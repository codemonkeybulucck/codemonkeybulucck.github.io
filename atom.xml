<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lemon&#39;s blog</title>
  
  <subtitle>让梦想实现的最好的方式，就是醒来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lemon2well.top/"/>
  <updated>2018-08-29T09:23:55.634Z</updated>
  <id>http://lemon2well.top/</id>
  
  <author>
    <name>lemon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中的圆角处理（终结篇）</title>
    <link href="http://lemon2well.top/2018/08/29/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E7%9A%84%E5%9C%86%E8%A7%92%E5%A4%84%E7%90%86%EF%BC%88%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%89/"/>
    <id>http://lemon2well.top/2018/08/29/iOS 开发/iOS中的圆角处理（终结篇）/</id>
    <published>2018-08-29T09:18:46.000Z</published>
    <updated>2018-08-29T09:23:55.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发中，我们经常用到圆角的处理，圆角看起来会比直角更加美观和柔美。但是设置圆角往往会带来一定的性能损耗，损耗的来源主要由于大量的离屏渲染，接下来我们就来讲一下如果实现高性能的圆角。我们下面来看以下几种设置圆角的方式以及它们对性能的影响。</p><h2 id="CornerRadius-masksToBounds"><a href="#CornerRadius-masksToBounds" class="headerlink" title="CornerRadius+masksToBounds"></a>CornerRadius+masksToBounds</h2><p>第一种方式就是我们最常用的设置圆角的方式，我们首先来看看<code>cornerRadius</code>的定义是什么：</p><blockquote><p>The radius to use when drawing rounded corners for the layer’s background. Animatable.<br>Setting the radius to a value greater than 0.0 causes the layer to begin drawing rounded corners on its background. By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to YES causes the content to be clipped to the rounded corners.<br>The default value of this property is 0.0.</p></blockquote><a id="more"></a><p>通过上面的解释我们可以看到cornerRadius只是对view的背景颜色和边框起作用，对于一些像ImageView以及Label等含有内部子视图的就不起作用了，这个时候我们往往还要添下下面这一句来让label生成一个适配圆角的剪切蒙版，该蒙版与label的边界相匹配，这样就达到了圆角的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label.layer.masksToBounds = YES;</span><br></pre></td></tr></table></figure><p>但是这样就会导致另外一个问题，离屏渲染。前面我们已经说了大量的离屏渲染会导致性能下降，最直观的感受就是如果在一个tableView中有大量的离屏渲染，就会导致FPS下降导致掉帧，界面看起来卡顿。</p><h3 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h3><p>我们通过模拟器的 <font color="#dd0000">Color-Off-screen-Render</font>可以看到那个元素产生了离屏渲染了，和很多人说的不一样，不可以统筹的说<font color="#dd0000">创建圆角是产生离屏渲染的原因</font>。<br>正确的来说：</p><font color="#dd0000"><br>view.layer.cornerRadius = 5;<br>view.layer.maskToBounds = YES;<br></font><br>这两句代码合在一起才是产生离屏渲染的原因。如下图所示，每个cell的第一和第二个的ImageView都是执行了上面的两句代码，产生了离屏幕渲染，而第三个棕色的圆形则是一个view，代码里面仅使用了<code>view.layer.cornerRadius</code>，所以没有产生离屏渲染。<br><br><img src="http://pcd17v2u0.bkt.clouddn.com/sim.png" alt="si"><br><br>如上所示，当一个tableView的离屏渲染达到了44个的时候，FPS下降到了35左右，性能下降得很厉害。所以如果一个界面上需要有很多的圆角的时候，这种方式不可取。<br><br>## CAShapeLayer + UIBezierPath<br><br>这种方式简直是<font color="#dd0000">噩梦</font>，我们先来看代码：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> CAShapeLayer *mask = [CAShapeLayer new];</span><br><span class="line">    mask.path = [UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:10].CGPath;</span><br><span class="line">imageView.layer.mask = mask;</span><br></pre></td></tr></table></figure><br><br>我们首先创建一个mask，然后通过贝塞尔曲线覆盖到原来的imageView上面，几行代码搞定。<br><br>### 性能影响<br><br>然后我们来看看界面是否会产生离屏渲染。<br><br><img src="http://pcd17v2u0.bkt.clouddn.com/sim2.png" alt="si"><br><br>如果不看一下真的吓一跳，全部的元素都产生了离屏渲染，还不如第一种方式。然后我们看一下FPS是10，其实都不用看FPS，直接页面上都能看出来了，卡到怀疑人生。<br><br>上面的方式是创建子控件的时候直接添加mask，还有一种方式是在 <code>-(void)drawRect:(CGRect)rect</code>里面添加mask，这样方式更加糟糕，因为不恰当的使用这个方法会导致内存暴增。举个例子，iPhone6 上与屏幕等大的 UIView，即使重写一个空的 drawRect 方法，它也至少占用 750 <em> 1134 </em> 4 字节 ≈ 3.4 Mb 的内存。在 <a href="http://bihongbo.com/2016/01/03/memoryGhostdrawRect/" target="_blank" rel="noopener">内存恶鬼drawRect</a> 及其后续中，作者详细介绍了其中原理，据他测试，在 iPhone6 上空的、与屏幕等大的视图重写 drawRect 方法会消耗 5.2 Mb 内存。总之，能避免重写 drawRect 方法就尽可能避免。<br><br>## Core Graphics<br>我们知道UIView其实是由CALayer和UIResponder组成，一个负责显示，一个负责响应。但是CALayer也只是一个普通的类，它并不能直接渲染到屏幕上，我们看到屏幕上面的东西其实也只是一张张图片，那为什么我们可以看到CALayer的内容呢。因为CALayer有一个content的属性，该属性可以传一个id类型的对象，当你传的对象为CGImage的时候，才会显示出来。<br><br>那通过Core Graphics 我们可以画出一个具有圆角的图片，然后添加到layer上面。<br><br>不过UIVIew和UIImageView的实现方式不一样，UIView的方式是创建一个空白的图片，然后插入到视图的最下面。而UIImageView是将在原来Image的基础上重新绘制一张带有圆角的图片，然后赋值给ImageView。<br><br>以下是关键代码：<br><br>UIVIew:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)lm_drawRectWithRoundedCorner:(CGFloat)radius</span><br><span class="line">                              borderWidth:(CGFloat)borderWidth</span><br><span class="line">                              borderColor:(UIColor *)borderColor</span><br><span class="line">                          backGroundColor:(UIColor*)bgColor&#123;</span><br><span class="line">    CGSize size = self.bounds.size;</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale);</span><br><span class="line">    CGContextRef contextRef =  UIGraphicsGetCurrentContext();</span><br><span class="line">    </span><br><span class="line">    CGContextSetLineWidth(contextRef, borderWidth);</span><br><span class="line">    CGContextSetStrokeColorWithColor(contextRef, borderColor.CGColor);</span><br><span class="line">    CGContextSetFillColorWithColor(contextRef, bgColor.CGColor);</span><br><span class="line">    </span><br><span class="line">    CGFloat halfBorderWidth = borderWidth / 2.0;</span><br><span class="line">    CGFloat width = size.width;</span><br><span class="line">    CGFloat height = size.height;</span><br><span class="line">    </span><br><span class="line">    CGContextMoveToPoint(contextRef, width - halfBorderWidth, radius + halfBorderWidth);</span><br><span class="line">    CGContextAddArcToPoint(contextRef, width - halfBorderWidth, height - halfBorderWidth, width - radius - halfBorderWidth, height - halfBorderWidth, radius);  // 右下角角度</span><br><span class="line">    CGContextAddArcToPoint(contextRef, halfBorderWidth, height - halfBorderWidth, halfBorderWidth, height - radius - halfBorderWidth, radius); // 左下角角度</span><br><span class="line">    CGContextAddArcToPoint(contextRef, halfBorderWidth, halfBorderWidth, width - halfBorderWidth, halfBorderWidth, radius); // 左上角</span><br><span class="line">    CGContextAddArcToPoint(contextRef, width - halfBorderWidth, halfBorderWidth, width - halfBorderWidth, radius + halfBorderWidth, radius); // 右上角</span><br><span class="line">    CGContextDrawPath(contextRef, kCGPathFillStroke);</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>————<br><br>UIImageVIew:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)lm_drawRectWithRoundedCorner:(CGFloat)radius</span><br><span class="line">                                     size:(CGSize)size&#123;</span><br><span class="line">    </span><br><span class="line">    CGRect rect = CGRectMake(0, 0, size.width, size.height);</span><br><span class="line">    </span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(rect.size, false, [UIScreen mainScreen].scale);</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, radius)];</span><br><span class="line">    CGContextAddPath(context, path.CGPath);</span><br><span class="line">    </span><br><span class="line">    CGContextClip(context);</span><br><span class="line">    </span><br><span class="line">    [self drawInRect:rect];</span><br><span class="line">    CGContextDrawPath(context, kCGPathFillStroke);</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return  image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 性能影响<br><br><img src="http://pcd17v2u0.bkt.clouddn.com/sim3.png" alt="si"><br><br><br>从上面的图片我们可以看出，设置圆角已经没有离屏渲染了，通过Core Animation可以看出FPS也回到60左右，界面也没有卡顿了。<br><br><font color="#dd0000">注意：即使我们使用了这种方式，我们还是要谨慎直接设置view.backGroundColor，因为我们没有设置maskToBounds属性，所以以这样的方式设置了背景颜色依然会导致没有圆角效果。<br>如果想要背景颜色，可以在画圆角图片的时候改变一下backGroundColor。</font><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，我们得出以下的结论：</p><ol><li>layer.cornerRadius不会触发离屏渲染，该属性只是对边框和背景颜色起作用，适用于内部没有其他控件的view。</li><li>CAShapeLayer+UIBezierPath会触发离屏渲染。</li><li>最好的方式就是使用Core Graphics的方式绘制圆角图片。</li><li>当然，还是那句话，根据场景来使用，如果界面中圆角的地方不多，第一种方式是最简单快捷，效率最高的。如果用到的圆角很多，那还是使用Core Graphics的方式把。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>本文章的代码已经放到Github，需要的可以自取。<a href="/Users/lemon/Desktop/练习/source Code/testImageSourceCode/CornerViewDemo">CornerViewDemo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在开发中，我们经常用到圆角的处理，圆角看起来会比直角更加美观和柔美。但是设置圆角往往会带来一定的性能损耗，损耗的来源主要由于大量的离屏渲染，接下来我们就来讲一下如果实现高性能的圆角。我们下面来看以下几种设置圆角的方式以及它们对性能的影响。&lt;/p&gt;
&lt;h2 id=&quot;CornerRadius-masksToBounds&quot;&gt;&lt;a href=&quot;#CornerRadius-masksToBounds&quot; class=&quot;headerlink&quot; title=&quot;CornerRadius+masksToBounds&quot;&gt;&lt;/a&gt;CornerRadius+masksToBounds&lt;/h2&gt;&lt;p&gt;第一种方式就是我们最常用的设置圆角的方式，我们首先来看看&lt;code&gt;cornerRadius&lt;/code&gt;的定义是什么：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The radius to use when drawing rounded corners for the layer’s background. Animatable.&lt;br&gt;Setting the radius to a value greater than 0.0 causes the layer to begin drawing rounded corners on its background. By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to YES causes the content to be clipped to the rounded corners.&lt;br&gt;The default value of this property is 0.0.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Runloop黑魔法之复活APP</title>
    <link href="http://lemon2well.top/2018/08/23/iOS%20%E5%BC%80%E5%8F%91/Runloop%E9%BB%91%E9%AD%94%E6%B3%95%E4%B9%8B%E5%A4%8D%E6%B4%BBAPP/"/>
    <id>http://lemon2well.top/2018/08/23/iOS 开发/Runloop黑魔法之复活APP/</id>
    <published>2018-08-23T02:18:42.000Z</published>
    <updated>2018-08-23T02:19:09.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Runloop黑魔法之复活APP"><a href="#Runloop黑魔法之复活APP" class="headerlink" title="Runloop黑魔法之复活APP"></a>Runloop黑魔法之复活APP</h1><p>看到这个标题是不是觉得很酷炫，但是我还要是解释一下标题是什么意思，以免有人说我标题党，我现在要做的就是当APP发生Crash的时候，不要让APP闪退，而是重新复活。</p><blockquote><p>换句话可以这么形容，把一个Crash信息吞掉，大家当没事发生过。</p></blockquote><p>说得这么牛批，这个东西有什么实际的用处呢？额，其实还真的没啥实际的用处，不过我们当发生异常信息的时候可以友好的弹一个框告诉用户当前发生了异常，是选择上传异常信息继续运行还是直接退出，当然继续运行依然会有Crash风险。</p><p>接下来我们就来实现这么一个事情吧。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>大家都知道，我们的APP能随时的处理事件就是因为有Runloop的存在，Runloop顾名思义就是一个环，不断的跑，并且Runloop是事件驱动的，也就是说没有事情做得时候就休眠，当有事情做的时候就做事情。</p><p>Runloop实际上是一个对象，这个对象管理了其所需要的消息和事件，并且提供了一个入口函数。线程执行了该函数之后，就会一直处于Runloop的内部，而Runloop的内部就会一直处于接受消息-&gt;处理-&gt;等待-&gt;接受消息这样的循环中。直到这个循环结束，线程才会退出。</p><p>想想如果我们的APP接受到Exception消息的时候，我们先获得当前的Runloop，然后获取所有的mode，自行创建一个死循环，让runloop在里面执行不同的mode，这样就相当于让Runloop起死回生了，这样APP也复活了。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>在我前面写得这一篇<a href="http://lemon2well.top/2018/08/22/iOS%20%E5%BC%80%E5%8F%91/iOS%E6%94%B6%E9%9B%86Crash%E4%BF%A1%E6%81%AF%E4%B8%8A%E6%8A%A5/">iOSCrash信息上报和处理</a>中我们已经实现了监听Exception事件，所以我们在监听到该事件之后插入以下代码即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获得当前的runloop并且重新启动</span><br><span class="line">   CFRunLoopRef runloop = CFRunLoopGetCurrent();</span><br><span class="line">   NSArray *modes = CFBridgingRelease(CFRunLoopCopyAllModes(runloop));</span><br><span class="line">   while (!self.isExit) &#123;</span><br><span class="line">       for (NSString *mode in modes) &#123;</span><br><span class="line">           CFRunLoopRunInMode((CFStringRef)mode, 0.001, false);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们来逐行看一下上面的代码，首先我们获取到当前的Runloop，然后我们获取到当前Runloop的所有mode，然后我们创建一个循环，在里面不断的跑所有的mode，这样就实现了APP的复活。</p><p><a href="https://github.com/codemonkeybulucck/RunloopResurgenceAPP" target="_blank" rel="noopener">这里</a>是完整的demo</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Runloop是个好东西，它能做的事情远远超出我们的想像，虽然我们开发中很少直接去接触Runloop，但是它却起着无比重要的作用，所以下面提供一些关于Runloop的资料介绍：</p><p><a href="https://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="noopener">sunnyxx线下分享Runloop</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">ibireme深入理解Runloop</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Runloop黑魔法之复活APP&quot;&gt;&lt;a href=&quot;#Runloop黑魔法之复活APP&quot; class=&quot;headerlink&quot; title=&quot;Runloop黑魔法之复活APP&quot;&gt;&lt;/a&gt;Runloop黑魔法之复活APP&lt;/h1&gt;&lt;p&gt;看到这个标题是不是觉得很酷炫，但是我还要是解释一下标题是什么意思，以免有人说我标题党，我现在要做的就是当APP发生Crash的时候，不要让APP闪退，而是重新复活。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;换句话可以这么形容，把一个Crash信息吞掉，大家当没事发生过。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说得这么牛批，这个东西有什么实际的用处呢？额，其实还真的没啥实际的用处，不过我们当发生异常信息的时候可以友好的弹一个框告诉用户当前发生了异常，是选择上传异常信息继续运行还是直接退出，当然继续运行依然会有Crash风险。&lt;/p&gt;
&lt;p&gt;接下来我们就来实现这么一个事情吧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOSCrash信息上报和处理</title>
    <link href="http://lemon2well.top/2018/08/22/iOS%20%E5%BC%80%E5%8F%91/iOSCrash%E4%BF%A1%E6%81%AF%E4%B8%8A%E6%8A%A5%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>http://lemon2well.top/2018/08/22/iOS 开发/iOSCrash信息上报和处理/</id>
    <published>2018-08-22T09:41:36.000Z</published>
    <updated>2018-08-23T01:46:25.542Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发中，最严重的bug估计就是应用奔溃，如果应用奔溃了，除了做好挨骂的准备，还需要冷静的下来去处理这个事情，接下来我们来看看需要做什么事情。</p><h2 id="获取crash信息"><a href="#获取crash信息" class="headerlink" title="获取crash信息"></a>获取crash信息</h2><p>我们首先第一个事情就是要知道应用的奔溃信息是什么，这里有几种方式去获取奔溃信息。</p><ol><li>使用Bugly，友盟等第三方SDK登入后台查看奔溃信息</li><li>代码自动上传奔溃信息到服务器，然后通过恢复dSYM文件来查看奔溃信息</li><li>通过使用当前发生应用奔溃的设备导出相关的奔溃信息</li><li>如果是线上的应用，还可以通过itunesConnect来查看（非即时）</li></ol><a id="more"></a><p>第一种集成第三方SDK的方案基本上不用我们管，只需要根据文档集成即可。<br>下面我们要讲的是第二种和第三种方案，第四种方案其实和第三种方案差不多，为什么要区分这两种方案呢，因为第二种方案中我们可以直接拿到奔溃的堆栈和具体信息，也就是可以看出在那段代码奔溃以及具体的奔溃内容。但是第三种和第四种方案我们拿到的奔溃信息是经过处理的奔溃信息，如下面所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Incident Identifier: 66BAB91F-07F7-4242-B8EF-8CC1771E5EF0</span><br><span class="line">CrashReporter Key:   bb6af27d5f29cc19a8df5dbdff702227fdb1232b</span><br><span class="line">Hardware Model:      iPhone8,1</span><br><span class="line">Process:             testImageSourceCode [25042]</span><br><span class="line">Path:                /private/var/containers/Bundle/Application/C8A371D9-3F19-4A17-A817-5FF35A40C8E7/testImageSourceCode.app/testImageSourceCode</span><br><span class="line">Identifier:          com.cmcc.enterprise-classID.onecardmultinumber.sdk</span><br><span class="line">Version:             1 (1.0)</span><br><span class="line">Code Type:           ARM-64 (Native)</span><br><span class="line">Role:                Foreground</span><br><span class="line">Parent Process:      launchd [1]</span><br><span class="line">Coalition:           com.cmcc.enterprise-classID.onecardmultinumber.sdk [8274]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Date/Time:           2018-08-22 15:35:09.3494 +0800</span><br><span class="line">Launch Time:         2018-08-22 15:35:03.3154 +0800</span><br><span class="line">OS Version:          iPhone OS 11.3.1 (15E302)</span><br><span class="line">Baseband Version:    4.56.00</span><br><span class="line">Report Version:      104</span><br><span class="line"></span><br><span class="line">Exception Type:  EXC_CRASH (SIGABRT)</span><br><span class="line">Exception Codes: 0x0000000000000000, 0x0000000000000000</span><br><span class="line">Exception Note:  EXC_CORPSE_NOTIFY</span><br><span class="line">Triggered by Thread:  0</span><br><span class="line"></span><br><span class="line">Application Specific Information:</span><br><span class="line">abort() called</span><br><span class="line"></span><br><span class="line">Filtered syslog:</span><br><span class="line">None found</span><br><span class="line"></span><br><span class="line">Last Exception Backtrace:</span><br><span class="line">0   CoreFoundation                0x184152d8c __exceptionPreprocess + 228</span><br><span class="line">1   libobjc.A.dylib               0x18330c5ec objc_exception_throw + 55</span><br><span class="line">2   CoreFoundation                0x1840eb750 _CFThrowFormattedException + 111</span><br><span class="line">3   CoreFoundation                0x18401b90c -[__NSArrayI objectAtIndex:] + 131</span><br><span class="line">4   testImageSourceCode           0x100d55ee4 _hidden#0_ + 24292 (__hidden#4_:14)</span><br><span class="line">5   testImageSourceCode           0x100d5ed6c _hidden#425_ + 60780 (__hidden#452_:131)</span><br><span class="line">6   UIKit                         0x18de826c8 -[UIApplication sendAction:to:from:forEvent:] + 95</span><br><span class="line">7   UIKit                         0x18dfa38a4 -[UIControl sendAction:to:forEvent:] + 79</span><br><span class="line">8   UIKit                         0x18de8877c -[UIControl _sendActionsForEvents:withEvent:] + 439</span><br><span class="line">9   UIKit                         0x18dfbe1dc -[UIControl touchesEnded:withEvent:] + 571</span><br><span class="line">10  UIKit                         0x18df05a48 -[UIWindow _sendTouchesForEvent:] + 2427</span><br><span class="line">11  UIKit                         0x18defa8f8 -[UIWindow sendEvent:] + 3159</span><br><span class="line">12  UIKit                         0x18def9238 -[UIApplication sendEvent:] + 339</span><br><span class="line">13  UIKit                         0x18e6dac0c __dispatchPreprocessedEventFromEventQueue + 2339</span><br><span class="line">14  UIKit                         0x18e6dd1b8 __handleEventQueueInternal + 4743</span><br><span class="line">15  UIKit                         0x18e6d6258 __handleHIDEventFetcherDrain + 151</span><br><span class="line">16  CoreFoundation                0x1840fb404 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 23</span><br><span class="line">17  CoreFoundation                0x1840fac2c __CFRunLoopDoSources0 + 275</span><br><span class="line">18  CoreFoundation                0x1840f879c __CFRunLoopRun + 1203</span><br><span class="line">19  CoreFoundation                0x184018da8 CFRunLoopRunSpecific + 551</span><br><span class="line">20  GraphicsServices              0x185ffb020 GSEventRunModal + 99</span><br><span class="line">21  UIKit                         0x18dff978c UIApplicationMain + 235</span><br><span class="line">22  testImageSourceCode           0x100d75ca8 main + 154792 (__hidden#956_:14)</span><br><span class="line">23  libdyld.dylib                 0x183aa9fc0 start + 3</span><br></pre></td></tr></table></figure><p>看到上面的奔溃信息我们是一脸懵逼的，完全看不出是因为哪里的代码导致了错误，这个时候我们就要进行符号化，通过dSYM文件通过奔溃信息的地址找到源码中奔溃的地方。这个我们放到第三点来讲，下面我们先将第二个方案。</p><h2 id="收集Crash信息"><a href="#收集Crash信息" class="headerlink" title="收集Crash信息"></a>收集Crash信息</h2><p>在iOS中，系统给我们提供了<code>NSException</code>这个类来帮助我们收集异常信息。</p><blockquote><p>NSException is used to implement exception handling and contains information about an exception — Apple Documentation.</p></blockquote><p>我们可以看一下这个类里面都包含什么属性和方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface NSException : NSObject &lt;NSCopying, NSCoding&gt; &#123;</span><br><span class="line">    @private</span><br><span class="line">    NSString*name;</span><br><span class="line">    NSString*reason;</span><br><span class="line">    NSDictionary*userInfo;</span><br><span class="line">    idreserved;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSException *)exceptionWithName:(NSExceptionName)name reason:(nullable NSString *)reason userInfo:(nullable NSDictionary *)userInfo;</span><br><span class="line">- (instancetype)initWithName:(NSExceptionName)aName reason:(nullable NSString *)aReason userInfo:(nullable NSDictionary *)aUserInfo NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">@property (readonly, copy) NSExceptionName name;</span><br><span class="line">@property (nullable, readonly, copy) NSString *reason;</span><br><span class="line">@property (nullable, readonly, copy) NSDictionary *userInfo;</span><br><span class="line"></span><br><span class="line">@property (readonly, copy) NSArray&lt;NSNumber *&gt; *callStackReturnAddresses API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line">@property (readonly, copy) NSArray&lt;NSString *&gt; *callStackSymbols API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));</span><br><span class="line"></span><br><span class="line">- (void)raise;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>我们来看看几个比较重要的属性和方法：<br>例如我们碰到一个<code>name: @&quot;NSRangeException&quot; - reason: @&quot;*** -[__NSArrayI objectAtIndex:]: index 3 beyond bounds [0 .. 1]&quot;</code>这样的错误</p><blockquote><ol><li>name : exception的名字，在上面中就是NSRangeException</li><li>reason : exception的原因，这是我们修复的最主要的提示。也就是上面的[__NSArrayI objectAtIndex:]: index 3 beyond bounds [0 .. 1]。</li><li>userInfo : 其他信息，一般用于自定义的时候传递一些其他的信息。</li><li>callStackSymbols : 这个产生Exception的调用栈，从下到上。</li><li>raise方法，这个方法就是让系统产生Exception，例如我们的APP如果检测到正在被其他不怀好意的人调试的时候，可以创建一个NSException的方法，然后调用raise直接闪退，不过他也有可能hook了这个方法，这里就不多说了。</li></ol></blockquote><p>既然我们知道了有这么一个类，那我们如何来捕捉系统异常呢，Crash分为两种，一种是由EXC_BAD_ACCESS引起的，原因是访问了不属于本进程的内存地址，有可能是访问已被释放的内存；另一种是未被捕获的Objective-C异常（NSException），导致程序向自身发送了SIGABRT信号而崩溃。其实对于未捕获的Objective-C异常，我们是有办法将它记录下来的。</p><p>我们先说第一种，第一种就是我们上面所说的Exception，系统提供了一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT void NSSetUncaughtExceptionHandler(NSUncaughtExceptionHandler * _Nullable);</span><br></pre></td></tr></table></figure><p>方法来捕获异常，这个方法一般会在程序启动的时候就调用一次，这样才能保证捕获所有的异常。<br>在APPDelegate的didFinishLaunch方法中 调用  <code>NSSetUncaughtExceptionHandler(&amp;CrashExceptionHandler);</code><br>然后增加一个方法的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void CrashExceptionHandler(NSException *exception)&#123;</span><br><span class="line">    NSArray *callStack = [exception callStackSymbols];</span><br><span class="line">    NSString *reson = [exception reason];</span><br><span class="line">    NSString *name = [exception name];</span><br><span class="line">   //TODO: 保存奔溃信息到本地，下次启动的时候上传到服务器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看看第二种异常，这种异常通过上面的方法无法捕捉，但是系统会发送一个信号，我们可以通过注册对应的Signal信息来监听是否捕捉到系统发出的异常信号。</p><p>同样是在APPDelaget中加入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGABRT, SignalExceptionHandler);</span><br><span class="line">signal(SIGILL, SignalExceptionHandler);</span><br><span class="line">signal(SIGSEGV, SignalExceptionHandler);</span><br><span class="line">signal(SIGFPE, SignalExceptionHandler);</span><br><span class="line">signal(SIGBUS, SignalExceptionHandler);</span><br><span class="line">signal(SIGPIPE, SignalExceptionHandler);</span><br></pre></td></tr></table></figure><p>然后实现 <code>SignalExceptionHandler</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void SignalExceptionHandler(int signal)&#123;</span><br><span class="line">    NSArray *callStack = [LMExceptionHandler backtrace];</span><br><span class="line">    NSLog(@&quot;信号捕获崩溃，堆栈信息：%@&quot;,callStack);</span><br><span class="line">    NSString *name = LMSignalException;</span><br><span class="line">    NSString *reason = [NSString stringWithFormat:@&quot;signal %d was raised&quot;,signal];</span><br><span class="line">    //TODO: 保存信息上传到本地</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSArray *)backtrace</span><br><span class="line">&#123;</span><br><span class="line">    void* callstack[128];</span><br><span class="line">    int frames = backtrace(callstack, 128);</span><br><span class="line">    char **strs = backtrace_symbols(callstack, frames);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];</span><br><span class="line">    for (int i = 0; i &lt; frames; i++) &#123;</span><br><span class="line">        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    free(strs);</span><br><span class="line">    </span><br><span class="line">    return backtrace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上的方法我们已经可以捕获到系统的crash信息，从而根据信息修复相关的bug。</p><h2 id="通过Xcode查看Crash信息"><a href="#通过Xcode查看Crash信息" class="headerlink" title="通过Xcode查看Crash信息"></a>通过Xcode查看Crash信息</h2><p>如果奔溃发生在我们测试的设备上面，那么奔溃信息是保存到我们手机本地的，这个时候我们可以通过xcode来查看。</p><p>手机连接电脑，然后打开Xcode，点击Window-&gt;Devices And Simulators-&gt;左侧选择对应的设备，然后右侧点击View Device Logs，然后就可以看到以下的奔溃信息，你可以在搜索出对应的APP也可以根据时间来排序找到对应的那一条奔溃信息。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15349278888373.jpg" alt=""></p><p>如上图所示我们其实是看不出具体的错误信息以及堆栈信息的，根据这些我们很难再代码中找到导致奔溃的代码在哪里。接下来我们就要开始通过dSYM文件找到对应的堆栈。</p><h2 id="dSYM"><a href="#dSYM" class="headerlink" title="dSYM"></a>dSYM</h2><p>进行崩溃分析，首先要弄懂一个概念，就是符号集。</p><blockquote><p>符号集是我们对ipa文件进行打包之后，和.app文件同级的后缀名为.dSYM的文件，这个文件必须使用Xcode进行打包才有。<br>每一个.dSYM文件都有一个UUID，和.app文件中的UUID对应，代表着是一个应用。而.dSYM文件中每一条崩溃信息也有一个单独的UUID，用来和程序的UUID进行校对。<br>我们如果不使用.dSYM文件获取到的崩溃信息都是不准确的。<br>符号集中存储着文件名、方法名、行号的信息，是和可执行文件的16进制函数地址对应的，通过分析崩溃的.Crash文件可以准确知道具体的崩溃信息。<br>我们每次Archive一个包之后，都会随之生成一个dSYM文件。每次发布一个版本，我们都需要备份这个文件，以方便以后的调试。进行崩溃信息符号化的时候，必须使用当前应用打包的电脑所生成的dSYM文件，其他电脑生成的文件可能会导致分析不准确的问题。</p></blockquote><h2 id="符号化crash信息"><a href="#符号化crash信息" class="headerlink" title="符号化crash信息"></a>符号化crash信息</h2><p>当程序崩溃的时候，我们可以获得到崩溃的错误堆栈，但是这个错误堆栈都是0x开头的16进制地址，需要我们使用Xcode自带的atos工具或者<a href="https://github.com/answer-huang/dSYMTools" target="_blank" rel="noopener">dSYMTools</a>来将.Crash和.dSYM文件进行符号化，就可以得到详细崩溃的信息。</p><p>那我们如何得到dSYM文件呢</p><blockquote><p>先打开Xcode，Windows-&gt;Organize-&gt;找到对应的app包，然后右键-&gt;Show in finder,找到appName. xcarchive-&gt;显示包内容-&gt;把dSYMs拷贝出来(或者就在里面操作)。</p></blockquote><p>我们可以新建一个CrashFolder的文件夹，然后将上面的dSYMs文件拷贝到该文件夹中，然后我们还需要找到上面的Crash信息，然后右键导出该Crash信息，同样拷贝到CrashFolder文件夹中，接下来我们就可以利用atos来将Crash文件中的地址还原为代码。</p><p>atos的基本用法为：</p><p><code>$ atos -arch &lt;Binary Architecture&gt; -o &lt;Path to dSYM file&gt;/Contents/Resources/DWARF/&lt;binary image name&gt; -l &lt;load address&gt; &lt;address to symbolicate&gt;</code></p><p>在我本地中，我执行的是：<code>atos -arch arm64 -o testImageSourceCode.app.dSYM/Contents/Resources/DWARF/testImageSourceCode -l 0x100d50000 0x100d55ee4</code></p><p>在上述命令中，需要解释的可能就是-l后面的两个参数，第一个参数是程序的基地址，也就是在crash文件中，在 <code>Binary Images:</code>下面的第一行中的第一个以0X开头的地址，然后第二个参数就是Crash文件中错误信息的地址，执行完上述命令之后输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[LMTool test] (in testImageSourceCode) (LMTool.m:15)</span><br></pre></td></tr></table></figure><p>字符串，该字符串就是对应代码中的方法以及对应的文件里面的行数。</p><p>另外一个方法就是使用一个第三方工具<a href="https://github.com/answer-huang/dSYMTools" target="_blank" rel="noopener">dSYMTools</a>这里的用法和我们上述的差不多，只不过那里是可视化工具。</p><p>完整的<a href="https://github.com/codemonkeybulucck/CrashCatchDemo" target="_blank" rel="noopener">demo</a>已经上传到Github。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发中，最严重的bug估计就是应用奔溃，如果应用奔溃了，除了做好挨骂的准备，还需要冷静的下来去处理这个事情，接下来我们来看看需要做什么事情。&lt;/p&gt;
&lt;h2 id=&quot;获取crash信息&quot;&gt;&lt;a href=&quot;#获取crash信息&quot; class=&quot;headerlink&quot; title=&quot;获取crash信息&quot;&gt;&lt;/a&gt;获取crash信息&lt;/h2&gt;&lt;p&gt;我们首先第一个事情就是要知道应用的奔溃信息是什么，这里有几种方式去获取奔溃信息。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用Bugly，友盟等第三方SDK登入后台查看奔溃信息&lt;/li&gt;
&lt;li&gt;代码自动上传奔溃信息到服务器，然后通过恢复dSYM文件来查看奔溃信息&lt;/li&gt;
&lt;li&gt;通过使用当前发生应用奔溃的设备导出相关的奔溃信息&lt;/li&gt;
&lt;li&gt;如果是线上的应用，还可以通过itunesConnect来查看（非即时）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>NSRunLoop与iOS中的倒计时（GCD,CADisplaylink,NSTimer）</title>
    <link href="http://lemon2well.top/2018/08/20/iOS%20%E5%BC%80%E5%8F%91/NSRunLoop%E4%B8%8EiOS%E4%B8%AD%E7%9A%84%E5%80%92%E8%AE%A1%E6%97%B6%EF%BC%88GCD-CADisplaylink-NSTimer%EF%BC%89/"/>
    <id>http://lemon2well.top/2018/08/20/iOS 开发/NSRunLoop与iOS中的倒计时（GCD-CADisplaylink-NSTimer）/</id>
    <published>2018-08-20T03:17:45.000Z</published>
    <updated>2018-08-20T03:18:42.822Z</updated>
    
    <content type="html"><![CDATA[<p>相信在iOS开发中大家都用过倒计时的功能，而NSTimer也是大家用得最多用来实现该功能的类，但是可能有人不太清楚NSTimer存在计时不准并且可能会导致引用循环资源无法释放的情况，接下来我会介绍一下使用GCD以及CADisplaylink来实现倒计时以及他们三者的利弊。</p><h2 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h2><p>在开始介绍下面三种方法之前，我想我们有必要先来介绍一下RunLoop，因为CADisplaylink和NSTimer都是需要通过运行在RunLoop里面才保证了每次到特定的时间点就会执行对应的事件</p><a id="more"></a><h2 id="RunLoop是什么"><a href="#RunLoop是什么" class="headerlink" title="RunLoop是什么"></a>RunLoop是什么</h2><p>一般来说线程只能执行一次任务，执行完任务之后就会退出，可是如果需要处理多个任务呢，那就需要RunLoop来保证线程能随时处理事件并且不会退出。</p><p>RunLoop实际上像是一个对象，该对象提供了一个入口函数，该入口函数会实现像不断的循环获取任务执行任务的功能，当线程执行了这个入口函数之后，就会一直处于函数内部：接受任务-&gt;等待-&gt;处理这样的循环中，知道接受到quit消息，就会推出该入口函数，然后线程销毁。</p><h2 id="RunLoop和线程之间的关系"><a href="#RunLoop和线程之间的关系" class="headerlink" title="RunLoop和线程之间的关系"></a>RunLoop和线程之间的关系</h2><p>RunLoop和线程是一一对应的，它们通过key-value的形式保存在一个全局的字典里面（key是p_thread,value是CFRunLoopRef），iOS中不允许直接创建RunLoop，可以通过两个方法获取RunLoop ，CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个方法内部会调用<code>CFRunLoopRef _CFRunLoopGet(pthread_t thread)</code>方法，调用该方法时，会优先判断该字典是不是为空，如果是的话就创建一个以pthread_main_thread_np()为key的runloop并且放到字典里面。然后在字典中寻找thread为key的runloop，如果不存在则创建一个新的RunLoop并且注册一个回调，当线程销毁时，也销毁RunLoop。</p><h2 id="RunLoopMode"><a href="#RunLoopMode" class="headerlink" title="RunLoopMode"></a>RunLoopMode</h2><p>苹果提供了两个公开的RunLoopMode，NSDefaultRunLoop以及UITrackingRunLoopMode，第一个mode程序默认的mode，当程序中有ScrollView滚动的时候，RunLoop就会将当前的mode切换为UITrackingRunLoopMode。</p><blockquote><p>相信很多人都有过NSTimer在默认情况下可用，当APP有ScrollView在滚动的时候就不可用的回调，那是因为NSTimer加到runloop里面的时候默认是NSDefaultRunLoop，当页面滑动的时候RunLoop切换到了UITrackingRunLoopMode，所以timer就不起作用了，这个时候需要使用<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code>将timer标记为NSRunLoopCommonModes，NSRunLoopCommonModes默认是包含了NSDefaultRunLoop和UITrackingRunLoopMode两个model。</p></blockquote><h2 id="RunLoop的结构"><a href="#RunLoop的结构" class="headerlink" title="RunLoop的结构"></a>RunLoop的结构</h2><p>我们首先来看一下RunLoop的都包含什么东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_CFRunLoop:</p><ul><li><p>_commonModes： 一个标记为common的集合，通过<code>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</code>可以将一个mode加到commonModes里面，当RunLoop的内容变化的时候，RunLoop都会将Timer/Observer/Sources同步到标记为“common”的Mode里面</p></li><li><p>_commonModeItems： 被加到CommonModes里面的所有的Item的集合，一个Item包含_source0,_source1,_observers，_timers。</p></li><li><p>_currentMode： 当前RunLoop的mode，可以通过 <code>CFRunLoopRunInMode(CFStringRef modeName, ...);</code>来切换mode</p></li><li><p>_modes：RunLoop包含的mode</p></li></ul><p>_CFRunLoopMode:</p><ul><li><p>source0(CFRunLoopSourceRef)： mode的事件源，source0只包含一个回调（函数指针），它并不会自动触发，需要先调用 <code>CFRunLoopSourceSinal(source)</code>将source标为待处理，然后调用<code>CFRunLoopSourceWakeUp(source)</code>来唤醒RunLoop才会调用这个方法。</p></li><li><p>_sources1(CFRunLoopSourceRef)： mode的另外一个事件源，source1包含了回调以及一个mach-port，被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程</p></li><li><p>_timers: 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）</p></li><li><p>_observers: 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</p></li></ul><p>更多的关于RunLoop的内容可以看<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p><h2 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h2><p>我们通常会使用以下的代码来创建一个Timer并且将Timer加到RunLoop里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sellf.timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(doSomeThing) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p>以上的代码会有两个问题：</p><ol><li>内存泄漏的问题，首先RunLoop会强引用timer，而timer会强引用self,所以timer不释放的时候，self也无法释放。通常我们会用以下的代码来释放Timer，但是需要找一个合适的时机去释放它，加入我们像以下代码那样在viewWillDisapper那样释放它，当回到主屏幕的时候那timer又要被销毁了，然后重新进入重新创建一个timer，这样就会非常麻烦，需要多个地方维护timer的状态。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillDisappear:(BOOL)animated&#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    self.timer  = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显我们这里要解决的就是timer的释放时机的问题，我们当然是希望持有timer的视图控制器执行dealloc释放的时候释放它，但是这时候千万别企图在dealloc方法里面做这个事情，原因自己想。</p><p>我们的思路就是通过创建一个MagicClass来弱应用这个target，然后timer的target强引用这个MagicClass，执行MagicClass的一个替身Action，在这个Action里面我们可以判断target是不是被销毁了（因为这个时候没有Timer强引用它，所以不会有有内存泄漏的问题），然后没有被销毁则执行真正的Action，如果Target已经被销毁了则调用invalidate销毁timer。</p><p>here is the code</p><p>NSTimer+LMExtension.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSTimer (LMExtension)</span><br><span class="line">+ (instancetype)lmScheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)target selector:(SEL)selector userInfo:(id)userInfo;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>NSTimer+LMExtension.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSTimer+LMExtension.h&quot;</span><br><span class="line"></span><br><span class="line">@interface LMMagicTarget : NSObject</span><br><span class="line">@property (nonatomic, weak) id target;</span><br><span class="line">@property (nonatomic, assign) SEL selector;</span><br><span class="line">@property (nonatomic, weak) NSTimer *timer;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation LMMagicTarget</span><br><span class="line">- (void)LMTimerStarAction:(NSTimer *)timer</span><br><span class="line">&#123;</span><br><span class="line">    if (self.target) &#123;</span><br><span class="line">        [self.target performSelector:self.selector withObject:timer afterDelay:0.0];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.timer invalidate];</span><br><span class="line">        self.timer = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation NSTimer (LMExtension)</span><br><span class="line">+ (instancetype)lmScheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)target selector:(SEL)selector userInfo:(id)userInfo&#123;</span><br><span class="line">    LMMagicTarget *magicTarget = [[LMMagicTarget alloc]init];</span><br><span class="line">    magicTarget.target = target;</span><br><span class="line">    magicTarget.selector = selector;</span><br><span class="line">    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:interval target:magicTarget selector:@selector(LMTimerStarAction:) userInfo:nil repeats:YES];</span><br><span class="line">    magicTarget.timer = timer;</span><br><span class="line">    return  timer;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ol start="2"><li>第二个问题，精度问题。NSTimer其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的，一个timer注册好后，RunLoop会在其重复的时间点注册事件，但是如果这个时候RunLoop正在处理一个其他任务的时候，错过了该事件点，则该次不会执行timer的事件源，会跳过当前时间点，直到下一个时间点才执行该timer的事件源。所以timer会有一个Tolerance的属性，这属性就是宽容度，该属性标记当时间点到了后，容许有多少的误差。</li></ol><h2 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h2><p>CADisplayLink是一个以屏幕刷新频率同步的计时器。以下是创建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建方法</span><br><span class="line">self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink:)];    </span><br><span class="line">[self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">停止方法</span><br><span class="line">[self.displayLink invalidate];  </span><br><span class="line">self.displayLink = nil;</span><br></pre></td></tr></table></figure><p>CADisplayLink的计算时间并不依靠RunLoop，当一个屏幕刷新完成时候则会通知RunLoop给对应的target执行action。但是CADisplayLink依然会有精度的问题，当两次界面刷新之间执行了一次长任务的时候，那就会有一帧被跳过去，也就是所谓的掉帧，那相应的此次也不会调用target的action。</p><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>GCD提供了一个计时的方法，GCD定时器的底层是由XNU内核中的select方法实现的。具体的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW , 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</span><br><span class="line">    dispatch_source_set_event_handler(self.timer, ^&#123;</span><br><span class="line">        NSLog(@&quot;GCD&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    //开启定时器</span><br><span class="line">    dispatch_resume(self.timer);</span><br><span class="line">    </span><br><span class="line">    //销毁定时器</span><br><span class="line">    dispatch_source_cancel(self.timer);</span><br><span class="line">    self.timer = nil;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果是对时间的要求不精确的计算，可以使用NSTimer，如果是对时间比较精确的，可以使用GCD提供的倒计时方法。如果是实现动画，需要高频率的绘制，可以使用CADisplayLink。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信在iOS开发中大家都用过倒计时的功能，而NSTimer也是大家用得最多用来实现该功能的类，但是可能有人不太清楚NSTimer存在计时不准并且可能会导致引用循环资源无法释放的情况，接下来我会介绍一下使用GCD以及CADisplaylink来实现倒计时以及他们三者的利弊。&lt;/p&gt;
&lt;h2 id=&quot;RunLoop&quot;&gt;&lt;a href=&quot;#RunLoop&quot; class=&quot;headerlink&quot; title=&quot;RunLoop&quot;&gt;&lt;/a&gt;RunLoop&lt;/h2&gt;&lt;p&gt;在开始介绍下面三种方法之前，我想我们有必要先来介绍一下RunLoop，因为CADisplaylink和NSTimer都是需要通过运行在RunLoop里面才保证了每次到特定的时间点就会执行对应的事件&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>图文混排的四种方案</title>
    <link href="http://lemon2well.top/2018/08/15/iOS%20%E5%BC%80%E5%8F%91/%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
    <id>http://lemon2well.top/2018/08/15/iOS 开发/图文混排的四种方案/</id>
    <published>2018-08-15T09:12:26.000Z</published>
    <updated>2018-08-15T09:21:15.954Z</updated>
    
    <content type="html"><![CDATA[<p>图文混排有多种方式可以实现，下面我会用四种不同的方式来实现以下界面的效果，并且说明他们的优缺点。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/screenshot.png" alt="screenshot"></p><h2 id="NSAttributedString"><a href="#NSAttributedString" class="headerlink" title="NSAttributedString"></a>NSAttributedString</h2><blockquote><p>NSAttributedString提供了自由并且多样式的富文本设置，图文混排的实现是通过插入NSTestAttachment来实现。</p></blockquote><a id="more"></a><p>talk is cheap ，here is the code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//调用</span><br><span class="line">NSString *originStr = @&quot; Hi ALL,这是我的博客：lemon2well.top，欢迎来到我的博客，环欢迎评论留言一起交流。&quot;;</span><br><span class="line">    NSString *targetStr = @&quot;lemon2well.top&quot;;</span><br><span class="line">    NSString *imageName = @&quot;trumpet&quot;;</span><br><span class="line">    self.label.attributedText = [self attribuStringWithString:originStr targetString:targetStr image:imageName];</span><br><span class="line"></span><br><span class="line">//方法</span><br><span class="line">- (NSAttributedString*)attribuStringWithString:(NSString*)string targetString:(NSString *)target image:(NSString*)imageName&#123;</span><br><span class="line">    NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc]initWithString:string attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">    </span><br><span class="line">    NSRange linkRange = [string rangeOfString:target];</span><br><span class="line">    if (linkRange.length != 0) &#123;</span><br><span class="line">        //添加可点击链接</span><br><span class="line">        [attributedStr addAttribute:NSLinkAttributeName value:[NSURL URLWithString:@&quot;lemon2well.top&quot;] range:linkRange];</span><br><span class="line">        [attributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:linkRange];</span><br><span class="line">        //添加下划线</span><br><span class="line">        [attributedStr addAttribute:NSUnderlineStyleAttributeName value:@1 range:linkRange];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //添加图片</span><br><span class="line">    NSTextAttachment *attachment = [[NSTextAttachment alloc]init];</span><br><span class="line">    attachment.image = [UIImage imageNamed:imageName];</span><br><span class="line">    attachment.bounds = CGRectMake(0, 0, 20 ,20);</span><br><span class="line">    NSAttributedString *imageStr = [NSAttributedString attributedStringWithAttachment:attachment];</span><br><span class="line">    //插入图片</span><br><span class="line">    [attributedStr insertAttributedString:imageStr atIndex:0];</span><br><span class="line">    </span><br><span class="line">    // 段落样式</span><br><span class="line">    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init];</span><br><span class="line">    // 行间距</span><br><span class="line">    [style setLineSpacing:3];</span><br><span class="line">    // 段落间距</span><br><span class="line">    [style setParagraphSpacing:10];</span><br><span class="line">    // 首行缩进</span><br><span class="line">    [style setFirstLineHeadIndent:25];</span><br><span class="line">    [attributedStr addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, string.length-1)];</span><br><span class="line">    </span><br><span class="line">    return attributedStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是NSAttributedString的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// NSFontAttributeName                设置字体属性，默认值：字体：Helvetica(Neue) 字号：12</span><br><span class="line">// NSForegroundColorAttributeNam      设置字体颜色，取值为 UIColor对象，默认值为黑色</span><br><span class="line">// NSBackgroundColorAttributeName     设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色</span><br><span class="line">// NSLigatureAttributeName            设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符</span><br><span class="line">// NSKernAttributeName                设定字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄</span><br><span class="line">// NSStrikethroughStyleAttributeName  设置删除线，取值为 NSNumber 对象（整数）</span><br><span class="line">// NSStrikethroughColorAttributeName  设置删除线颜色，取值为 UIColor 对象，默认值为黑色</span><br><span class="line">// NSUnderlineStyleAttributeName      设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似</span><br><span class="line">// NSUnderlineColorAttributeName      设置下划线颜色，取值为 UIColor 对象，默认值为黑色</span><br><span class="line">// NSStrokeWidthAttributeName         设置笔画宽度，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果</span><br><span class="line">// NSStrokeColorAttributeName         填充部分颜色，不是字体颜色，取值为 UIColor 对象</span><br><span class="line">// NSShadowAttributeName              设置阴影属性，取值为 NSShadow 对象</span><br><span class="line">// NSTextEffectAttributeName          设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用：</span><br><span class="line">// NSBaselineOffsetAttributeName      设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏</span><br><span class="line">// NSObliquenessAttributeName         设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾</span><br><span class="line">// NSExpansionAttributeName           设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本</span><br><span class="line">// NSWritingDirectionAttributeName    设置文字书写方向，从左向右书写或者从右向左书写</span><br><span class="line">// NSVerticalGlyphFormAttributeName   设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本</span><br><span class="line">// NSLinkAttributeName                设置链接属性，点击后调用浏览器打开指定URL地址</span><br><span class="line">// NSAttachmentAttributeName          设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排</span><br><span class="line">// NSParagraphStyleAttributeName      设置文本段落排版格式，取值为 NSParagraphStyle 对象</span><br></pre></td></tr></table></figure><p>NSParagraphStyle的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];  </span><br><span class="line">paragraphStyle.lineSpacing = 10;// 字体的行间距  </span><br><span class="line">paragraphStyle.firstLineHeadIndent = 20.0f;//首行缩进  </span><br><span class="line">paragraphStyle.alignment = NSTextAlignmentJustified;//（两端对齐的）文本对齐方式：（左，中，右，两端对齐，自然）  </span><br><span class="line">paragraphStyle.lineBreakMode = NSLineBreakByTruncatingTail;//结尾部分的内容以……方式省略 ( &quot;...wxyz&quot; ,&quot;abcd...&quot; ,&quot;ab...yz&quot;)  </span><br><span class="line">paragraphStyle.headIndent = 20;//整体缩进(首行除外)  </span><br><span class="line">paragraphStyle.tailIndent = 20;//  </span><br><span class="line">paragraphStyle.minimumLineHeight = 10;//最低行高  </span><br><span class="line">paragraphStyle.maximumLineHeight = 20;//最大行高  </span><br><span class="line">paragraphStyle.paragraphSpacing = 15;//段与段之间的间距  </span><br><span class="line">paragraphStyle.paragraphSpacingBefore = 22.0f;//段首行空白空间/* Distance between the bottom of the previous paragraph (or the end of its paragraphSpacing, if any) and the top of this paragraph. */  </span><br><span class="line">paragraphStyle.baseWritingDirection = NSWritingDirectionLeftToRight;//从左到右的书写方向（一共➡️三种）  </span><br><span class="line">paragraphStyle.lineHeightMultiple = 15;/* Natural line height is multiplied by this factor (if positive) before being constrained by minimum and maximum line height. */  </span><br><span class="line">paragraphStyle.hyphenationFactor = 1;//连字属性 在iOS，唯一支持的值分别为0和1</span><br></pre></td></tr></table></figure><h2 id="TextView-UIImageview"><a href="#TextView-UIImageview" class="headerlink" title="TextView + UIImageview"></a>TextView + UIImageview</h2><blockquote><p> 以上的效果同样可以使用UITextView + UIImageView来实现，该方法主要利用了textview的textContainer.exclusionPaths属性</p></blockquote><p>// Default value : empty array  An array of UIBezierPath representing the exclusion paths inside the receiver’s bounding rect.<br>@property (copy, NS_NONATOMIC_IOSONLY) NSArray<uibezierpath *=""> *exclusionPaths NS_AVAILABLE(10_11, 7_0);</uibezierpath></p><p>按照文档的说明我们可以提供一个元素为UIBezierPath的数组，这样文字的描绘就会避开这些路径。从而实现图文混排的效果。不过这种方式最适合用于文字环绕的效果，所有的文字把图片包围住。</p><p>here is the code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 调用</span><br><span class="line"> UITextView *textView = [[UITextView alloc]init];</span><br><span class="line">    textView.frame = CGRectMake(20, 200, 335, 150);</span><br><span class="line">    textView.attributedText = [self textViewAttributestring];</span><br><span class="line">    [textView sizeToFit];</span><br><span class="line">    [self.view addSubview:textView];</span><br><span class="line">    self.textView = textView;</span><br><span class="line">    </span><br><span class="line">    UIImageView *imageView = [[UIImageView alloc]init];</span><br><span class="line">    imageView.frame = CGRectMake(45, 210, 20, 20);</span><br><span class="line">    imageView.image = [UIImage imageNamed:@&quot;trumpet&quot;];</span><br><span class="line">    [self.view addSubview:imageView];</span><br><span class="line">    self.imageView = imageView;</span><br><span class="line">    textView.textContainer.exclusionPaths = @[[self translatedBezierPath]];</span><br><span class="line">    </span><br><span class="line">//方法：</span><br><span class="line">- (UIBezierPath *)translatedBezierPath</span><br><span class="line">&#123;</span><br><span class="line">    //计算出imageView相对于textView的相对坐标</span><br><span class="line">    CGRect imageRect = [self.textView</span><br><span class="line">                        convertRect:self.imageView.frame fromView:self.view];</span><br><span class="line">    UIBezierPath *bezierPath = [UIBezierPath bezierPathWithRect:CGRectMake(imageRect.origin.x, imageRect.origin.y-10, imageRect.size.width, imageRect.size.height)];</span><br><span class="line">    return bezierPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSAttributedString*)textViewAttributestring&#123;</span><br><span class="line">    NSString *originStr = @&quot; Hi ALL,这是我的博客：lemon2well.top，欢迎来到我的博客，环欢迎评论留言一起交流。&quot;;</span><br><span class="line">    NSString *targetStr = @&quot;lemon2well.top&quot;;</span><br><span class="line">    </span><br><span class="line">    NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc]initWithString:originStr attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">    </span><br><span class="line">    NSRange linkRange = [originStr rangeOfString:targetStr];</span><br><span class="line">    if (linkRange.length != 0) &#123;</span><br><span class="line">        //添加可点击链接</span><br><span class="line">        [attributedStr addAttribute:NSLinkAttributeName value:[NSURL URLWithString:targetStr] range:linkRange];</span><br><span class="line">        [attributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:linkRange];</span><br><span class="line">        //添加下划线</span><br><span class="line">        [attributedStr addAttribute:NSUnderlineStyleAttributeName value:@1 range:linkRange];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 段落样式</span><br><span class="line">    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init];</span><br><span class="line">    // 行间距</span><br><span class="line">    [style setLineSpacing:3];</span><br><span class="line">    // 段落间距</span><br><span class="line">    [style setParagraphSpacing:10];</span><br><span class="line">    // 首行缩进</span><br><span class="line">    [style setFirstLineHeadIndent:25];</span><br><span class="line">    [attributedStr addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, originStr.length-1)];</span><br><span class="line">    </span><br><span class="line">    return attributedStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CoreText"><a href="#CoreText" class="headerlink" title="CoreText"></a>CoreText</h2><p>coreText给我的感觉就是太难用了，但是可创造性又很高，因为CoreText是属于比较底层的框架，所以基本上都是使用的C的方法，CoreText可以实现很复杂的图文混排而且渲染速度更快。</p><p>CoreText来实现图文混排实际上分为以下的几步:</p><blockquote><p>获得上下文，翻转坐标系 -&gt; 创建NSAttributeString -&gt; 创建空白占位图片，创建代理 -&gt; 实现代理 -&gt; 创建CTFrameRef,CTFrameDraw绘制 -&gt; 计算图片坐标，CGContextDrawImage绘制 -&gt; 释放资源</p></blockquote><p><img src="http://pcd17v2u0.bkt.clouddn.com/15343172514431.jpg" alt=""></p><blockquote></blockquote><p>CFAttributedStringRef ：属性字符串，用于存储需要绘制的文字字符和字符属性<br>CTFramesetterRef：通过CFAttributedStringRef进行初始化，作为CTFrame对象的生产工厂，负责根据path创建对应的CTFrame<br>CTFrame：用于绘制文字的类，可以通过CTFrameDraw函数，直接将文字绘制到context上<br>CTLine：在CTFrame内部是由多个CTLine来组成的，每个CTLine代表一行<br>CTRun：每个CTLine又是由多个CTRun组成的，每个CTRun代表一组显示风格一致的文本<br>实际上CoreText是不直接支持绘制图片的，但是我们可以先在需要显示图片的地方用一个特殊的空白占位符代替，同时设置该字体的CTRunDelegate信息为要显示的图片的宽度和高度，这样绘制文字的时候就会先把图片的位置留出来，再在drawRect方法里面用CGContextDrawImage绘制图片。</p><p>Here is the code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">-(void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);</span><br><span class="line">    CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot; Hi ALL,这是我的博客：lemon2well.top，欢迎来到我的博客，环欢迎评论留言一起交流。&quot; attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">    NSString *targetStr = @&quot;lemon2well.top&quot;;</span><br><span class="line">    </span><br><span class="line">    NSRange linkRange = [attributeStr.string rangeOfString:targetStr];</span><br><span class="line">    if (linkRange.length != 0) &#123;</span><br><span class="line">        //添加可点击链接</span><br><span class="line">        [attributeStr addAttribute:NSLinkAttributeName value:[NSURL URLWithString:targetStr] range:linkRange];</span><br><span class="line">        [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:linkRange];</span><br><span class="line">        //添加下划线</span><br><span class="line">        [attributeStr addAttribute:NSUnderlineStyleAttributeName value:@1 range:linkRange];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 段落样式</span><br><span class="line">    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init];</span><br><span class="line">    // 行间距</span><br><span class="line">    [style setLineSpacing:3];</span><br><span class="line">    // 段落间距</span><br><span class="line">    [style setParagraphSpacing:10];</span><br><span class="line">    // 首行缩进</span><br><span class="line">    [style setFirstLineHeadIndent:25];</span><br><span class="line">    [attributeStr addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, attributeStr.length-1)];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    CTRunDelegateCallbacks callBacks;</span><br><span class="line">    memset(&amp;callBacks,0,sizeof(CTRunDelegateCallbacks));</span><br><span class="line">    callBacks.version = kCTRunDelegateVersion1;</span><br><span class="line">    callBacks.getAscent = ascentCallBacks;</span><br><span class="line">    callBacks.getDescent = descentCallBacks;</span><br><span class="line">    callBacks.getWidth = widthCallBacks;</span><br><span class="line">    NSDictionary * dicPic = @&#123;@&quot;height&quot;:@16,@&quot;width&quot;:@16&#125;;</span><br><span class="line">    CTRunDelegateRef delegate = CTRunDelegateCreate(&amp; callBacks, (__bridge void *)dicPic);</span><br><span class="line">    unichar placeHolder = 0xFFFC;</span><br><span class="line">    NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];</span><br><span class="line">    NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];</span><br><span class="line">    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);</span><br><span class="line">    CFRelease(delegate);</span><br><span class="line">    [attributeStr insertAttributedString:placeHolderAttrStr atIndex:0];</span><br><span class="line">    CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);</span><br><span class="line">    CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">    CGPathAddRect(path, NULL, self.bounds);</span><br><span class="line">    NSInteger length = attributeStr.length;</span><br><span class="line">    CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, length), path, NULL);</span><br><span class="line">    CTFrameDraw(frame, context);</span><br><span class="line">    </span><br><span class="line">    UIImage * image = [UIImage imageNamed:@&quot;trumpet&quot;];</span><br><span class="line">    CGRect imgFrm = [self calculateImageRectWithFrame:frame];</span><br><span class="line">    CGContextDrawImage(context,imgFrm, image.CGImage);</span><br><span class="line">    CFRelease(frame);</span><br><span class="line">    CFRelease(path);</span><br><span class="line">    CFRelease(frameSetter);</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat ascentCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;height&quot;] floatValue];</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat descentCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat widthCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;width&quot;] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(CGRect)calculateImageRectWithFrame:(CTFrameRef)frame</span><br><span class="line">&#123;</span><br><span class="line">    NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);</span><br><span class="line">    NSInteger count = [arrLines count];</span><br><span class="line">    CGPoint points[count];</span><br><span class="line">    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);</span><br><span class="line">    for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">        CTLineRef line = (__bridge CTLineRef)arrLines[i];</span><br><span class="line">        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);</span><br><span class="line">        for (int j = 0; j &lt; arrGlyphRun.count; j ++) &#123;</span><br><span class="line">            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];</span><br><span class="line">            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];</span><br><span class="line">            if (delegate == nil) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            NSDictionary * dic = CTRunDelegateGetRefCon(delegate);</span><br><span class="line">            if (![dic isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            CGPoint point = points[i];</span><br><span class="line">            CGFloat ascent;</span><br><span class="line">            CGFloat descent;</span><br><span class="line">            CGRect boundsRun;</span><br><span class="line">            boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</span><br><span class="line">            boundsRun.size.height = ascent + descent;</span><br><span class="line">            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</span><br><span class="line">            boundsRun.origin.x = point.x + xOffset;</span><br><span class="line">            boundsRun.origin.y = point.y - descent;</span><br><span class="line">            CGPathRef path = CTFrameGetPath(frame);</span><br><span class="line">            CGRect colRect = CGPathGetBoundingBox(path);</span><br><span class="line">            CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);</span><br><span class="line">            return imageBounds;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return CGRectZero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="YYText"><a href="#YYText" class="headerlink" title="YYText"></a>YYText</h2><p><a href="https://github.com/ibireme/YYText" target="_blank" rel="noopener">YYText</a><br>YYText是大神郭曜源开发的一个强大的展示和编辑富文本的第三方工具，里面提供了丰富的与富文本开发相关的方法，具体的可以到github里面看。YYText是基于CoreText向上封装了一层，所以对开发者更加友好，如果在项目中运用到大量的富文本的地方建议可以用YYText。</p><p>here is the code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">YYLabel *label = [[YYLabel alloc]init];</span><br><span class="line">  label.numberOfLines = 0 ;</span><br><span class="line">  label.frame = CGRectMake(0, 200, 375, 200);</span><br><span class="line">  [self.view addSubview:label];</span><br><span class="line">  </span><br><span class="line">  NSString *headStr = @&quot;Hi ALL,这是我的博客：&quot;;</span><br><span class="line">  NSString *linkStr = @&quot;lemon2well.top&quot;;</span><br><span class="line">  NSString *lastStr = @&quot;，欢迎来到我的博客，环欢迎评论留言一起交流。&quot;;</span><br><span class="line">  UIImage *image = [UIImage imageNamed:@&quot;trumpet&quot;];</span><br><span class="line">  </span><br><span class="line">  NSMutableAttributedString *attrText = [NSMutableAttributedString new];</span><br><span class="line">  </span><br><span class="line">  NSAttributedString *headAttr = [[NSAttributedString alloc] initWithString:headStr attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">  </span><br><span class="line">  NSAttributedString *lastAttr = [[NSAttributedString alloc] initWithString:lastStr attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">  </span><br><span class="line">  NSMutableAttributedString *linkAttr = [[NSMutableAttributedString alloc] initWithString:linkStr];</span><br><span class="line">  linkAttr.yy_font = [UIFont systemFontOfSize:20];</span><br><span class="line">  linkAttr.yy_underlineStyle = NSUnderlineStyleSingle;</span><br><span class="line">  [linkAttr yy_setTextHighlightRange:NSMakeRange(0, linkStr.length) color:[UIColor blueColor] backgroundColor:nil tapAction:^(UIView * _Nonnull containerView, NSAttributedString * _Nonnull text, NSRange range, CGRect rect) &#123;</span><br><span class="line">      NSLog(@&quot;link = %@&quot;,text);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  NSMutableAttributedString *imageAttr = [NSMutableAttributedString yy_attachmentStringWithContent:image contentMode:UIViewContentModeCenter attachmentSize:CGSizeMake(32, 32) alignToFont:[UIFont systemFontOfSize:20] alignment:YYTextVerticalAlignmentCenter];</span><br><span class="line">  </span><br><span class="line">  [attrText appendAttributedString:imageAttr];</span><br><span class="line">  [attrText appendAttributedString:headAttr];</span><br><span class="line">  [attrText appendAttributedString:linkAttr];</span><br><span class="line">  [attrText appendAttributedString:lastAttr];</span><br><span class="line"></span><br><span class="line">  label.attributedText = attrText;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>总的来说，以上说的四种都各有优劣，但是他们都用了NSAttributedString来实现富文本。</p><p>如果在项目中用到富文本的地方不多，出于APP体积考虑没必要引入一个第三方，  可以考虑使用第一和第二种方案，如果是图文环绕这种，可以使用UITextView+UIImageview的方案，如果是小的表情图文混排可以使用NSAttributedString+label即可。</p><p>如果在项目中多处用到富文本的展示和编辑，建议使用YYText，因为它对于开发者更加友好，并且也是基于CoreText来渲染，不过有一点就是目前YYText已经有一年没维护了，之前他生病了，现在正在家里修养，希望他快点好起来，祝好。</p><h2 id="突然有感"><a href="#突然有感" class="headerlink" title="突然有感"></a>突然有感</h2><p>本来这篇文章到这里就应该完了，不过刚刚去看了一下YYKit的作者的<a href="https://blog.ibireme.com/author/ibireme/" target="_blank" rel="noopener">博客</a>，突然有点伤感，没想到他生病这么严重，看他的文字感觉他是一个对待生活也很细腻的人，这也说得通为什么他可以用业余的时间写出了YYKIT这么强大的工具，因为他对待技术也是很细腻。</p><p>真的很佩服这样的人，你可以感受到他的真诚，我虽然没和他聊过天，没见过他真人，不过他一定会是一个让别人感受到交流沟通起来让你没有防御的一个人。现在这个社会因为各种各样变态的人以及事，总会让人无论何时何地总会身上架着一层防御装，更可怕的是还有那种表面善内里恶的人，多可怕，如果是危害别人的人我一点都不心疼。</p><p>最后希望大家一定要注意自己的身体，祝大家都好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图文混排有多种方式可以实现，下面我会用四种不同的方式来实现以下界面的效果，并且说明他们的优缺点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcd17v2u0.bkt.clouddn.com/screenshot.png&quot; alt=&quot;screenshot&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;NSAttributedString&quot;&gt;&lt;a href=&quot;#NSAttributedString&quot; class=&quot;headerlink&quot; title=&quot;NSAttributedString&quot;&gt;&lt;/a&gt;NSAttributedString&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;NSAttributedString提供了自由并且多样式的富文本设置，图文混排的实现是通过插入NSTestAttachment来实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>开发细节之 hash 与 isEqual 方法</title>
    <link href="http://lemon2well.top/2018/08/14/iOS%20%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%BB%86%E8%8A%82%E4%B9%8B-hash-%E4%B8%8E-isEqual-%E6%96%B9%E6%B3%95/"/>
    <id>http://lemon2well.top/2018/08/14/iOS 开发/开发细节之-hash-与-isEqual-方法/</id>
    <published>2018-08-14T03:11:53.000Z</published>
    <updated>2018-08-14T03:12:23.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="isEuqal-与-的区别"><a href="#isEuqal-与-的区别" class="headerlink" title="isEuqal 与 == 的区别"></a>isEuqal 与 == 的区别</h2><p>相信大家都知道在OC中有两种比较是否相等的方法，第一种是直接用<code>==</code>符号比较，第二种是使用isEqual来比较，它们的区别如下：</p><ol><li><code>==</code> 如果是用于基本数据类型的比较，那么直接比较数值，isEqual只能用于OC对象比较</li><li><code>==</code> 如果是用于OC对象比较，那么是判断他们是不是同一个对象，也就是指针所指向的地址是否一致。而isEqual则是比较两个对象是否相同。</li></ol><a id="more"></a><p>接下来用一个颜色的示例来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIColor *color1 = [UIColor colorWithRed:120/255.0 green:120/255.0 blue:120/255.0 alpha:1];</span><br><span class="line">UIColor *color2 = [UIColor colorWithRed:120/255.0 green:120/255.0 blue:120/255.0 alpha:1];</span><br><span class="line">NSLog(@&quot;color1.address = %p\ncolor2.address = %p&quot;,color1,color2);</span><br><span class="line">NSLog(@&quot;color1 == color2 ? %@ &quot;,color1 == color2 ? @&quot;是&quot; : @&quot;否&quot;);</span><br><span class="line">NSLog(@&quot;color1 isEqual color2 ? %@ &quot;,[color1 isEqual:color2] ? @&quot;是&quot; : @&quot;否&quot;);</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color1.address = 0x60400046af40</span><br><span class="line">color2.address = 0x60400046b280</span><br><span class="line">color1 == color2 ? 否</span><br><span class="line">color1 isEqual color2 ? 是</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以看出，color1和color2是两个不同的对象，所以使用<code>==</code>来比较的时候他们不相等。但是color1和color2颜色的值都是一样的，所以使用isEuqal来比较的时候他们是相等的。</p><h2 id="isEuqal-用于自定义对象的比较"><a href="#isEuqal-用于自定义对象的比较" class="headerlink" title="isEuqal 用于自定义对象的比较"></a>isEuqal 用于自定义对象的比较</h2><p>刚刚我们是使用系统的UIColor的对象来比较，如果是我们是自定义的对象，如果需要判断两个对象是否相等的时候，使用isEqual方法来比较是否还起作用呢？</p><p>看看以下代码，我们有一个<code>LMPerson</code>类，里面有两个属性，一个name，一个age，我们创建两个不同的对象，然后给他们赋予同样的name和age，看看使用isEuqal来比较是否相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LMPerson *person1 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line">  LMPerson *person2 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line">  NSLog(@&quot;person1.address = %p\nperson2.address = %p&quot;,person1,person2);</span><br><span class="line">  NSLog(@&quot;person1 == person2 ? %@ &quot;,person1==person2?@&quot;是&quot;:@&quot;否&quot;);</span><br><span class="line">  NSLog(@&quot;person1 isEqual person2 ? %@ &quot;,[person1 isEqual:person2]?@&quot;是&quot;:@&quot;否&quot;);</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.address = 0x60400022b500</span><br><span class="line">person2.address = 0x60400022b200</span><br><span class="line">person1 == person2 ? 否</span><br><span class="line">person1 isEqual person2 ? 否</span><br></pre></td></tr></table></figure><p>通过上面的结果可以看出，当isEqual是用于我们自定义对象的比较的时候，即使我们赋予两个对象属性相同的值，但是返回的却是NO。这是为什么呢？</p><p><strong>这是因为UIColor，NSArray,NSdictonary 系统已经帮我们实现了对应的isEqual或者isEqualTo的方法，所以我们如果要用于自定义对象比较，那么也需要实现对应的isEqual方法，接下来我们给LMPerson添加以下实现方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object&#123;</span><br><span class="line">    if (self == object) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (![object isKindOfClass:LMPerson.class]) &#123;</span><br><span class="line">        return  NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LMPerson *person2 = (LMPerson*)object;</span><br><span class="line">    BOOL isSameName = (!self.name &amp;&amp; !person2.name) || [self.name isEqualToString:person2.name];</span><br><span class="line">    BOOL isSameAge = self.age == person2.age ;</span><br><span class="line">    return isSameName &amp;&amp; isSameAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.address = 0x60000022bac0</span><br><span class="line">person2.address = 0x60000022c460</span><br><span class="line">person1 == person2 ? 否</span><br><span class="line">person1 isEqual person2 ? 是</span><br></pre></td></tr></table></figure><p><strong>综上，如果我们要比较两个自定义对象是否相等的时候我们需要重写isEqual方法，给该方法提供一个实现。</strong></p><h2 id="什么是hash方法"><a href="#什么是hash方法" class="headerlink" title="什么是hash方法"></a>什么是hash方法</h2><p>这个要从hashTable说起，因为hashTabe是无序的集合，并且查找的时间复杂度是O(1)，数组是O(array_lenth)，为什么hashTable可以做到O(1)呢，因为当一个元素加到hashTable里面的时候，会有一个默认的hash值，用于标记元素在table中的位置，后面如果需要查找该元素，通过hash值可以直接找到该元素。</p><p>那么问题来了，这个hash值是怎样得来的呢？</p><p>这个hash值其实就是通过<code>- (NSUInteger)hash</code>方法提供的，并且系统默认的实现就是返回该对象的地址。下面我们来验证这个说法：</p><p>我们增加以下方法，并且打印出hash的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//LMPerson.m</span><br><span class="line">- (NSUInteger)getSuperHash&#123;</span><br><span class="line">    NSUInteger superHash = [super hash];</span><br><span class="line">    return superHash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ViewController</span><br><span class="line">  LMPerson *person1 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line">    LMPerson *person2 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line">    NSLog(@&quot;person1.address = %ld\nperson2.address = %ld&quot;,(NSUInteger)person1,(NSUInteger)person2);</span><br><span class="line">    NSLog(@&quot;person1.hash = %ld\nperson2.hash = %ld&quot;,[person1 getSuperHash],[person2 getSuperHash]);</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.address = 105553118496736</span><br><span class="line">person2.address = 105553116524864</span><br><span class="line">person1.hash = 105553118496736</span><br><span class="line">person2.hash = 105553116524864</span><br></pre></td></tr></table></figure><p>通过结果我们可以知道，其实系统默认的hash方法就是返回对象地址的十进制。</p><h2 id="什么时候会调用hash-方法"><a href="#什么时候会调用hash-方法" class="headerlink" title="什么时候会调用hash 方法"></a>什么时候会调用hash 方法</h2><p>这里我们直接说结论，如果一个集合中不能出现重复的元素那么就会调用hash方法来判断两个元素是否相等。什么意思呢？</p><p>NSMutableArray和NSArray是允许添加重复元素的，所以将一个元素放到该容器中的时候是不会调用hash方法，像NSSet，NSMutableSet元素不能重复，在添加和删除的时候会调用hash方法。当一个元素作为NSDictonary的key的时候，因为key也不能重复，所以也会调用hash方法。大家可以通过将上述创建的两个person对象分别放到不同的集合中进行验证。</p><p>值得注意的是，就算hash方法相等也不能判断两个元素就一定是相等，还会调用isEqual来进行判断。也就是说，会优先判断hash是否相等，如果hash不相等那么这两个元素一定不相等，如果hash相等，那么就调用isEqual判断两个元素是否相等，如果返回NO，那么两个元素也不相等， 如果返回YES那么两个元素相等。</p><p>也就是说当我们把自定义对象加到NSSet中的或者作为NSDictonary的key的时候 会同时调用hash方法和isEqual方法来判断两个元素是否相等，因此我们需要重写isEqual方法和hash方法。</p><h2 id="hash-的正确使用姿势"><a href="#hash-的正确使用姿势" class="headerlink" title="hash 的正确使用姿势"></a>hash 的正确使用姿势</h2><p>我们在上面已经验证过如果我们使用系统默认的hash方法来比较两个自定义对象是否相等是不正确的了，那么正确的使用姿势是什么呢？</p><p>在<a href="https://nshipster.com/equality/" target="_blank" rel="noopener">Equality</a>这篇文章中，matt大神给了方法，也就是对属性的hash进行异或运算。在<code>LMPerson.m</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash&#123;</span><br><span class="line">    return ([self.name hash] ^ [[NSNumber numberWithInteger:self.age] hash]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们编写以下代码来测试一下相同的元素是否还能加到hashTable里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LMPerson *person1 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line"> LMPerson *person2 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line"> LMPerson *person3 = [LMPerson personWithName:@&quot;lemon&quot; age:19];</span><br><span class="line"> NSSet *set = [NSSet setWithObjects:person1,person2, person3,nil];</span><br><span class="line"> NSLog(@&quot;set.count = %ld&quot;,[set count]);</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-08-14 11:08:13.250550+0800 testImageSourceCode[47478:7219161] set.count = 2</span><br></pre></td></tr></table></figure><p>可以看到我们往hashTable里面添加了三个元素，但是第一和第二个元素是相同的，所以最后加到集合里面的只有两个元素，证明hash方法起作用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;isEuqal-与-的区别&quot;&gt;&lt;a href=&quot;#isEuqal-与-的区别&quot; class=&quot;headerlink&quot; title=&quot;isEuqal 与 == 的区别&quot;&gt;&lt;/a&gt;isEuqal 与 == 的区别&lt;/h2&gt;&lt;p&gt;相信大家都知道在OC中有两种比较是否相等的方法，第一种是直接用&lt;code&gt;==&lt;/code&gt;符号比较，第二种是使用isEqual来比较，它们的区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 如果是用于基本数据类型的比较，那么直接比较数值，isEqual只能用于OC对象比较&lt;/li&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 如果是用于OC对象比较，那么是判断他们是不是同一个对象，也就是指针所指向的地址是否一致。而isEqual则是比较两个对象是否相同。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="isEuqal" scheme="http://lemon2well.top/tags/isEuqal/"/>
    
      <category term="hash" scheme="http://lemon2well.top/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>细说HTTP与HTTPS</title>
    <link href="http://lemon2well.top/2018/08/10/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/%E7%BB%86%E8%AF%B4HTTP%E4%B8%8EHTTPS/"/>
    <id>http://lemon2well.top/2018/08/10/其他技术/细说HTTP与HTTPS/</id>
    <published>2018-08-10T09:57:36.000Z</published>
    <updated>2018-08-10T09:59:57.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网上已经有很多关于HTTP与HTTPS的文章，为什么我还要写这篇文章呢，源于昨天有个iOS开发同学昨天在群里面提了一个问题，如果一个人下载了一个APP，该APP与服务器是HTTPS连接，他不会信任任何来源于不明身份的证书，然后连上了我的WIFI，我有没有办法去破解里面的通信内容?</p><p>接下来我们就带着这个疑问去寻找答案，并且给出我的答案。</p><h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h2><blockquote><p>HTTP(HyperText Transfer Protocol)超文本传输协议，HTTP是七层网络模型中作用在应用层的协议。</p></blockquote><a id="more"></a><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><ol><li>窃听风险（eavesdropping）：第三方可以获知通信内容。</li><li>篡改风险（tampering）：第三方可以修改通信内容。</li><li>冒充风险（pretending）：第三方可以冒充他人身份参与通信。</li></ol><p>因为HTTP是明文传输内容的，所以只要攻击者通过劫持你的WIFI或者你连上了不安全的WIFI那么你所有的传输内容他都可以拿到，接下来就可以篡改里面的数据。基于以上的缺点就有了HTTPS，待会我们再来说这个事儿。</p><h3 id="HTTP的工作流程："><a href="#HTTP的工作流程：" class="headerlink" title="HTTP的工作流程："></a>HTTP的工作流程：</h3><p>相信大家都听说过TCP三次握手，HTTP就是通过TCP三次握手建立连接，值得一提的是HTTP/1.0版本是默认没有复用TCP连接的，每次发送数据都要建立一个连接(需要使用keep-alive来建立长连接)，这样导致了耗时以及占用资源非常严重，后来发布了HTTP/1.1，同一个TCP通道可以复用发送多个请求，但是在该通道里面所有的请求都是按照顺序来发送的发送的，容易导致阻塞。HTTP/2在1.1的基础上改进了，不止复用同一个TCP通道并且可以并发的处理多个请求。</p><p>TCP三次握手，依照惯例，先发一个图片，看图说话</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15338881870637.png" alt=""></p><p>下面来解释一下上面三次握手的作用：</p><p>第一次握手：客户端发送将SYN标志位设置为1，并且随机产生一个序列号值seq=J，发送给数据包给服务端后，自身状态变为SYN_SENT</p><p>第二次握手：服务端接收到数据包之后，将发送标志位SYN设置为1，ACK应答需要为J+1表，并且再发送一个随机序列号值seq=K然后发送到客户端</p><p>第三次握手：客户端检查ACK是否为J+1，如果是的话发送一个ACK包，ACK=k+!，服务端收到之后确定ack是否等于K+1，是的话连接建立</p><p>我们先来解释一下为什么需要三次握手：<br>第一次握手确认客户端是具有发送消息能力的，发送消息之后客户端出于SYN_SENT状态，第二次握手服务器确定了自己有接收消息的能力，但是还不知道有没有发送消息的能力，此时服务器出于SYN_RECV的状态，也就是半连接的状态，第三次握手确定了服务器有发送消息的能力，因为客户端收到了他的消息并且回应了。此时客户端和服务端都处于establish状态，连接已经建立，可以开始收发消息。</p><p>基于HTTP的确定，后面衍生出来了HTTPS，那接下来我们来讲讲HTTPS以及他们的区别</p><h2 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h2><blockquote><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）顾名思义就是在HTTP的基础上加了SSL/TLS，以此来保证数据传输的安全性。</p></blockquote><h3 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h3><p>HTTPS 协议旨在解决以上三个风险，因此它可以：</p><ol><li>保证所有信息加密传输，无法被第三方窃取。</li><li>为信息添加校验机制，如果被第三方恶意破坏，可以检测出来。</li><li>配备身份证书，防止第三方伪装参与通信。</li></ol><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><blockquote><p>SSL(Secure Sockets Layer)/TLS(transport Layer Security)安全套接层是保证HTTPS安全的协议，这个协议主要的思想是通过公钥加解密来实现数据传输安全。</p></blockquote><p>那么我们就面临着两个问题.<br>1.如何保证公钥不被篡改 </p><blockquote><p>我们通过权威机构申请证书，将自己的公钥包装到证书里面，只要证书是可信的，那么公钥就是可信的。</p></blockquote><p>2.每次都生成公钥，消耗的时间太长，如何减少消耗。</p><blockquote><p>使用对称加密来替换非对称加密，每一次对话，客户端和和服务端都生成一个对话秘钥，而这个对称秘钥使用服务端的公私钥来进行加解密，这样就减少了加密运算的消耗时间。</p></blockquote><p>SSL/TLS 握手的流程：</p><ol><li><p>首先客户端发起请求，这个时候客户端会向服务端提供一些信息，包括支持的加密的算法，支持协议的版本TLS,一个随机数（用于待会生成对称秘钥），支持的压缩算法</p></li><li><p>服务端收到请求之后，向客户端发出相应，该响应也包括一些信息，确认使用的加密算法，一个服务端生成的随机数（用于待会生成秘钥）,支持的协议的版本TLS，还有一个最重要的数字证书，该数字证书包含了服务器的域名，还有服务端的公钥，以及经过加密后的摘要，该摘要是通过一定的算法对域名以及公钥进行计算得来。然后使用CA的私钥对摘要进行加密，</p></li><li><p>客户端收到数据之后首先会验证该数字证书是不是权威机构申请的证书，或者证书中的域名与实际域名是否一致，证书是否已经过期，如果都不符合的话那么就会提示是否信任该未知来源证书警告。<br>这里会验证证书是否被篡改，因为本地系统会内置权威机构的公钥，所以可以使  用公钥对解密出证书里面的摘要，然后通过特定的算法对域名以及公钥进行计算得到一个本地摘要，再和服务端传过来的摘要进行对比是否一致，以此来判断证书是否被篡改。<br>如果校验了证书是没有问题，客户端会生成一个随机数，并且使用服务器的公钥进行加密，并且发送编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p></li><li><p>服务端获取客户端的数据，然后使用自己的私钥机密客户端发过来的随机数。至此，一共有三个随机数。</p></li><li><p>客户端和服务端通过之前协议好的加密算法，使用前面生成的三个随机数生成一个真正的对称秘钥，该对称秘钥用于加密传输数据。</p></li></ol><p>简单点来说以上步骤就是：</p><ol><li>客户端发送请求</li><li>服务端返回证书，该证书包含服务端的公钥</li><li>客户端验证证书，并且生成对称秘钥，并且使用服务端的公钥加密该对称秘钥</li><li>服务端用私钥解密客户端的对称秘钥</li><li>发送内容通过对称秘钥来加密</li></ol><p>总结一下 HTTPS 协议是如何避免前文所说的三大风险的：<br>先用非对称加密传输密码，然后用这个密码对称加密数据，使得第三方无法获得通信内容<br>发送方将数据的哈希结果写到数据中，接收方解密后对比数据的哈希结果，如果不一致则说明被修改。由于传输数据加密，第三方无法修改哈希结果。<br>由权威机构颁发证书，再加上证书校验机制，避免第三方伪装参与通信。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>在我们抛砖引玉说了这么多HTTP与HTTPS的区别之后，我们得到了答案。</p><blockquote><p>如果一个人下载了一个APP，该APP与服务器是HTTPS连接，他不会信任任何来源于不明身份的证书，然后连上了我的WIFI，我有没有办法去破解里面的通信内容</p></blockquote><p><strong>答案就是不行</strong></p><p>我们想到的可以破解里面的通信内容也许就是希望能做一个中间人拦截，在服务端向客户端发送证书的时候拦截该证书，并且伪造一个和服务端域名相同并且替换将里面的公钥替换成自己的公钥，并且用自己的私钥进行签名。客户端收到伪造的证书之后，如果客户端的系统中有我们的公钥，那么就可以验证通过该中间人的证书，然后获取得到公钥，然后用该公钥对对称秘钥加密发送给服务端，此时中间件又可以拦截，并且使用自己的私钥解密出对称秘钥，然后中间人通过服务端的公钥对该秘钥进行加密，然后发送给服务端，这样中间人就拿到了对称秘钥信息，所以也可以窃取到里面的通信内容。</p><p>但是……….</p><p>前面的题目说了一个前提，不会信任任何来源于不明身份的证书，也就是说在中间人拦截了服务端的证书并且将伪造的证书发送给客户端之后，客户端并不会通过验证该证书，然后连接就到此中断了。。。。</p><h2 id="附加：HTTPS与HTTPS的区别"><a href="#附加：HTTPS与HTTPS的区别" class="headerlink" title="附加：HTTPS与HTTPS的区别"></a>附加：HTTPS与HTTPS的区别</h2><ol><li>HTTP是明文传输，HTTPS是加密传输</li><li>HTTP只有TCP三次握手，HTTPS是TCP三次握手+SSL/TLS</li><li>HTTP是使用80端口，HTTPS是使用443端口</li><li>HTTPS比HTTPS更加耗时</li><li>HTTPS需要到CA购买证书，需要一定的费用</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1  <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></p><ol start="2"><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></li><li><a href="http://skx926.com/2017/12/05/https/" target="_blank" rel="noopener">深入理解HTTPS</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;网上已经有很多关于HTTP与HTTPS的文章，为什么我还要写这篇文章呢，源于昨天有个iOS开发同学昨天在群里面提了一个问题，如果一个人下载了一个APP，该APP与服务器是HTTPS连接，他不会信任任何来源于不明身份的证书，然后连上了我的WIFI，我有没有办法去破解里面的通信内容?&lt;/p&gt;
&lt;p&gt;接下来我们就带着这个疑问去寻找答案，并且给出我的答案。&lt;/p&gt;
&lt;h2 id=&quot;什么是HTTP&quot;&gt;&lt;a href=&quot;#什么是HTTP&quot; class=&quot;headerlink&quot; title=&quot;什么是HTTP&quot;&gt;&lt;/a&gt;什么是HTTP&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;HTTP(HyperText Transfer Protocol)超文本传输协议，HTTP是七层网络模型中作用在应用层的协议。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其他技术" scheme="http://lemon2well.top/categories/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="http" scheme="http://lemon2well.top/tags/http/"/>
    
      <category term="https" scheme="http://lemon2well.top/tags/https/"/>
    
      <category term="SSL/TLS" scheme="http://lemon2well.top/tags/SSL-TLS/"/>
    
  </entry>
  
  <entry>
    <title>回文数</title>
    <link href="http://lemon2well.top/2018/08/10/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://lemon2well.top/2018/08/10/常见算法/回文数/</id>
    <published>2018-08-10T02:34:40.000Z</published>
    <updated>2018-08-10T02:35:39.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。"><a href="#判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。" class="headerlink" title="判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。"></a>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</h1><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><a id="more"></a><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><blockquote><p>思路：<br>根据定义如果我们要找出一个数是否是回文数我们其实只需要将这个数分成平均分成两个部分，然后将后半部分翻转，只要翻转后的后半部分等于前半部分，就代表这个数是回文数。<br>我们拿1221来举例，假设我们拿到后半段是21然后将21翻转就是12了，和前半段比较相等就代表是回文数。<br>那么我们第一个问题，如何将21翻转，首先我们将1221%10 得到的就是第一个数1，然后用这第一个数 1<em> 10 得到翻转后的正确位置。第二个数我们依然是122%10，然后得到第二个数，用第一个数加上第二个数就得到了12.<br>第二个问题就是我们如何将这个数分成两部分。当原始数/10小于翻转数</em>10的时候就代表已经完成了一半的翻转。</p></blockquote><p><strong>不过依然有两点需要注意，第一点是如果这个原始的数是负数的话我们需要返回，如果这个数是以0结尾的数，那么只有0才满足回文数，其他数都不满足回文数，我们直接返回false。</strong><br><strong>第二点是如果这个数的位数是基数，例如12321，那么循环完成之后原始数编程12，翻转数是123，这个时候我们用123/10得到12再和原始数12比较，忽略中间那一位数</strong></p><p>以下是代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func solution(_ num:Int)-&gt;Bool&#123;</span><br><span class="line">      if num&lt;0 || (num % 10 == 0 &amp;&amp; num != 0)&#123;</span><br><span class="line">          return false</span><br><span class="line">      &#125;</span><br><span class="line">      var originNum = num</span><br><span class="line">      var reverserNum = 0</span><br><span class="line">      while originNum &gt; reverserNum &#123;</span><br><span class="line">          reverserNum = reverserNum * 10 + originNum % 10</span><br><span class="line">          originNum = originNum / 10</span><br><span class="line">      &#125;</span><br><span class="line">      return originNum == reverserNum || originNum == reverserNum / 10</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&quot;&gt;&lt;a href=&quot;#判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&quot; class=&quot;headerlink&quot; title=&quot;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&quot;&gt;&lt;/a&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/h1&gt;&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: -121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://lemon2well.top/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>持续集成之Jenkins构建项目并上传到蒲公英</title>
    <link href="http://lemon2well.top/2018/08/08/iOS%20%E5%BC%80%E5%8F%91/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
    <id>http://lemon2well.top/2018/08/08/iOS 开发/持续集成之Jenkins构建项目并上传到蒲公英/</id>
    <published>2018-08-08T15:18:25.000Z</published>
    <updated>2018-08-09T03:18:43.898Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在第一篇<a href="http://lemon2well.top/2018/08/07/iOS%20开发/持续集成之Jenkins搭建/">Jenkins的搭建</a>中我们已经把本地jenkins环境都搭建好了，接下来我们通过jenkins构建一个ipa并且上传到蒲公英。</p></blockquote><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p>1.首先选择左侧的新建任务，然后下面是构建该工程的基本信息</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336240434000.jpg" alt=""></p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336241947095.jpg" alt=""></p><a id="more"></a><h2 id="填写源码地址"><a href="#填写源码地址" class="headerlink" title="填写源码地址"></a>填写源码地址</h2><ol start="2"><li>下面填写github或者gitLab的源码的地址，并且需要配置对应的Credentials，这里相当是授权。等到构建的时候jenkins会从对应的git上面拉去代码开始构建。</li></ol><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336242653880.jpg" alt=""></p><p>填完源码的网址之后需要填写git的账号密码或者输入对应的私钥。点击Add然后会出现下面的界面</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336242294039.jpg" alt=""></p><blockquote><p>如果你的git已经配置了ssh那么可以选择SSH username and private key， 然后到你的/Users/用户名/.ssh/id_rsa 将这个私钥文件里面的所有内容复制到privatekey (enter directly)上面去。<br>否则可以按照上图那样，选择username with password，然后输入用户名和密码</p></blockquote><h2 id="设置触发器（非必要）"><a href="#设置触发器（非必要）" class="headerlink" title="设置触发器（非必要）"></a>设置触发器（非必要）</h2><ol start="3"><li>构建触发器是与测试相关的操作，这里可以根据需求选择构建的触发时刻，例如选择第二个就是当代码仓库有push事件的时候，就会触发构建操作，然后构建一个版本并且通知测试去操作。因为我们是手动构建，所以这里先不管这个。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336265635081.jpg" alt=""></li></ol><h2 id="设置签名和证书"><a href="#设置签名和证书" class="headerlink" title="设置签名和证书"></a>设置签名和证书</h2><ol start="4"><li>接下我们需要设置签名文件和证书。<br>首先保存我们原先的设置，然后回到首页，选择系统管理-&gt;Keychains and Provisioning Profiles Management 点击选取文件，然后选择login.keychain文件和 provisioning file 上传。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336269763882.jpg" alt=""></li></ol><p>填写本机密码，输入描述，然后选择Add Code Signing Identity 输入签名文件的名称，这里的名称可以到钥匙串找到对应的证书然后选择显示简介然后复制头部的文字。</p><blockquote><p>这个Keychain在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下</p></blockquote><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336275407363.jpg" alt=""></p><p>上面的配置完成之后，回到任务的配置里面，选择对应的keyChain和provisioning file</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336251729871.jpg" alt=""></p><h2 id="构建命令"><a href="#构建命令" class="headerlink" title="构建命令"></a>构建命令</h2><ol start="5"><li>上面已经将所有的设置都配置好了，接下来需要选择构建的方式，你可以选择通过xcode来构建，但是这里我们选择shell 并且也推荐通过shell来构建。选择执行shell，然后输入下面的代码，里面有些地方需要改成你自己的，根据实际情况改就可以了，不过一定要注意一点，jenkins那个编辑框极其不好用，我因为不小心输入了一个空格字符然后一直报 command not found ，搞到我一直以为是jenkins配置环境的问题。如果中间有构建错误，点击构建那个红点然后可以查看具体的控制台信息，根据错误提示来修改就好了</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 工程名，记得改成你自己</span><br><span class="line">APP_NAME=&quot;TestUMCOpen&quot;</span><br><span class="line"># 证书</span><br><span class="line">CODE_SIGN_DISTRIBUTION=&quot;iPhone Distribution: XXXXXXXXXX&quot;</span><br><span class="line"># info.plist路径</span><br><span class="line">project_infoplist_path=&quot;./$&#123;APP_NAME&#125;/Info.plist&quot;</span><br><span class="line"></span><br><span class="line">#取版本号</span><br><span class="line">bundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line"></span><br><span class="line">#取build值</span><br><span class="line">bundleVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line">DATE=&quot;$(date +%Y%m%d)&quot;</span><br><span class="line">IPAFOLDER=&quot;$&#123;APP_NAME&#125;_V$&#123;bundleShortVersion&#125;_$&#123;DATE&#125;&quot;</span><br><span class="line"></span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">ARCHIVE_PATH=&quot;$&#123;HOME&#125;/Desktop/archive&quot;</span><br><span class="line">IPA_PATH=&quot;$ARCHIVE_PATH/$&#123;IPAFOLDER&#125;/$&#123;APP_NAME&#125;.ipa&quot;</span><br><span class="line">PLIST_PATH=&quot;$ARCHIVE_PATH/ADHocExportOptions.plist&quot;</span><br><span class="line">echo $&#123;IPA_PATH&#125;</span><br><span class="line">echo $&#123;PLIST_PATH&#125;</span><br><span class="line"></span><br><span class="line">#下面两行是没有Cocopods的用法</span><br><span class="line"># 清除上次构建</span><br><span class="line">xcodebuild clean -project &quot;$&#123;APP_NAME&#125;.xcodeproj&quot; -scheme $&#123;APP_NAME&#125;   -configuration &apos;Release&apos;</span><br><span class="line"># 构建xcarchive文件</span><br><span class="line">xcodebuild archive -project &quot;$&#123;APP_NAME&#125;.xcodeproj&quot; -scheme $&#123;APP_NAME&#125; -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot;</span><br><span class="line"></span><br><span class="line">#下面两行是有cocopods的用法</span><br><span class="line"># xcodebuild clean -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme $&#123;APP_NAME&#125;   -configuration &apos;Release&apos;</span><br><span class="line"></span><br><span class="line"># xcodebuild archive -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme $&#123;APP_NAME&#125; -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot;</span><br><span class="line"></span><br><span class="line"># 导出ipa</span><br><span class="line">xcodebuild -exportArchive -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot; -exportPath &quot;$ARCHIVE_PATH/$IPAFOLDER&quot; -exportOptionsPlist &quot;$PLIST_PATH&quot;</span><br><span class="line"></span><br><span class="line">#打开文件夹</span><br><span class="line">open $&#123;ARCHIVE_PATH&#125;</span><br></pre></td></tr></table></figure><p><strong>这里有个地方需要注意一下，在xcode9之后，需要提供一个信息才能打包，我们可以通过xcode打包出来ipa文件然后复制那个ExportOption.plist文件就好了以下是我的文件的内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;compileBitcode&lt;/key&gt;</span><br><span class="line">&lt;false/&gt;</span><br><span class="line">&lt;key&gt;method&lt;/key&gt;</span><br><span class="line">&lt;string&gt;enterprise&lt;/string&gt;</span><br><span class="line">&lt;key&gt;provisioningProfiles&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;your Bundle id&lt;/key&gt;</span><br><span class="line">&lt;string&gt;证书的名字&lt;/string&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;key&gt;signingCertificate&lt;/key&gt;</span><br><span class="line">&lt;string&gt;iPhone Distribution&lt;/string&gt;</span><br><span class="line">&lt;key&gt;signingStyle&lt;/key&gt;</span><br><span class="line">&lt;string&gt;manual&lt;/string&gt;</span><br><span class="line">&lt;key&gt;stripSwiftSymbols&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;teamID&lt;/key&gt;</span><br><span class="line">&lt;string&gt;7LD5QKB26C&lt;/string&gt;</span><br><span class="line">&lt;key&gt;thinning&lt;/key&gt;</span><br><span class="line">&lt;string&gt;none&lt;/string&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>如果成功之后会在我们指定的文件里面生成下面的文件，除了那个ADHocExportOption.plist是我创建的，前天的文件都是jenkins构建的。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336256611678.jpg" alt=""></p></li><li><p>上传ipa到蒲公英</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#上传到蒲公英</span><br><span class="line">uKey=&quot;aec42b3cc32*******837cc7084a819c&quot;</span><br><span class="line">#蒲公英上的API Key</span><br><span class="line">apiKey=&quot;ba4e62***************8067a87315&quot;</span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">echo $IPA_PATH</span><br><span class="line"> </span><br><span class="line">#执行上传至蒲公英的命令</span><br><span class="line">echo &quot;++++++++++++++upload+++++++++++++&quot;</span><br><span class="line">curl -F &quot;file=@$&#123;IPA_PATH&#125;&quot; -F &quot;uKey=$&#123;uKey&#125;&quot; -F &quot;_api_key=$&#123;apiKey&#125;&quot; http://www.pgyer.com/apiv1/app/upload</span><br></pre></td></tr></table></figure><h2 id="命令行构建"><a href="#命令行构建" class="headerlink" title="命令行构建"></a>命令行构建</h2><ol start="7"><li>至此我们已经完成手动构建项目了，接下来我们利用Jenkins命令行来完成一行命令构建版本<br>进入系统管理然后选择Jenkins命令行，下载最新的jenkins-cli.jar<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336535463602.jpg" alt=""></li></ol><p>下载完成之后，如果直接运行上述命令行会提示没有权限，这个时候我们需要配置一下SSH。点击右上角的用户名，然后点击设置，找到SSH，然后将本地的公钥复制粘贴到上面，保存。</p><p>下面是完整的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">add-job-to-view</span><br><span class="line">    Adds jobs to view.</span><br><span class="line">  build</span><br><span class="line">    Builds a job, and optionally waits until its completion.</span><br><span class="line">  cancel-quiet-down</span><br><span class="line">    Cancel the effect of the &quot;quiet-down&quot; command.</span><br><span class="line">  clear-queue</span><br><span class="line">    Clears the build queue.</span><br><span class="line">  connect-node</span><br><span class="line">    Reconnect to a node(s)</span><br><span class="line">  console</span><br><span class="line">    Retrieves console output of a build.</span><br><span class="line">  copy-job</span><br><span class="line">    Copies a job.</span><br><span class="line">  create-credentials-by-xml</span><br><span class="line">    Create Credential by XML</span><br><span class="line">  create-credentials-domain-by-xml</span><br><span class="line">    Create Credentials Domain by XML</span><br><span class="line">  create-job</span><br><span class="line">    Creates a new job by reading stdin as a configuration XML file.</span><br><span class="line">  create-node</span><br><span class="line">    Creates a new node by reading stdin as a XML configuration.</span><br><span class="line">  create-view</span><br><span class="line">    Creates a new view by reading stdin as a XML configuration.</span><br><span class="line">  delete-builds</span><br><span class="line">    Deletes build record(s).</span><br><span class="line">  delete-credentials</span><br><span class="line">    Delete a Credential</span><br><span class="line">  delete-credentials-domain</span><br><span class="line">    Delete a Credentials Domain</span><br><span class="line">  delete-job</span><br><span class="line">    Deletes job(s).</span><br><span class="line">  delete-node</span><br><span class="line">    Deletes node(s)</span><br><span class="line">  delete-view</span><br><span class="line">    Deletes view(s).</span><br><span class="line">  disable-job</span><br><span class="line">    禁用任务</span><br><span class="line">  disconnect-node</span><br><span class="line">    Disconnects from a node.</span><br><span class="line">  enable-job</span><br><span class="line">    启用任务</span><br><span class="line">  get-credentials-as-xml</span><br><span class="line">    Get a Credentials as XML (secrets redacted)</span><br><span class="line">  get-credentials-domain-as-xml</span><br><span class="line">    Get a Credentials Domain as XML</span><br><span class="line">  get-job</span><br><span class="line">    Dumps the job definition XML to stdout.</span><br><span class="line">  get-node</span><br><span class="line">    Dumps the node definition XML to stdout.</span><br><span class="line">  get-view</span><br><span class="line">    Dumps the view definition XML to stdout.</span><br><span class="line">  groovy</span><br><span class="line">    Executes the specified Groovy script.</span><br><span class="line">  groovysh</span><br><span class="line">    Runs an interactive groovy shell.</span><br><span class="line">  help</span><br><span class="line">    Lists all the available commands or a detailed description of single command.</span><br><span class="line">  import-credentials-as-xml</span><br><span class="line">    Import credentials as XML. The output of &quot;list-credentials-as-xml&quot; can be used as input here as is, the only needed change is to set the actual Secrets which are redacted in the output.</span><br><span class="line">  install-plugin</span><br><span class="line">    Installs a plugin either from a file, an URL, or from update center.</span><br><span class="line">  install-tool</span><br><span class="line">    Performs automatic tool installation, and print its location to stdout. Can be only called from inside a build. [deprecated]</span><br><span class="line">  keep-build</span><br><span class="line">    永久保留这次构建。</span><br><span class="line">  list-changes</span><br><span class="line">    Dumps the changelog for the specified build(s).</span><br><span class="line">  list-credentials</span><br><span class="line">    Lists the Credentials in a specific Store</span><br><span class="line">  list-credentials-as-xml</span><br><span class="line">    Export credentials as XML. The output of this command can be used as input for &quot;import-credentials-as-xml&quot; as is, the only needed change is to set the actual Secrets which are redacted in the output.</span><br><span class="line">  list-credentials-context-resolvers</span><br><span class="line">    List Credentials Context Resolvers</span><br><span class="line">  list-credentials-providers</span><br><span class="line">    List Credentials Providers</span><br><span class="line">  list-jobs</span><br><span class="line">    Lists all jobs in a specific view or item group.</span><br><span class="line">  list-plugins</span><br><span class="line">    Outputs a list of installed plugins.</span><br><span class="line">  login</span><br><span class="line">    Saves the current credentials to allow future commands to run without explicit credential information. [deprecated]</span><br><span class="line">  logout</span><br><span class="line">    Deletes the credentials stored with the login command. [deprecated]</span><br><span class="line">  mail</span><br><span class="line">    Reads stdin and sends that out as an e-mail.</span><br><span class="line">  offline-node</span><br><span class="line">    Stop using a node for performing builds temporarily, until the next &quot;online-node&quot; command.</span><br><span class="line">  online-node</span><br><span class="line">    Resume using a node for performing builds, to cancel out the earlier &quot;offline-node&quot; command.</span><br><span class="line">  quiet-down</span><br><span class="line">    Quiet down Jenkins, in preparation for a restart. Don’t start any builds.</span><br><span class="line">  reload-configuration</span><br><span class="line">    Discard all the loaded data in memory and reload everything from file system. Useful when you modified config files directly on disk.</span><br><span class="line">  reload-job</span><br><span class="line">    Reload job(s)</span><br><span class="line">  remove-job-from-view</span><br><span class="line">    Removes jobs from view.</span><br><span class="line">  restart</span><br><span class="line">    重新启动Jenkins</span><br><span class="line">  safe-restart</span><br><span class="line">    安全地重新启动Jenkins</span><br><span class="line">  safe-shutdown</span><br><span class="line">    Puts Jenkins into the quiet mode, wait for existing builds to be completed, and then shut down Jenkins.</span><br><span class="line">  session-id</span><br><span class="line">    Outputs the session ID, which changes every time Jenkins restarts.</span><br><span class="line">  set-build-description</span><br><span class="line">    Sets the description of a build.</span><br><span class="line">  set-build-display-name</span><br><span class="line">    Sets the displayName of a build.</span><br><span class="line">  set-build-parameter</span><br><span class="line">    Update/set the build parameter of the current build in progress. [deprecated]</span><br><span class="line">  set-build-result</span><br><span class="line">    Sets the result of the current build. Works only if invoked from within a build. [deprecated]</span><br><span class="line">  set-external-build-result</span><br><span class="line">    Set external monitor job result.</span><br><span class="line">  shutdown</span><br><span class="line">    立刻关闭Jenkins</span><br><span class="line">  update-credentials-by-xml</span><br><span class="line">    Update Credentials by XML</span><br><span class="line">  update-credentials-domain-by-xml</span><br><span class="line">    Update Credentials Domain by XML</span><br><span class="line">  update-job</span><br><span class="line">    Updates the job definition XML from stdin. The opposite of the get-job command.</span><br><span class="line">  update-node</span><br><span class="line">    Updates the node definition XML from stdin. The opposite of the get-node command.</span><br><span class="line">  update-view</span><br><span class="line">    Updates the view definition XML from stdin. The opposite of the get-view command.</span><br><span class="line">  version</span><br><span class="line">    Outputs the current version.</span><br><span class="line">  wait-node-offline</span><br><span class="line">    Wait for a node to become offline.</span><br><span class="line">  wait-node-online</span><br><span class="line">    Wait for a node to become online.</span><br><span class="line">  who-am-i</span><br><span class="line">    Reports your credential and permissions.</span><br></pre></td></tr></table></figure><p>我们执行命令的格式是<br><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -ssh -user username command</code><br>command 就是我们需要执行的命令，build是构建命令，下面的事情就很简单了。</p><p><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -ssh -user username build UMC10.1.0Demo</code><br><strong>UMC10.1.0Demo是我们一开始创建任务的时候的名字，这个时候就会自动构建版本并且上传蒲公英</strong><br>可以将上述命令放到.command文件里面，并且增加可执行权限，这样双击这个文件的时候就会触发构建。注意里面cli.jar的路径。</p><p>上述命令指示构建一个指定版本的脚本，下面我们可以通过列举出所有的任务，然后选择其中一个任务来开始构建版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">ps -fe|grep &quot;jenkins&quot; |grep -v grep</span><br><span class="line">if [ $? -ne 0 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;******请先使用Jenkins -h来启动jenkins**********&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;********检测到Jenkins已经启动**********&quot;</span><br><span class="line">fi</span><br><span class="line">LOCALHOST=&quot;http://localhost:8080/&quot;</span><br><span class="line">CLIJAR=&quot;/Users/lemon/jenkins-cli.jar&quot;</span><br><span class="line"></span><br><span class="line">java -jar $&#123;CLIJAR&#125; -s $&#123;LOCALHOST&#125; -ssh -user admin list-jobs</span><br><span class="line"></span><br><span class="line">echo &quot;*******请输入你要构建的任务*******&quot;</span><br><span class="line">read BuildName</span><br><span class="line"></span><br><span class="line">java -jar $&#123;CLIJAR&#125; -s $&#123;LOCALHOST&#125; -ssh -user admin build $&#123;BuildName&#125;</span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">echo &quot;*******正在构建$&#123;BuildName&#125;，构建完成后会自动打开本地文件夹*******&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;*******构建$&#123;BuildName&#125;失败，请检查是否有对应的任务*******&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述：总的来说在我们jenkins已经安装好的情况下，我们需要做的就是构建任务，然后填写源码地址，设置构建策略，设置签名和证书，编写构建代码（包括上传蒲公英），编写shell。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在第一篇&lt;a href=&quot;http://lemon2well.top/2018/08/07/iOS%20开发/持续集成之Jenkins搭建/&quot;&gt;Jenkins的搭建&lt;/a&gt;中我们已经把本地jenkins环境都搭建好了，接下来我们通过jenkins构建一个ipa并且上传到蒲公英。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;创建任务&quot;&gt;&lt;a href=&quot;#创建任务&quot; class=&quot;headerlink&quot; title=&quot;创建任务&quot;&gt;&lt;/a&gt;创建任务&lt;/h2&gt;&lt;p&gt;1.首先选择左侧的新建任务，然后下面是构建该工程的基本信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcd17v2u0.bkt.clouddn.com/15336240434000.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcd17v2u0.bkt.clouddn.com/15336241947095.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="jenkins" scheme="http://lemon2well.top/tags/jenkins/"/>
    
      <category term="蒲公英" scheme="http://lemon2well.top/tags/%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
    
  </entry>
  
  <entry>
    <title>持续集成之Jenkins搭建</title>
    <link href="http://lemon2well.top/2018/08/07/iOS%20%E5%BC%80%E5%8F%91/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%90%AD%E5%BB%BA/"/>
    <id>http://lemon2well.top/2018/08/07/iOS 开发/持续集成之Jenkins搭建/</id>
    <published>2018-08-07T08:26:29.000Z</published>
    <updated>2018-08-08T08:27:10.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于一个APP来说，我相信我们开发最担心的就是出bug，只要是线上APP出bug，心里就慌得很，这是一件很严重的事情，还有可能让用户一气之下把你的APP删掉，从此再也不会出现在他的手机里面。</p><p>但是如果我们严格把控APP的质量，我们做到每天都构建一个版本并且测试，我们将这个APP上传到一个特定的测试系统，当有代码更新的时候或者每天设置一个时间去不断的跑测试，这样我们在开发阶段就发现很多问题。</p><blockquote><p>上面我们说的就是CI(Continuous Integration)持续集成+TDD(Test Driven Development)测试驱动开发。</p></blockquote><a id="more"></a><h2 id="持续集成带来的好处"><a href="#持续集成带来的好处" class="headerlink" title="持续集成带来的好处"></a>持续集成带来的好处</h2><p>持续集成带来的好处是显而易见的</p><ol><li><p>减少风险。通过每天构建版本，在开发阶段就可以发现项目的缺陷，排除一些因为项目设置的低级错误而导致的bug，用同样的脚本和过程构建和测试软件，排除因代码外的其他因素。</p></li><li><p>减少重复的过程，提高效率。当项目变大之后，频繁的打包会很影响开发的效率，但是有了持续集成我们不用关心打包的过程，将重复的build,archive,code sign交给提供构建服务的机器去做，将时间放在更有意义的事情上面。</p></li><li><p>随时可部署。持续集成有一个好处就是我们每天都会做构建版本，可以交付部署上线，当我们无休止的讨论需求软件质量或者开发进度的时候，对于客户来说，不如一个可安装的软件包来得实际</p></li></ol><h3 id="持续集成之Jenkins"><a href="#持续集成之Jenkins" class="headerlink" title="持续集成之Jenkins"></a>持续集成之Jenkins</h3><p>CI包括三个基本的元素，第一个是可自动构建版本的服务，第二个是代码仓库，第三个是搭建了服务的机器。</p><blockquote><p>可自动构建版本的服务目前有Jenkins和fastlane。<br>代码仓库也就是我们平时使用的github,gitlab等等<br>在iOS中机器必须是搭建OSX系统的机器，因为构建需要用到xcodeBuild命令，该命令由xcode提供，而xcode只能安装在OSX系统下面。</p></blockquote><p>下面我们要说的就是可自动构建版本的服务，<a href="https://jenkins.io" target="_blank" rel="noopener">Jenkins</a>。</p><p>Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性，构建完成之后通过脚本直接上传到分发平台或者测试平台。</p><h2 id="Jenkins搭建"><a href="#Jenkins搭建" class="headerlink" title="Jenkins搭建"></a>Jenkins搭建</h2><p>jenkins有两种安装方式</p><p>一种是通过在<a href="https://jenkins.io/download" target="_blank" rel="noopener">官网</a>下载pkg安装包的方式安装，图形化的安装界面直接跟着提示安装就好了。</p><p>第二种是通过homebrew安装，不过在安装之前我们需要检测本地环境是否已经安装了java，可以使用<code>java -version</code>来查看当前的java版本，如果没有安装的java的话可以在<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">这里</a>安装java。<br>还要检测是否已经安装了homebrew,查看本机homebrew版本’brew -v’。</p><p>如果java和homebrew都已经安装好，就可以开始安装jenkins了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure><p>当出现Jenkins is fully up and running之后，表明jenkins已经安装好了，如果没有自动打开<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> ，可以到网页上面自行打开该外地址。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337123514685.png" alt=""></p><p>上面给了一个地址，提示你去那里找到初始化的密码。打开/User/Shared/Jenkins/Home/secrets/initialAdminPassword复制出密码。</p><p>接下来会提示你安装一些插件，安装默认的插件即可，不过就算这里安装失败了也没关系，后面进到主界面还可以继续安装。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337131168237.png" alt=""></p><p>安装完插件之后会提示你创建一个jenkins用户。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15337133154570.jpg" alt=""></p><p>输入这些信息之后点击save And Finish安装的过程就算完成了。接下来可以进入到jenkins主界面了。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337135245241.jpg" alt=""><br>我们主要关注一下面板左侧的选项，点击“系统管理”，然后找到“管理插件”<br>在“可选插件”中选中“GitLab Plugin”和“Gitlab Hook Plugin”这两项，然后安装。<br>安装Xcode插件<br>同安装GitLab插件的步骤一样，我们依次选择系统管理-&gt;管理插件，在“可选插件”中选中“Xcode integration”安装，安装完这个插件我们还需要安装一个“Keychains and Provisioning Profiles Management”插件。这个插件用于我们设置签名和证书。</p><p>安装“Keychains and Provisioning Profiles Management”之后，我们去到系统管理-&gt;Keychains and Provisioning Profiles Management设置签名和证书。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337147054369.jpg" alt=""></p><p>这里需要选择 login.keychain ，在 /Users/用户名/Library/keychains/login.keychain 目录里。如果不能通过选择的话，可以把login.keychain拷贝到桌面，然后在选择上传。<br>Code Signing Identity，可以添加多项。进入钥匙串，选择开发者证书或发布证书，拷贝完全，粘贴至Jenkins的Code Signing Identity项。</p><p>当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下</p><p>到这里Jenkins的搭建就算完成了，下一篇文章我们将会使用jenkins创建一个任务，然后构造版本并且上传蒲公英，最终的目的都是通过一个脚本来完成上述的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于一个APP来说，我相信我们开发最担心的就是出bug，只要是线上APP出bug，心里就慌得很，这是一件很严重的事情，还有可能让用户一气之下把你的APP删掉，从此再也不会出现在他的手机里面。&lt;/p&gt;
&lt;p&gt;但是如果我们严格把控APP的质量，我们做到每天都构建一个版本并且测试，我们将这个APP上传到一个特定的测试系统，当有代码更新的时候或者每天设置一个时间去不断的跑测试，这样我们在开发阶段就发现很多问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上面我们说的就是CI(Continuous Integration)持续集成+TDD(Test Driven Development)测试驱动开发。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="jenkins" scheme="http://lemon2well.top/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>用队列实现栈和用栈实现队列</title>
    <link href="http://lemon2well.top/2018/08/03/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://lemon2well.top/2018/08/03/常见算法/用队列实现栈和用栈实现队列/</id>
    <published>2018-08-03T02:44:23.000Z</published>
    <updated>2018-08-03T02:46:05.639Z</updated>
    
    <content type="html"><![CDATA[<p>用两个栈来实现队列，思路和用数组实现队列一样</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//用栈实现队列</span><br><span class="line">struct QueueByStack&#123;</span><br><span class="line">    </span><br><span class="line">    var Peek: Int? &#123;</span><br><span class="line">        mutating middleCaulate()</span><br><span class="line">        return rightStack?.peek</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    typealias Element = Int</span><br><span class="line">    </span><br><span class="line">    private var leftStack:IntergerStack?</span><br><span class="line">    private var rightStack:IntergerStack?</span><br><span class="line">    </span><br><span class="line">    init() &#123;</span><br><span class="line">    leftStack = IntergerStack()</span><br><span class="line">    rightStack = IntergerStack()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var isEmpty: Bool &#123;return leftStack!.isEmpty &amp;&amp; rightStack!.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return leftStack!.Size + rightStack!.Size&#125;</span><br><span class="line">    </span><br><span class="line">    mutating func middleCaulate()&#123;</span><br><span class="line">        if leftStack!.isEmpty &#123;</span><br><span class="line">            while !rightStack!.isEmpty&#123;</span><br><span class="line">                leftStack!.push((rightStack?.pop())!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func enQueue(_ newElement: Int) &#123;</span><br><span class="line">        rightStack?.push(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func deQueue() -&gt; Int? &#123;</span><br><span class="line">        middleCaulate()</span><br><span class="line">        return leftStack?.peek</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用两个队列来实现栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct StackByQueue &#123;</span><br><span class="line">    private var queueA : IntergerQueue?</span><br><span class="line">    private var queueB : IntergerQueue?</span><br><span class="line">    init() &#123;</span><br><span class="line">        queueA = IntergerQueue()</span><br><span class="line">        queueB = IntergerQueue()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var isEmpty: Bool&#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return queueA!.isEmpty &amp;&amp; queueB!.isEmpty</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var Size: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return queueA!.Size</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var peek: Int?&#123;</span><br><span class="line">        mutating get &#123;</span><br><span class="line">            transfer()</span><br><span class="line">            let obj = queueB?.Peek</span><br><span class="line">            swap()</span><br><span class="line">            return obj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func push(_ newElement:Int)&#123;</span><br><span class="line">        queueB?.enQueue(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func pop()-&gt;Int?&#123;</span><br><span class="line">        transfer()</span><br><span class="line">        let obj = queueB?.deQueue()</span><br><span class="line">        swap()</span><br><span class="line">        return obj</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func transfer() &#123;</span><br><span class="line">        if queueB?.Size != 1&#123;</span><br><span class="line">            queueA?.enQueue((queueB?.deQueue())!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func swap()&#123;</span><br><span class="line">        (queueA,queueB) = (queueB,queueA)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用两个栈来实现队列，思路和用数组实现队列一样&lt;/p&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://lemon2well.top/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>swift实现栈和队列</title>
    <link href="http://lemon2well.top/2018/08/02/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/swift%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://lemon2well.top/2018/08/02/常见算法/swift实现栈和队列/</id>
    <published>2018-08-02T15:58:37.000Z</published>
    <updated>2018-08-02T16:00:14.923Z</updated>
    
    <content type="html"><![CDATA[<p>在swift中并没有内设的栈和队列，接下来我们通过数组来实现栈和队列</p><p>栈的实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protocol Stack &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    //是否为空</span><br><span class="line">    var isEmpty: Bool&#123; get &#125;</span><br><span class="line">    //栈的大小</span><br><span class="line">    var Size: Int&#123; get &#125;</span><br><span class="line">    //栈顶元素</span><br><span class="line">    var peek: Element? &#123; get &#125;</span><br><span class="line">    //入栈</span><br><span class="line">    mutating func push(_ newElement:Element)</span><br><span class="line">    //出栈</span><br><span class="line">    mutating func pop()-&gt;Element?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct IntegerStack:Stack &#123;</span><br><span class="line">    typealias Element  = Int</span><br><span class="line">    private var stack = [Element]()</span><br><span class="line">    var isEmpty: Bool &#123;return stack.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return stack.count&#125;</span><br><span class="line">    var peek: Int? &#123;return stack.last&#125;</span><br><span class="line">    mutating func push(_ newElement: Int) &#123;</span><br><span class="line">        self.stack.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    func pop() -&gt; Int? &#123;</span><br><span class="line">        return stack.last</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>队列的实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protocol Queue &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    var isEmpty: Bool &#123;get&#125;</span><br><span class="line">    var Size: Int &#123;get&#125;</span><br><span class="line">    var Peek:Element? &#123;get&#125;</span><br><span class="line">    mutating func enQueue(_ newElement:Element)</span><br><span class="line">    mutating func deQueue()-&gt;Element?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct IntergerQueue:Queue &#123;</span><br><span class="line">    typealias Element = Int</span><br><span class="line">    private var left = [Element]()</span><br><span class="line">    private var right = [Element]()</span><br><span class="line">    var isEmpty: Bool &#123;return left.isEmpty &amp;&amp; right.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return left.count + right.count&#125;</span><br><span class="line">    var Peek: Element? &#123;return left.isEmpty ? right.first : left.last&#125;</span><br><span class="line">    mutating func enQueue(_ newElement: Int) &#123;</span><br><span class="line">       right.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func deQueue() -&gt; Element? &#123;</span><br><span class="line">        if left.isEmpty &#123;</span><br><span class="line">            left = right.reversed()</span><br><span class="line">            right.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        return left.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在swift中并没有内设的栈和队列，接下来我们通过数组来实现栈和队列&lt;/p&gt;
&lt;p&gt;栈的实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protocol Stack &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    associatedtype Element&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //是否为空&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var isEmpty: Bool&amp;#123; get &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //栈的大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var Size: Int&amp;#123; get &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //栈顶元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var peek: Element? &amp;#123; get &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //入栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mutating func push(_ newElement:Element)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //出栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mutating func pop()-&amp;gt;Element?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct IntegerStack:Stack &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    typealias Element  = Int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private var stack = [Element]()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var isEmpty: Bool &amp;#123;return stack.isEmpty&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var Size: Int &amp;#123;return stack.count&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var peek: Int? &amp;#123;return stack.last&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mutating func push(_ newElement: Int) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.stack.append(newElement)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func pop() -&amp;gt; Int? &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return stack.last&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://lemon2well.top/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="http://lemon2well.top/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://lemon2well.top/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>网络层设计方案以及去Model化实践</title>
    <link href="http://lemon2well.top/2018/08/02/iOS%20%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E4%BB%A5%E5%8F%8A%E5%8E%BBModel%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>http://lemon2well.top/2018/08/02/iOS 开发/网络层设计方案以及去Model化实践/</id>
    <published>2018-08-02T09:30:30.000Z</published>
    <updated>2018-08-02T09:32:52.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然在网上看到<a href="https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="noopener">casa的网络层设计方案</a>，在以前的iOS开发中，用的最多的就是集约型的网络请求+去Model的形式，然而在看完这篇文章之后我觉得好像发现了新大陆，原来还可以这么玩。</p><a id="more"></a><blockquote><ol><li>此网络层设计方案最大的好处就是解耦，每个API都有特定的APIManager管理，可以方便的缓存数据以及取消网络请求。</li><li>在集约型网络基础上封装了散约型的API，参数以及请求以及处理请求数据全部封装到该APIManager方法里面。</li><li>通过Delegate的方法回调，更好的方便调试以及释放对象。如果以block来调用的话首先不方便调试，其次会延长对象的生命周期，对象需要必须等到网络请求回来之后才能释放。</li><li>提供一个BaseAPIManager，然后通过IOP的方式约束子类必须要遵循APIRequestProtocol，通过实现该协议的方式来提供给API参数，这样父类就不用提供空载函数。 该父类还提供一个代理，该代理用于返回数据。</li><li>最后是去Model化的设计，APIRequestProtocol 提供了一个<code>-(id)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer;</code>协议方法，在该方法里面可以会传入一个遵守ReformProtocol协议的reformer，到时reformer就可以自定义处理数据的方法，返回特定的数据</li><li>ReformProtocol有一个<code>- (id)reformDataWith:(LMBaseAPIManager*)apiManager;</code>的协议方法，里面可以根据apiManager做判断，然后返回不同的数据，也就是说，一个reformer可以对应多个apiManager。</li></ol></blockquote><p>具体的原理和好处在case的文章里面已经说得很清楚了</p><h2 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h2><p><img src="http://pcd17v2u0.bkt.clouddn.com/15331959524160.jpg" alt=""></p><ul><li>LMNetwork是具体的网络出口类，里面提供了集约化的网络请求方法，通过block返回数据。</li><li><p>LMBaseAPIManager是网络请求基类，里面有一个遵循了APIRequestProtocol协议的request，这个协议提供了网络请求参数的的方法和处理网络请求结果的方法。发送网络请求的时候会通过这个request获取必要的参数，以及返回数据的时候通过这个类处理数据。</p><p>该类还提供了一个遵循了APIResponseProtocol的代理对象，当网络返回数据的时候会调用该协议方法，该协议方法返回一个遵循APIRequestProtocol的request，调用方需要调用<code>fetchDataWithReformer:</code>方法，并且传入一个reformer，然后在该方法的实现里面就可以将apiManager传给reformer，reformer可以根据不同apiManager做不同的数据返回了。</p><p>LMBaseAPIManager还提供了两个属性，一个responseData和error，网络请求结果和错误都会放到这里面，到时将apiManager传到reformer的时候，通过这两个属性可以取出数据。</p><p>LMBaseAPIManager还可以提供一个isCache的方法，可以自己设置缓存策略。</p><p>总的来说，LMBaseAPIManager需要派生一个子类，然后子类需要实现apiRequestProtocol方法，提供网络必要的参数。调用<code>startRequest</code>方法之后调用LMNetwork发送网络请求。当网络请求回来之后，通过代理回调结果，并且将apiManager返回，调用方收到回调时候，传入reformer对数据进行处理。</p></li></ul><ul><li><p>LMReformerProtocol是一个协议，里面有一个协议方法<code>- (id)reformDataWith:(LMBaseAPIManager*)apiManager;</code>该方法用来处理返回数据。</p></li><li><p>LMProductionAPIManager是LMBaseAPIManagerd的派生类，里面提供了apiRequestProtocol协议方法的实现。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以上已经将框架介绍清楚了，下面是代码实现：</p><ol><li>首先初始化productionAPIManager并且设计代理。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (LMProductionAPIManager *)productionAPIManager&#123;</span><br><span class="line">    if(!_productionAPIManager)&#123;</span><br><span class="line">        _productionAPIManager = [[LMProductionAPIManager alloc]init];</span><br><span class="line">        _productionAPIManager.response = self;</span><br><span class="line">    &#125;</span><br><span class="line">    return _productionAPIManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于LMProductionAPIManager是LMBaseAPIManagerd的子类，因此会调用父类的init方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        if ([self conformsToProtocol:@protocol(APIRequestProtocol)]) &#123;</span><br><span class="line">            self.request = (id&lt;APIRequestProtocol&gt;)self;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSAssert(NO, @&quot;子类必须要遵循APIRequestProtocol协议&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于子类遵循了 <code>@interface LMProductionAPIManager: LMBaseAPIManager&lt;APIRequestProtocol&gt;</code> APIRequestProtocol协议，因为该类内部有一个request的属性指向该对象。而该对象是遵循了上述的协议，所以要实现上述协议里面的方法，接下来看看LMProductionAPIManager里面的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@implementation LMProductionAPIManager</span><br><span class="line">- (NSString *)apiRequestName&#123;</span><br><span class="line">    return  @&quot;http://120.197.235.101:8080/apk/iosPagingQuery?pageNo=1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSString *)apiRequestMethod&#123;</span><br><span class="line">    return GET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)apiRequestParameters&#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer&#123;</span><br><span class="line">    if (reformer == nil) &#123;</span><br><span class="line">        return self.responseData;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [reformer reformDataWith:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该对象内部提供了url以及get方法和参数，还提供处理返回数据的实现。</p><ol start="2"><li><p>接下来调用 <code>[self.productionAPIManager startRequest];</code>方法，看看该方法内部会做什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   - (void)startRequest&#123;</span><br><span class="line">    [[LMNetwork sharedInstance]requestMethod:[self.request apiRequestMethod] url:[self.request apiRequestName] parameters:[self.request apiRequestParameters] finishBlock:^(id data, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            self.responseError = error;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">         self.responseData = data;</span><br><span class="line">         &#125;</span><br><span class="line">        if ([self.response respondsToSelector:@selector(apiResponseSuccess:)]) &#123;</span><br><span class="line">            [self.response apiResponseSuccess:self.request];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>该方法会发送网络请求并且将请求后的数据复制给当前对象的相关属性，然后通过代理回到结果，并且将当前请求对象返回。</p><ol start="3"><li><p>调用方收到代理之后进行处理 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)apiResponseSuccess:(id&lt;APIRequestProtocol&gt;)request&#123;</span><br><span class="line">    [MBProgressHUD hideHUD];</span><br><span class="line">    self.productionArr =  [request fetchDataWithReformer:[LMProductReformer new]];</span><br><span class="line">    [self.tableView reloadData];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>收到回调之后首先对初始化一个LMProductionReform对象，该对象遵循了LMReformerProtocol协议，待会再来看里面的实现。</p><p>然后调用request的协议方法 <code>fetchDataWithReformer</code>该方法的实现在第一点已经提到了，该方法内部会看一下有没有传reformer进来，如果没有的话直接返回未经处理的对象，如果有的话那就调用reformer的LMReformerProtocol协议方法。</p><p>接下来来看<code>LMReformerProtocol</code>方法的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   - (id)reformDataWith:(LMBaseAPIManager *)apiManager&#123;</span><br><span class="line">    //这里根据不同的APIManager返回相应的数据</span><br><span class="line">    if ([apiManager isKindOfClass: [LMProductionAPIManager class]]) &#123;</span><br><span class="line">        NSDictionary *dict = apiManager.responseData;</span><br><span class="line">        NSArray *list = dict[@&quot;list&quot;];</span><br><span class="line">        NSMutableArray *mArr = [NSMutableArray arrayWithCapacity:list.count];</span><br><span class="line">        for (NSDictionary *dict in list) &#123;</span><br><span class="line">            NSDictionary *infoDict = @&#123;kLMProductionVer:dict[@&quot;ver&quot;],kLMProductionVerDesc:dict[@&quot;verDesc&quot;]&#125;;</span><br><span class="line">            [mArr addObject:infoDict];</span><br><span class="line">        &#125;</span><br><span class="line">        return mArr;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return  nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>reform在这里根据不同的APIManager进行不同的解析，返回不同的数据。</p><p>到这里，整个网络和去model的设计就完成了。每个API都应该对应一个APIManager，但是可以使用同一个reformer，然后reformer对apimanager做判断从而返回不同的数据。</p><p>值得注意的是：由于我们用字典的形式来存储数据，所以肯定会有hardcode，我们可以定义一个头文件了里面包含所有我们用到的字符串常量，然后在reformer的实现文件里面给这些常量赋值。<br>如在<code>LMProductReformKeys.h</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern NSString *const kLMProductionVer;</span><br><span class="line">extern NSString *const kLMProductionVerDesc;</span><br></pre></td></tr></table></figure><p>在<code>LMProductReformer.m</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString * const kLMProductionVer = @&quot;productionVer&quot;;</span><br><span class="line">NSString * const kLMProductionVerDesc = @&quot;productionVerDesc&quot;;</span><br></pre></td></tr></table></figure><p>这样只要引入LMProductReformer.h都可以使用该常量。</p><p>完整的<a href="https://github.com/codemonkeybulucck/NoModelExample.git" target="_blank" rel="noopener">demo</a></p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;偶然在网上看到&lt;a href=&quot;https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;casa的网络层设计方案&lt;/a&gt;，在以前的iOS开发中，用的最多的就是集约型的网络请求+去Model的形式，然而在看完这篇文章之后我觉得好像发现了新大陆，原来还可以这么玩。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="去model" scheme="http://lemon2well.top/tags/%E5%8E%BBmodel/"/>
    
  </entry>
  
  <entry>
    <title>快行指针</title>
    <link href="http://lemon2well.top/2018/08/01/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E5%BF%AB%E8%A1%8C%E6%8C%87%E9%92%88/"/>
    <id>http://lemon2well.top/2018/08/01/常见算法/快行指针/</id>
    <published>2018-08-01T15:11:07.000Z</published>
    <updated>2018-08-01T15:12:02.824Z</updated>
    
    <content type="html"><![CDATA[<p>快行指针的定义就是有两个指针访问链表，但是一个指针的速度比另外一个快，或者说一个指针在前，一个在后。</p><p>根据这个特性我们可以用来检测一个链表中是否有环。</p><blockquote><p>假设：一个指针的速度是另外一个指针的两倍，它们同时开始访问同一个链表，如果链表有环的情况下，那么快行指针总会追上慢行指针，也就是总有一个时刻快行指针和慢行指针指向同一个节点，当慢行指针跑一圈的时候，快行指针此时刚好跑了两圈。<br><a id="more"></a><br>以下是具体算法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:Equatable &#123;</span><br><span class="line">//遵守Equatable协议</span><br><span class="line">    static func == (lhs: ListNode, rhs: ListNode) -&gt; Bool &#123;</span><br><span class="line">        if lhs.val == rhs.val &amp;&amp; lhs.next == rhs.next&#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      public var val: Int</span><br><span class="line">      public var next: ListNode?</span><br><span class="line">      public init(_ val: Int) &#123;</span><br><span class="line">          self.val = val</span><br><span class="line">          self.next = nil</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class quickSolution &#123;</span><br><span class="line">    func checkCycle(_ l1:ListNode?)-&gt;Bool&#123;</span><br><span class="line">        guard let l1 = l1 else&#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        var slowNode:ListNode? = l1,fastNode:ListNode? = l1</span><br><span class="line">        while fastNode != nil &amp;&amp; fastNode?.next != nil &#123;</span><br><span class="line">            slowNode = slowNode?.next</span><br><span class="line">            fastNode = fastNode?.next!.next</span><br><span class="line">            if slowNode == fastNode &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们依然可以用这个方法来解决另外一个问题。<br>删除链表中的第n个节点，例如：1-&gt;3-&gt;6-&gt;5-&gt;2 ，这里要删除倒数第2个节点。那么删除后的链表为： 1-&gt;3-&gt;6-&gt;2。</p><blockquote><p>思路：<br>假设快行指针从一开始就比慢行指针快n个节点，然后他们以相同的速度前进，当快行指针走到链表的最后一个节点的时候，慢行指针的当前节点的下一个节点就是我们要删除的节点。</p></blockquote><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class DeleteSolution &#123;</span><br><span class="line">    func deleteNode(_ l1:ListNode?,n:Int)-&gt;ListNode?&#123;</span><br><span class="line">        guard let l1 = l1 else&#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        let dummy = ListNode(0)</span><br><span class="line">        dummy.next = l1</span><br><span class="line">        var slowNode:ListNode? = dummy</span><br><span class="line">        var fastNode:ListNode? = dummy</span><br><span class="line">        //设置快行指针比慢行指针快n个节点</span><br><span class="line">        for _ in 0 ..&lt; n &#123;</span><br><span class="line">            if fastNode == nil &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            fastNode = fastNode?.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //同时移动两个指针</span><br><span class="line">        while fastNode != nil &amp;&amp; fastNode?.next != nil &#123;</span><br><span class="line">            slowNode = slowNode?.next</span><br><span class="line">            fastNode = fastNode?.next</span><br><span class="line">        &#125;</span><br><span class="line">        //删除需要删除的节点</span><br><span class="line">        slowNode?.next = slowNode?.next?.next</span><br><span class="line">        return dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快行指针的定义就是有两个指针访问链表，但是一个指针的速度比另外一个快，或者说一个指针在前，一个在后。&lt;/p&gt;
&lt;p&gt;根据这个特性我们可以用来检测一个链表中是否有环。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设：一个指针的速度是另外一个指针的两倍，它们同时开始访问同一个链表，如果链表有环的情况下，那么快行指针总会追上慢行指针，也就是总有一个时刻快行指针和慢行指针指向同一个节点，当慢行指针跑一圈的时候，快行指针此时刚好跑了两圈。&lt;br&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://lemon2well.top/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://lemon2well.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>dummy节点和尾巴插法</title>
    <link href="http://lemon2well.top/2018/07/31/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/dummy%E8%8A%82%E7%82%B9%E5%92%8C%E5%B0%BE%E5%B7%B4%E6%8F%92%E6%B3%95/"/>
    <id>http://lemon2well.top/2018/07/31/常见算法/dummy节点和尾巴插法/</id>
    <published>2018-07-31T15:35:01.000Z</published>
    <updated>2018-07-31T15:36:54.856Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个链表和一个数X，要求将链表中所有小于X的值放到左边，等于或者大于X的值放到右边，并且原链表的节点顺序不变。</p><p>示例：<br>假设： 1-&gt;7-&gt;3-&gt;5-&gt;2-&gt;8-&gt;4，给定x=4<br>那么变换后的节点为： 1-&gt;3-&gt;2-&gt;7-&gt;5-&gt;8-&gt;4</p><a id="more"></a><blockquote><p>思路：<br>我们先把题目简单化，我们可以先找出链表中小于X的节点放到一个新的链表里面<br>然后再找出等于或者大于X的节点放到另外一个条链表<br>最后将第一条链表的next指向第二条链表的头结点，这样就完成了题目的要求。</p></blockquote><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">      public var val: Int</span><br><span class="line">      public var next: ListNode?</span><br><span class="line">      public init(_ val: Int) &#123;</span><br><span class="line">          self.val = val</span><br><span class="line">          self.next = nil</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class NewSoluction &#123;</span><br><span class="line">    func getNewList(_ l1:ListNode?,x:Int)-&gt;ListNode?&#123;</span><br><span class="line">        let headDummy = ListNode(0), tailDummy = ListNode(0)</span><br><span class="line">        var head = headDummy,tail = tailDummy</span><br><span class="line">        var node = l1</span><br><span class="line">        while node != nil &#123;</span><br><span class="line">            if node!.val &lt; x &#123;</span><br><span class="line">                head.next = node!</span><br><span class="line">                head = node!</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                tail.next = node!</span><br><span class="line">                tail = node!;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node!.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = nil;</span><br><span class="line">        //头链加上尾链</span><br><span class="line">        head.next = tailDummy.next</span><br><span class="line">        return headDummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：tail.next = nil 是为了防止形成环，因为<code>tail.next = node ! ,tail = node</code>这一句实际上是形成了环，所以需要将tail.next置空来打破环</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个链表和一个数X，要求将链表中所有小于X的值放到左边，等于或者大于X的值放到右边，并且原链表的节点顺序不变。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;假设： 1-&amp;gt;7-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;8-&amp;gt;4，给定x=4&lt;br&gt;那么变换后的节点为： 1-&amp;gt;3-&amp;gt;2-&amp;gt;7-&amp;gt;5-&amp;gt;8-&amp;gt;4&lt;/p&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://lemon2well.top/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表结构" scheme="http://lemon2well.top/tags/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>iOS 组件化实践《二》基于现有项目拆分组件化实践</title>
    <link href="http://lemon2well.top/2018/07/31/iOS%20%E5%BC%80%E5%8F%91/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%BA%8C%E3%80%8B-%E5%9F%BA%E4%BA%8E%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>http://lemon2well.top/2018/07/31/iOS 开发/组件化实践《二》-基于现有项目拆分组件化实践/</id>
    <published>2018-07-31T08:41:12.000Z</published>
    <updated>2018-07-31T08:45:00.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><blockquote><p>在<a href="http://lemon2well.top/2018/07/30/iOS%20开发/组件化实践《一》创建私有pod/">第一篇</a>介绍中已经介绍了如果发布一个私有pod，下面将会介绍如何基于一个现有的项目拆分成组件化形式的项目。<br>假设我们现有的项目是有一个AViewController,还有一个BViewController，目前的功能是点击rootViewController页面的按钮会push到AviewController，然后点击AviewController的一个按钮会跳转到BViewController。这里是未拆分的<a href="https://github.com/codemonkeybulucck/TestModule" target="_blank" rel="noopener">demo</a></p></blockquote><a id="more"></a><h2 id="0x02-拆分组件"><a href="#0x02-拆分组件" class="headerlink" title="0x02 拆分组件"></a>0x02 拆分组件</h2><blockquote><p>现在我们要拆分AViewController和BViewController,将他们拆分成两个组件，并且按照Target-Action的形式提供对外的接口，通过中间件去调用Target对应的Action，在最上层是中间件的分类，给调用方提供具体且便利的方法和接口。</p></blockquote><h3 id="0x02-1-分析如何拆分AViewController"><a href="#0x02-1-分析如何拆分AViewController" class="headerlink" title="0x02.1 分析如何拆分AViewController"></a>0x02.1 分析如何拆分AViewController</h3><ol><li><p>首先AViewController，现在AViewController需要外部传一个NSString类型的参数进去，然后返回一个AViewController的对象。这个时候应该创建一个Target_AViewController的类，然后对外一个<code>Action_fectchAViewController:</code>的方法，这个方法需要接收一个字典类型的参数，到时我们会从这个字典中取出key为navTitle的值来作为AViewController的参数。以下是该方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   - (UIViewController*)Action_fetchAViewController:(NSDictionary*)params&#123;</span><br><span class="line">    AViewController *aViewControlelr = [[AViewController alloc]init];</span><br><span class="line">    NSString *title = params[@&quot;navTitle&quot;];</span><br><span class="line">    aViewControlelr.navTitle = title;</span><br><span class="line">    return aViewControlelr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>然后我们要创建CTMediator的分类<code>CTMediator+ModuleAActions</code>，这个分类方法对外提供了一个<code>fetchAViewController</code>的方法，到时调用方调用此方法即可获取到一个AViewController的实例，而不用自己去初始化AViewController。</p></li><li><p>那么上面那个分类具体做了什么操作呢，该方法会传一个“AViewController”和“fetchAViewController”来表明需要调用Target_AViewController的Action_fetchAViewller方法，也就是我们刚刚提供的Target_Action。本来调用方是不用通过类别来调用组件Target_Action的，因为可以通过CTMediator的<code>perform Target: action: params:</code>来直接调用。但是那样非常不友好以及不统一。<br>加上了该分类之后，可以做更多的容错处理以及有一个容易的入口。</p></li><li><p>所以在后面做成pod的时候，category是一个pod，它只依赖于CTMediator，调用方法是通过CTMediator通过runtime来找到Target_Action来调用。所以另外一个pod就是AViewController+Target_AViewController。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   - (UIViewController*)fetchAViewController&#123;</span><br><span class="line">    UIViewController *vc = [self performTarget:@&quot;AViewController&quot; action:@&quot;fetchAViewController&quot; params:@&#123;@&quot;navTitle&quot;:@&quot;This is A ViewController&quot;&#125; shouldCacheTarget:NO];</span><br><span class="line">    if ([vc isKindOfClass:[UIViewController class]]) &#123;</span><br><span class="line">        return vc;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [[UIViewController alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>以上提到的pod：</strong><br><a href="https://github.com/codemonkeybulucck/AViewControllerCategory" target="_blank" rel="noopener">CategoryAViewController</a><br><a href="https://github.com/codemonkeybulucck/LMAViewController" target="_blank" rel="noopener">AviewControllerPod</a><br><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="noopener">CTMediactor</a></p><h3 id="0x02-2-创建BViewController的category和Target-Action的pod"><a href="#0x02-2-创建BViewController的category和Target-Action的pod" class="headerlink" title="0x02.2 创建BViewController的category和Target_Action的pod"></a>0x02.2 创建BViewController的category和Target_Action的pod</h3><p>1、为什么需要先创建BViewController组件，因为AViewController会依赖于BViewController，所以我们先创建BViewController组件。</p><p>2、首先我们先创建BViewController私有pod，按照我的<a href="http://lemon2well.top/2018/07/30/iOS%20开发/组件化实践《一》创建私有pod/">组件化实践《一》</a>创建好<a href="https://github.com/codemonkeybulucck/BViewController" target="_blank" rel="noopener">BViewController</a>的pod，这个pod不用依赖于任何其他组件，所以应该没啥困难。</p><p>3、接下来我们需要创建<a href="https://github.com/codemonkeybulucck/BCategory" target="_blank" rel="noopener">BViewControllerCategory</a>，这里有一点要注意的是在podspec文件的最下面需要加入<code>s.dependency &#39;CTMediator&#39;</code>，因为里面需要用到CTMediator的perform方法去调用到对应的组件。因为CTMediator已经发布到cocoapods所以可以直接用，如果这里的依赖是你自己改动之后的私有Mediator，记得在pod spec lint 的时候要加上<code>--sources=yourgithub/spec,master</code>将源改成你自己的私有索引库的地址，不然默认是从公有索引库里面找不到对应的Mediator。待会在AViewController调用B的时候会用到这个命令。</p><h3 id="0x02-3-创建AViewController的category和Target-Action的pod"><a href="#0x02-3-创建AViewController的category和Target-Action的pod" class="headerlink" title="0x02.3 创建AViewController的category和Target_Action的pod"></a>0x02.3 创建AViewController的category和Target_Action的pod</h3><p>1、方法同上，首先创建AViewController的<a href="https://github.com/codemonkeybulucck/AViewControllerCategory" target="_blank" rel="noopener">Category</a>组件，这里只需要注意在podspec文件的最下面需要加入<code>s.dependency &#39;CTMediator&#39;</code>。<br>2、 然后我们创建<a href="https://github.com/codemonkeybulucck/LMAViewController" target="_blank" rel="noopener">AViewController</a>私有pod，由于在AViewController里面我们有个按钮点击之后会push到BViewController，那必然要引入BViewController，但是在组件中不会直接引入BViewController，我们通过引入BViewControllerCategory来让程序编译的时候不要报错就行。podspec文件要加入<code>s.dependency &#39;BCategory&#39;</code>。</p><p>3、 验证，因为第二部中我们的私有工程依赖了另外一个私有工程，这个时候的<code>pod spec lint</code>和 <code>pod repo push</code>命令都要加上 <code>--source</code>说明</p><p><strong>注意：组件间的调用依然是利用Target对应的分类来调用。记住分类是统一的入口，组件里面的代码不会依赖于另外一个组件，而是依赖于对应的分类组件或者CTMediator，然后所有依赖的pod都要写到主工程的podfile里面</strong></p><h2 id="0x03-引用组件"><a href="#0x03-引用组件" class="headerlink" title="0x03 引用组件"></a>0x03 引用组件</h2><p>我们将AViewController和BViewController拆分后，我们创建一个demo来测试一下刚刚拆分的组件。创建一个OC项目，在项目的跟目录下执行<code>pod init</code>，然后在podfile文件里面写入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/codemonkeybulucck/LMSpec&apos;</span><br><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"></span><br><span class="line">target &apos;moduleTest&apos; do</span><br><span class="line">  # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line">  pod &apos;ACategory&apos;</span><br><span class="line">  pod &apos;AViewController&apos;,&apos;~&gt;0.1.1&apos;</span><br><span class="line">  pod &apos;BViewController&apos;</span><br><span class="line">  # Pods for moduleTest</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>完成后执行 <code>pod install</code>，成功之后再<code>#import &quot;CTMediator+ModuleAActions.h&quot;</code> 然后调用方式就变成了<br><code>UIViewController *vc = [[CTMediator sharedInstance] fetchAViewController];</code></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>组件化最核心的思想就是解耦，将庞大的项目抽丝剥茧，分离成互相独立的一个一个模块，每个模块都是可复用的。上述的方案其实已经做到了解耦，调用者只需要用到中间件的分类的方法接口而不需要引入实际的组件的类。<br>但是在分类里面有一个弊端就是：动态调用方法的时候需要硬编码也就是，这样容错率就很低，不过幸好这个东西是在分类中，在开发的过程中就可以发现的问题。<br>另外一个方面也不是所有的项目都适合用组件化，只有当项目规模扩大到一定的程度，并且人员众多的情况下用组件化的便捷性才体现出来。所以很多时候我们讨论架构或者讨论一种新的技术，并不是它就是最好的，没有什么东西是最好的，只有最合适的，因地制宜。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://lemon2well.top/2018/07/30/iOS%20开发/组件化实践《一》创建私有pod/&quot;&gt;第一篇&lt;/a&gt;介绍中已经介绍了如果发布一个私有pod，下面将会介绍如何基于一个现有的项目拆分成组件化形式的项目。&lt;br&gt;假设我们现有的项目是有一个AViewController,还有一个BViewController，目前的功能是点击rootViewController页面的按钮会push到AviewController，然后点击AviewController的一个按钮会跳转到BViewController。这里是未拆分的&lt;a href=&quot;https://github.com/codemonkeybulucck/TestModule&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="cocoapods" scheme="http://lemon2well.top/tags/cocoapods/"/>
    
      <category term="组件化" scheme="http://lemon2well.top/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://lemon2well.top/2018/07/31/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://lemon2well.top/2018/07/31/常见算法/无重复字符的最长子串/</id>
    <published>2018-07-31T02:30:35.000Z</published>
    <updated>2018-07-31T02:31:33.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><p>示例：</p><p>给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。</p><p>给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。</p><p>给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列  而不是子串。</p><a id="more"></a><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">leetcode链接</a></p><blockquote><p>解答思路：</p><ol><li>首先从头开始遍历字符串，并且将已经遍历过的字符串放到一个数组里面</li><li>但是放到数组里面的前提是当前遍历的字符并不存在在数组当中，也就是如果当前遍历的字符不在数组中，那么就将字符放到数组中，开始下一次遍历</li><li>如果当前当前的字符在数组中，那么找到该字符在数组中的下标，删除数组中从下标为0到该字符下标区间的元素，然后将当前字符放到数组里面开始下一次遍历。</li><li>每遍历一次，都要判断上一次的最长字符串maxCount是否小于当前数组的元素的数量，如果是，那么就更新maxCount。</li></ol></blockquote><p>下面是代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func _maxLongString(s:String!)-&gt;Int&#123;</span><br><span class="line">        if s.count == 0 &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">        var subArr = [CChar]()</span><br><span class="line">        var maxCount = 0;</span><br><span class="line">        var array = s.cString(using:.utf8)!</span><br><span class="line">        array.removeLast() //由于字符串会有一个结束符，所以需要删掉最后的结束符</span><br><span class="line">        for str in array&#123;</span><br><span class="line">            if subArr.contains(str) &#123;</span><br><span class="line">                let index:Int = subArr.index(of: str)!</span><br><span class="line">                let empty = 0..&lt;index+1</span><br><span class="line">                subArr.removeSubrange(empty)</span><br><span class="line">            &#125;</span><br><span class="line">            subArr.append(str)</span><br><span class="line">            maxCount = max(maxCount, subArr.count)</span><br><span class="line">        &#125;</span><br><span class="line">        return maxCount</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串&quot;&gt;&lt;/a&gt;无重复字符的最长子串&lt;/h1&gt;&lt;p&gt;给定一个字符串，找出不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。&lt;/p&gt;
&lt;p&gt;给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。&lt;/p&gt;
&lt;p&gt;给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列  而不是子串。&lt;/p&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://lemon2well.top/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>非空链表相加</title>
    <link href="http://lemon2well.top/2018/07/30/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E9%9D%9E%E7%A9%BA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/"/>
    <id>http://lemon2well.top/2018/07/30/常见算法/非空链表相加/</id>
    <published>2018-07-30T09:12:45.000Z</published>
    <updated>2018-07-30T09:33:42.698Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p><blockquote><p>思路：</p><ol><li>只要两个非空链表中的其中一个链表不为空的时候就循环便利两个链表</li><li>如果其中一个链表为空而另外一个链表不为空，那么为空的那个链表的值就为0</li><li>用一个carry位来表示是否有进位，0代表无进位，1代表有进位，因为链表中都是个位数，所以最大进位也只能为1，初始化进位为0</li><li>用x,y来表示当前两个链表的值，sum = x+y+carry为新链表的值，但是有可能有进位，所以新的carry = sum / 10,当前节点位的值为sum = sum %10。<a id="more"></a></li><li>创建一个新节点，将上述中sum的值赋给新节点，然后将新链表当前节点的next指向新节点，然后将当前节点指向到新节点</li><li>两个链表的当前节点都要指向下一个节点</li><li>当遍历完成之后，还需要判断一下carry的值是不是大于0，如果大于0则代表还需要创建一个节点，并且将新链表的节点的next指向该节点</li></ol></blockquote><p>以下是代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">      public var val: Int</span><br><span class="line">      public var next: ListNode?</span><br><span class="line">      public init(_ val: Int) &#123;</span><br><span class="line">          self.val = val</span><br><span class="line">          self.next = nil</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;</span><br><span class="line">        let resultNode = ListNode(0)</span><br><span class="line">        var currentNode = resultNode</span><br><span class="line">        var p = l1</span><br><span class="line">        var q = l2</span><br><span class="line">        var carry = 0 //表示进位</span><br><span class="line">        while p != nil || q != nil &#123;</span><br><span class="line">            //获取当前的值</span><br><span class="line">            var x = 0,y = 0;</span><br><span class="line">            if let p = p &#123;</span><br><span class="line">                x = p.val</span><br><span class="line">            &#125;</span><br><span class="line">            if let q = q &#123;</span><br><span class="line">                y = q.val</span><br><span class="line">            &#125;</span><br><span class="line">            let sum = x + y + carry</span><br><span class="line">            carry = sum / 10</span><br><span class="line">            let newSum = sum % 10;</span><br><span class="line">            currentNode.next = ListNode(newSum)</span><br><span class="line">            currentNode = currentNode.next!</span><br><span class="line">            p = p?.next</span><br><span class="line">            q = q?.next</span><br><span class="line">        &#125;</span><br><span class="line">        if carry &gt; 0 &#123;</span><br><span class="line">            currentNode.next = ListNode(carry)</span><br><span class="line">        &#125;</span><br><span class="line">        return resultNode.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只要两个非空链表中的其中一个链表不为空的时候就循环便利两个链表&lt;/li&gt;
&lt;li&gt;如果其中一个链表为空而另外一个链表不为空，那么为空的那个链表的值就为0&lt;/li&gt;
&lt;li&gt;用一个carry位来表示是否有进位，0代表无进位，1代表有进位，因为链表中都是个位数，所以最大进位也只能为1，初始化进位为0&lt;/li&gt;
&lt;li&gt;用x,y来表示当前两个链表的值，sum = x+y+carry为新链表的值，但是有可能有进位，所以新的carry = sum / 10,当前节点位的值为sum = sum %10。
    
    </summary>
    
      <category term="常见算法" scheme="http://lemon2well.top/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://lemon2well.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS 组件化实践《一》创建私有pod</title>
    <link href="http://lemon2well.top/2018/07/30/iOS%20%E5%BC%80%E5%8F%91/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%B8%80%E3%80%8B%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89pod/"/>
    <id>http://lemon2well.top/2018/07/30/iOS 开发/组件化实践《一》创建私有pod/</id>
    <published>2018-07-30T03:41:12.000Z</published>
    <updated>2018-07-30T08:09:31.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>本次组件化实践的方式来自于<a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">casaty组件化方案</a>，该方案是基于target-action模式和Mediator模式，通过Mediator利用runtime的机制来调用对应的target-action。并且在上层通过category的方式暴露对外调用的接口，这样调用者在调用的时候就知道需要传递哪些参数。</p><a id="more"></a><p>具体的调用方式就是：<br><img src="http://pcd17v2u0.bkt.clouddn.com/WX20180730-160336@2x.png" alt="WX20180730-160336@2x"></p><blockquote><p>实际上是可以不使用category的形式而是直接调用CTMediactor的<code>- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget</code> 方法直接调用对应target的action，但是那样对于调用方来说极其不友好，最直观的感受就是不知道params应该传哪些参数。</p></blockquote><blockquote><p>利用catogory的方式暴露方法的好处在于<br>1、一个组件对应一个category，每个category提供了组件所有的调用方法，调用方直接调用，可以直观的看到需要传递哪些参数。<br>2、提供统一的调用入口，所有的组件的被调用都是通过category<br>3、可以做异常处理，将参数的校验提前，并且可以做请求转发。</p></blockquote><h2 id="0x02-组件化实践"><a href="#0x02-组件化实践" class="headerlink" title="0x02 组件化实践"></a>0x02 组件化实践</h2><p>在简单的介绍了组件化的实际逻辑之后下面开始真正的开始动手实现组件化实践流程。</p><blockquote><p>一个私有pod的创建具体分为以下几步：</p></blockquote><ol><li>创建工程</li><li>创建私有库，修改podSpec文件，将本地代码库和远程代码库关联起来，上传代码到远程仓库。</li><li>创建远程索引库和本地索引库，也就是用于放置podspec的地方，每个podspec文件可以索引到我们远程不同的代码私有库</li><li>本地测试podspec文件是否可用</li><li>向索引库Spec Repo中提交podspec</li><li>测试Spec Repo中的的 podspec 是否可用</li></ol><p>1、 首先到github里面创建一个空的工程，例如我要创建一个FirstViewController<br><img src="http://pcd17v2u0.bkt.clouddn.com/15329320727207.jpg" alt=""></p><hr><p>2、 创建私有库，终端运行<code>pod lib create FirstViewController</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:Module lemon$ pod lib create FirstViewController</span><br><span class="line">Cloning `https://github.com/CocoaPods/pod-template.git` into `FirstViewController`.</span><br><span class="line">Configuring FirstViewController template.</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">To get you started we need to ask a few questions, this should only take a minute.</span><br><span class="line"></span><br><span class="line">If this is your first time we recommend running through with the guide:</span><br><span class="line"> - https://guides.cocoapods.org/making/using-pod-lib-create.html</span><br><span class="line"> ( hold cmd and click links to open in a browser. )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line"> &gt; iOS //pod平台</span><br><span class="line"></span><br><span class="line">What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line"> &gt; ObjC //pod语言</span><br><span class="line"></span><br><span class="line">Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class="line"> &gt; No //是否需要提供demo</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line"> &gt; None //测试框架</span><br><span class="line"></span><br><span class="line">Would you like to do view based testing? [ Yes / No ]</span><br><span class="line"> &gt; No //是否需要测试视图</span><br><span class="line"></span><br><span class="line">What is your class prefix?</span><br><span class="line"> &gt; LM //demo类前缀</span><br><span class="line"></span><br><span class="line">Running pod install on your new library.</span><br><span class="line"></span><br><span class="line">Analyzing dependencies</span><br><span class="line">Fetching podspec for `FirstViewController` from `../`</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing FirstViewController (0.1.0)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br></pre></td></tr></table></figure><p>上述命令执行完成之后会本地帮我们生成一个pod的模板文件，我们在这里首先需要改动的就是FirstViewController.podspec文件，用xcode打开该文件。<br>目前我们需要注意下面几处地方：</p><ul><li><code>s.version          = &#39;1.0.0&#39;</code>    //pod的版本，后面将podSpec文件提交到私有repo的时候会验证远程的仓库中是否已经存在对应的tag，所以这个要与后面提交代码的时候的tag相同,我们先修改为1.0.0，可以按照你们自己的标准修改。</li><li><code>s.homepage         = &#39;https://github.com/codemonkeybulucck/FirstViewController&#39;</code>  //homepage这里填写在第一步中再github创建的远程仓库的地址即可。</li><li><p><code>s.source           = { :git =&gt; &#39;https://github.com/codemonkeybulucck/FirstViewController.git&#39;, :tag =&gt; s.version.to_s }</code>  //这里填写远程仓库的地址，记得后面要加上.git的后缀</p></li><li><p><code>s.ios.deployment_target = &#39;8.0&#39;</code> //该pod的最低运行环境</p></li><li><p><code>s.source_files = &#39;FirstViewController/Classes/**/*&#39;</code> //pod中源代码的路径，后面会将实际的代码放在Classes文件夹下面</p></li></ul><p>一些其他设置的说明：</p><p>  s.summary          = ‘A short description of FirstViewController.’  //pod的简述<br>  s.description      = &lt;&lt;-DESC //具体描述<br> s.license          = { :type =&gt; ‘MIT’, :file =&gt; ‘LICENSE’ } //许可证<br>  s.author           = { <a href="mailto:&#39;545390087@qq.com" target="_blank" rel="noopener">&#39;545390087@qq.com</a>‘ =&gt; <a href="mailto:&#39;codebulucck@163.com" target="_blank" rel="noopener">&#39;codebulucck@163.com</a>‘ } //作者信息<br> s.dependency ‘AFNetworking’, ‘~&gt; 2.3’ //依赖库，如果该pod依赖其他pod，可以在此处加上。</p><p>完成podspec文件修改之后我们可以将对应的组件代码放到Classes文件夹路径下面。下面将本地代码库和远程代码库关联起来，然后将本地代码推送到远程仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git remote add origin https://github.com/codemonkeybulucck/FirstViewController.git</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git add .</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git commit -m &quot;初始化&quot;</span><br><span class="line">[master 8ac032c] 初始化</span><br><span class="line"> 25 files changed, 1209 insertions(+)</span><br><span class="line"> create mode 100644 Example/FirstViewController.xcworkspace/contents.xcworkspacedata</span><br><span class="line"> create mode 100644 Example/FirstViewController.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist</span><br><span class="line"> create mode 100644 Example/Podfile.lock</span><br><span class="line"> create mode 100644 Example/Pods/Local Podspecs/FirstViewController.podspec.json</span><br><span class="line"> create mode 100644 Example/Pods/Manifest.lock</span><br><span class="line"> create mode 100644 Example/Pods/Pods.xcodeproj/project.pbxproj</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-dummy.m</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-prefix.pch</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-umbrella.h</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController.modulemap</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController.xcconfig</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/Info.plist</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Info.plist</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-acknowledgements.markdown</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-acknowledgements.plist</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-dummy.m</span><br><span class="line"> create mode 100755 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-frameworks.sh</span><br><span class="line"> create mode 100755 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-resources.sh</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-umbrella.h</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.debug.xcconfig</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.modulemap</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.release.xcconfig</span><br><span class="line"> create mode 100644 FirstViewController/Classes/FirstViewController.h</span><br><span class="line"> create mode 100644 FirstViewController/Classes/FirstViewController.m</span><br><span class="line"> delete mode 100644 FirstViewController/Classes/ReplaceMe.m</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git push origin master</span><br><span class="line">Counting objects: 62, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (55/55), done.</span><br><span class="line">Writing objects: 100% (62/62), 23.04 KiB | 2.56 MiB/s, done.</span><br><span class="line">Total 62 (delta 10), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (10/10), done.</span><br><span class="line">To https://github.com/codemonkeybulucck/FirstViewController.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure><hr><p>3、 创建远程索引库和本地索引库，同样在github创建一个新的仓库，仓库的名字叫做LMSpec，这个仓库是pod的索引库，也就是后面如果要引用组件pod的话只要引入这个LMSpec就能从里面找到对应的组件。<br>    创建完远程仓库之后我们创建一个本地索引库，并且将本地索引库和远程仓库连接起来。<br>    <code>pod repo add LMSpec https://github.com/codemonkeybulucck/LMSpec.git</code> 执行完这条命令之后，去到 <code>~/.cocoapods/repo</code>路径下就能看到有一个master和LMSpec，master是公有cocoapod的索引库，LMSpec就是我们自己新建的索引库。到此我们已经创建好代码库以及索引库了。</p><hr><p>4、本地测试podspec文件是否可用 本地测试podspec文件是否可用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ pod lib lint</span><br><span class="line"></span><br><span class="line"> -&gt; FirstViewController (1.0.0)</span><br><span class="line">    - WARN  | summary: The summary is not meaningful.</span><br><span class="line"></span><br><span class="line">[!] FirstViewController did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it).</span><br><span class="line">You can use the `--no-clean` option to inspect any issue.</span><br></pre></td></tr></table></figure><p>上述验证表明我们本地验证已经没有错误了，但是有一个警告，我们可以使用<br><code>pod lib lint --allow-warnings</code>来忽略警告。如果我们使用<code>pod spec lint</code>来验证的话，记得要先本地代码库打tag然后将tag推动到远程仓库才能通过验证，因为该命令是同时验证本地和远程仓库，因为我们还没有打tag推送到远程仓库，所以我们先用<code>pod lib lint</code>来验证。</p><hr><p>5、 向索引库Spec Repo中提交podspec<br>  在第四步中我们已经验证我们的podspec文件没有问题了，但是我们现在还不能推送到索引库，因为我们还没有打tag，这个tag应该是与podspec文件里面的version一致，不一致的话远程验证的时候是通不过验证的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git tag -a 1.0.0 -m &quot;第一个版本pod&quot;</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git push origin master 1.0.0</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 183 bytes | 183.00 KiB/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/codemonkeybulucck/FirstViewController.git</span><br><span class="line"> * [new tag]         1.0.0 -&gt; 1.0.0</span><br></pre></td></tr></table></figure><p>完成上述步骤后我们需要将podspec提交到索引库中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ pod repo push LMSpec FirstViewController.podspec --allow-warnings</span><br><span class="line"></span><br><span class="line">Validating spec</span><br><span class="line"> -&gt; FirstViewController (1.0.0)</span><br><span class="line">    - WARN  | summary: The summary is not meaningful.</span><br><span class="line"></span><br><span class="line">Updating the `LMSpec&apos; repo</span><br><span class="line"></span><br><span class="line">Already up to date.</span><br><span class="line"></span><br><span class="line">Adding the spec to the `LMSpec&apos; repo</span><br><span class="line"></span><br><span class="line"> - [Add] FirstViewController (1.0.0)</span><br><span class="line"></span><br><span class="line">Pushing the `LMSpec&apos; repo</span><br></pre></td></tr></table></figure><p>至此为止我们已经将podspec文件推送到本地LMSpec和远程LMSpec里面了，可以到 <code>~/.cocoapods/repo/LMSpec</code>文件夹下看有没有对应FirstViewControll文件夹。该文件夹下会有一个1.0.0的文件夹，也就是我们刚刚打的tag的数值。后续如果修改代码需要重新打tag,然后到时这里也会出现新的版本的代码。<br><strong>注</strong> 如果该私有库里面引用了其他的私有库，也就是podspec文件中s.dependency引用了其他私有库的信息，需要指定私有库的位置，那么推送命令将变为</p><p><code>pod repo push LMSpec FirstViewController.podspec --allow-warnings --sources=https://github.com/codemonkeybulucck/LMSpec,master</code> </p><hr><p>6、 测试Spec Repo中的的 podspec 是否可用<br>创建一个ModuleTest的工程，进入到工程里面先执行 <code>pod init</code> ，然后编辑podfile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/codemonkeybulucck/LMSpec&apos;</span><br><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"></span><br><span class="line">target &apos;moduleTest&apos; do</span><br><span class="line">  # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line">  pod &apos;FirstViewController&apos;</span><br><span class="line">  # Pods for moduleTest</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>执行<code>pod install</code>如果没出错就代表私有库已经添加成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;本次组件化实践的方式来自于&lt;a href=&quot;https://casatwy.com/iOS-Modulization.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;casaty组件化方案&lt;/a&gt;，该方案是基于target-action模式和Mediator模式，通过Mediator利用runtime的机制来调用对应的target-action。并且在上层通过category的方式暴露对外调用的接口，这样调用者在调用的时候就知道需要传递哪些参数。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="cocoapods" scheme="http://lemon2well.top/tags/cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="http://lemon2well.top/2018/07/29/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://lemon2well.top/2018/07/29/常见算法/两数之和/</id>
    <published>2018-07-29T09:12:45.000Z</published>
    <updated>2018-07-29T09:13:15.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>给定一个数组和一个目标数，判断数组中是否有两个数的和等于该目标数，如果存在则输出它们在数组中的序号。</p><blockquote><p>解法1：第一眼看到上述题目我们第一时间的反应应该是通过两个循环遍历来找出它们的序号。第一个循环找出一个数X，然后用目标数减去该数值X得到第二个数Y，然后第二次循环找出有没有与Y相等的数值。这样时间的复杂度是O(n²)。</p></blockquote><a id="more"></a><blockquote><p>解法2：我们可以通过使用字典的的方式，数值作为字典的key，数组下标作为字典的value。我们可以在第一次便利的时候，用目标数减去循环得到的数X，然后得到目标数Y，然后判断字典中有没有以Y作为key的value。<br>如果有的话，那么此次循环的i就是第一个数值的下标，以Y作为key那个value就是第二个数值的下标。<br>如果不存在则将该次循环的下标和数值保存到字典里面。继续下一次遍历。<br>以下是Swift代码示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func _sum(_ array:[Int],targetNum:Int)-&gt;[Int]&#123;</span><br><span class="line">       var dict = [Int:Int]()</span><br><span class="line">       for(i,num) in array.enumerated()&#123;</span><br><span class="line">           let secondNum = targetNum - num</span><br><span class="line">           if let secondIndex = dict[secondNum]&#123;</span><br><span class="line">               return [i,secondIndex]</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               dict[num] = i</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return [0,0]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;两数之和&lt;/h1&gt;&lt;p&gt;给定一个数组和一个目标数，判断数组中是否有两个数的和等于该目标数，如果存在则输出它们在数组中的序号。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解法1：第一眼看到上述题目我们第一时间的反应应该是通过两个循环遍历来找出它们的序号。第一个循环找出一个数X，然后用目标数减去该数值X得到第二个数Y，然后第二次循环找出有没有与Y相等的数值。这样时间的复杂度是O(n²)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://lemon2well.top/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
