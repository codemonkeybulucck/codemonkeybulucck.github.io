<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lemon&#39;s blog</title>
  
  <subtitle>Talk is cheap show me the code</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-03T02:46:05.639Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lemon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用队列实现栈和用栈实现队列</title>
    <link href="http://yoursite.com/2018/08/03/%E7%AE%97%E6%B3%95/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2018/08/03/算法/用队列实现栈和用栈实现队列/</id>
    <published>2018-08-03T02:44:23.000Z</published>
    <updated>2018-08-03T02:46:05.639Z</updated>
    
    <content type="html"><![CDATA[<p>用两个栈来实现队列，思路和用数组实现队列一样</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//用栈实现队列</span><br><span class="line">struct QueueByStack&#123;</span><br><span class="line">    </span><br><span class="line">    var Peek: Int? &#123;</span><br><span class="line">        mutating middleCaulate()</span><br><span class="line">        return rightStack?.peek</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    typealias Element = Int</span><br><span class="line">    </span><br><span class="line">    private var leftStack:IntergerStack?</span><br><span class="line">    private var rightStack:IntergerStack?</span><br><span class="line">    </span><br><span class="line">    init() &#123;</span><br><span class="line">    leftStack = IntergerStack()</span><br><span class="line">    rightStack = IntergerStack()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var isEmpty: Bool &#123;return leftStack!.isEmpty &amp;&amp; rightStack!.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return leftStack!.Size + rightStack!.Size&#125;</span><br><span class="line">    </span><br><span class="line">    mutating func middleCaulate()&#123;</span><br><span class="line">        if leftStack!.isEmpty &#123;</span><br><span class="line">            while !rightStack!.isEmpty&#123;</span><br><span class="line">                leftStack!.push((rightStack?.pop())!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func enQueue(_ newElement: Int) &#123;</span><br><span class="line">        rightStack?.push(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func deQueue() -&gt; Int? &#123;</span><br><span class="line">        middleCaulate()</span><br><span class="line">        return leftStack?.peek</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用两个队列来实现栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct StackByQueue &#123;</span><br><span class="line">    private var queueA : IntergerQueue?</span><br><span class="line">    private var queueB : IntergerQueue?</span><br><span class="line">    init() &#123;</span><br><span class="line">        queueA = IntergerQueue()</span><br><span class="line">        queueB = IntergerQueue()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var isEmpty: Bool&#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return queueA!.isEmpty &amp;&amp; queueB!.isEmpty</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var Size: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return queueA!.Size</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var peek: Int?&#123;</span><br><span class="line">        mutating get &#123;</span><br><span class="line">            transfer()</span><br><span class="line">            let obj = queueB?.Peek</span><br><span class="line">            swap()</span><br><span class="line">            return obj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func push(_ newElement:Int)&#123;</span><br><span class="line">        queueB?.enQueue(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func pop()-&gt;Int?&#123;</span><br><span class="line">        transfer()</span><br><span class="line">        let obj = queueB?.deQueue()</span><br><span class="line">        swap()</span><br><span class="line">        return obj</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func transfer() &#123;</span><br><span class="line">        if queueB?.Size != 1&#123;</span><br><span class="line">            queueA?.enQueue((queueB?.deQueue())!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func swap()&#123;</span><br><span class="line">        (queueA,queueB) = (queueB,queueA)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用两个栈来实现队列，思路和用数组实现队列一样&lt;/p&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://yoursite.com/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>swift实现栈和队列</title>
    <link href="http://yoursite.com/2018/08/02/%E7%AE%97%E6%B3%95/swift%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2018/08/02/算法/swift实现栈和队列/</id>
    <published>2018-08-02T15:58:37.000Z</published>
    <updated>2018-08-02T16:00:14.923Z</updated>
    
    <content type="html"><![CDATA[<p>在swift中并没有内设的栈和队列，接下来我们通过数组来实现栈和队列</p><p>栈的实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protocol Stack &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    //是否为空</span><br><span class="line">    var isEmpty: Bool&#123; get &#125;</span><br><span class="line">    //栈的大小</span><br><span class="line">    var Size: Int&#123; get &#125;</span><br><span class="line">    //栈顶元素</span><br><span class="line">    var peek: Element? &#123; get &#125;</span><br><span class="line">    //入栈</span><br><span class="line">    mutating func push(_ newElement:Element)</span><br><span class="line">    //出栈</span><br><span class="line">    mutating func pop()-&gt;Element?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct IntegerStack:Stack &#123;</span><br><span class="line">    typealias Element  = Int</span><br><span class="line">    private var stack = [Element]()</span><br><span class="line">    var isEmpty: Bool &#123;return stack.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return stack.count&#125;</span><br><span class="line">    var peek: Int? &#123;return stack.last&#125;</span><br><span class="line">    mutating func push(_ newElement: Int) &#123;</span><br><span class="line">        self.stack.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    func pop() -&gt; Int? &#123;</span><br><span class="line">        return stack.last</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>队列的实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protocol Queue &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    var isEmpty: Bool &#123;get&#125;</span><br><span class="line">    var Size: Int &#123;get&#125;</span><br><span class="line">    var Peek:Element? &#123;get&#125;</span><br><span class="line">    mutating func enQueue(_ newElement:Element)</span><br><span class="line">    mutating func deQueue()-&gt;Element?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct IntergerQueue:Queue &#123;</span><br><span class="line">    typealias Element = Int</span><br><span class="line">    private var left = [Element]()</span><br><span class="line">    private var right = [Element]()</span><br><span class="line">    var isEmpty: Bool &#123;return left.isEmpty &amp;&amp; right.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return left.count + right.count&#125;</span><br><span class="line">    var Peek: Element? &#123;return left.isEmpty ? right.first : left.last&#125;</span><br><span class="line">    mutating func enQueue(_ newElement: Int) &#123;</span><br><span class="line">       right.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func deQueue() -&gt; Element? &#123;</span><br><span class="line">        if left.isEmpty &#123;</span><br><span class="line">            left = right.reversed()</span><br><span class="line">            right.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        return left.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在swift中并没有内设的栈和队列，接下来我们通过数组来实现栈和队列&lt;/p&gt;
&lt;p&gt;栈的实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protocol Stack &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    associatedtype Element&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //是否为空&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var isEmpty: Bool&amp;#123; get &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //栈的大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var Size: Int&amp;#123; get &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //栈顶元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var peek: Element? &amp;#123; get &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //入栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mutating func push(_ newElement:Element)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //出栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mutating func pop()-&amp;gt;Element?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct IntegerStack:Stack &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    typealias Element  = Int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private var stack = [Element]()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var isEmpty: Bool &amp;#123;return stack.isEmpty&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var Size: Int &amp;#123;return stack.count&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var peek: Int? &amp;#123;return stack.last&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mutating func push(_ newElement: Int) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.stack.append(newElement)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func pop() -&amp;gt; Int? &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return stack.last&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://yoursite.com/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>网络层设计方案以及去Model化实践</title>
    <link href="http://yoursite.com/2018/08/02/iOS%20%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E4%BB%A5%E5%8F%8A%E5%8E%BBModel%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/08/02/iOS 开发/网络层设计方案以及去Model化实践/</id>
    <published>2018-08-02T09:30:30.000Z</published>
    <updated>2018-08-02T09:32:52.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然在网上看到<a href="https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="noopener">casa的网络层设计方案</a>，在以前的iOS开发中，用的最多的就是集约型的网络请求+去Model的形式，然而在看完这篇文章之后我觉得好像发现了新大陆，原来还可以这么玩。</p><a id="more"></a><blockquote><ol><li>此网络层设计方案最大的好处就是解耦，每个API都有特定的APIManager管理，可以方便的缓存数据以及取消网络请求。</li><li>在集约型网络基础上封装了散约型的API，参数以及请求以及处理请求数据全部封装到该APIManager方法里面。</li><li>通过Delegate的方法回调，更好的方便调试以及释放对象。如果以block来调用的话首先不方便调试，其次会延长对象的生命周期，对象需要必须等到网络请求回来之后才能释放。</li><li>提供一个BaseAPIManager，然后通过IOP的方式约束子类必须要遵循APIRequestProtocol，通过实现该协议的方式来提供给API参数，这样父类就不用提供空载函数。 该父类还提供一个代理，该代理用于返回数据。</li><li>最后是去Model化的设计，APIRequestProtocol 提供了一个<code>-(id)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer;</code>协议方法，在该方法里面可以会传入一个遵守ReformProtocol协议的reformer，到时reformer就可以自定义处理数据的方法，返回特定的数据</li><li>ReformProtocol有一个<code>- (id)reformDataWith:(LMBaseAPIManager*)apiManager;</code>的协议方法，里面可以根据apiManager做判断，然后返回不同的数据，也就是说，一个reformer可以对应多个apiManager。</li></ol></blockquote><p>具体的原理和好处在case的文章里面已经说得很清楚了</p><h2 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h2><p><img src="http://pcd17v2u0.bkt.clouddn.com/15331959524160.jpg" alt=""></p><ul><li>LMNetwork是具体的网络出口类，里面提供了集约化的网络请求方法，通过block返回数据。</li><li><p>LMBaseAPIManager是网络请求基类，里面有一个遵循了APIRequestProtocol协议的request，这个协议提供了网络请求参数的的方法和处理网络请求结果的方法。发送网络请求的时候会通过这个request获取必要的参数，以及返回数据的时候通过这个类处理数据。</p><p>该类还提供了一个遵循了APIResponseProtocol的代理对象，当网络返回数据的时候会调用该协议方法，该协议方法返回一个遵循APIRequestProtocol的request，调用方需要调用<code>fetchDataWithReformer:</code>方法，并且传入一个reformer，然后在该方法的实现里面就可以将apiManager传给reformer，reformer可以根据不同apiManager做不同的数据返回了。</p><p>LMBaseAPIManager还提供了两个属性，一个responseData和error，网络请求结果和错误都会放到这里面，到时将apiManager传到reformer的时候，通过这两个属性可以取出数据。</p><p>LMBaseAPIManager还可以提供一个isCache的方法，可以自己设置缓存策略。</p><p>总的来说，LMBaseAPIManager需要派生一个子类，然后子类需要实现apiRequestProtocol方法，提供网络必要的参数。调用<code>startRequest</code>方法之后调用LMNetwork发送网络请求。当网络请求回来之后，通过代理回调结果，并且将apiManager返回，调用方收到回调时候，传入reformer对数据进行处理。</p></li></ul><ul><li><p>LMReformerProtocol是一个协议，里面有一个协议方法<code>- (id)reformDataWith:(LMBaseAPIManager*)apiManager;</code>该方法用来处理返回数据。</p></li><li><p>LMProductionAPIManager是LMBaseAPIManagerd的派生类，里面提供了apiRequestProtocol协议方法的实现。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以上已经将框架介绍清楚了，下面是代码实现：</p><ol><li>首先初始化productionAPIManager并且设计代理。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (LMProductionAPIManager *)productionAPIManager&#123;</span><br><span class="line">    if(!_productionAPIManager)&#123;</span><br><span class="line">        _productionAPIManager = [[LMProductionAPIManager alloc]init];</span><br><span class="line">        _productionAPIManager.response = self;</span><br><span class="line">    &#125;</span><br><span class="line">    return _productionAPIManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于LMProductionAPIManager是LMBaseAPIManagerd的子类，因此会调用父类的init方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        if ([self conformsToProtocol:@protocol(APIRequestProtocol)]) &#123;</span><br><span class="line">            self.request = (id&lt;APIRequestProtocol&gt;)self;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSAssert(NO, @&quot;子类必须要遵循APIRequestProtocol协议&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于子类遵循了 <code>@interface LMProductionAPIManager: LMBaseAPIManager&lt;APIRequestProtocol&gt;</code> APIRequestProtocol协议，因为该类内部有一个request的属性指向该对象。而该对象是遵循了上述的协议，所以要实现上述协议里面的方法，接下来看看LMProductionAPIManager里面的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@implementation LMProductionAPIManager</span><br><span class="line">- (NSString *)apiRequestName&#123;</span><br><span class="line">    return  @&quot;http://120.197.235.101:8080/apk/iosPagingQuery?pageNo=1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSString *)apiRequestMethod&#123;</span><br><span class="line">    return GET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)apiRequestParameters&#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer&#123;</span><br><span class="line">    if (reformer == nil) &#123;</span><br><span class="line">        return self.responseData;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [reformer reformDataWith:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该对象内部提供了url以及get方法和参数，还提供处理返回数据的实现。</p><ol start="2"><li><p>接下来调用 <code>[self.productionAPIManager startRequest];</code>方法，看看该方法内部会做什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   - (void)startRequest&#123;</span><br><span class="line">    [[LMNetwork sharedInstance]requestMethod:[self.request apiRequestMethod] url:[self.request apiRequestName] parameters:[self.request apiRequestParameters] finishBlock:^(id data, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            self.responseError = error;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">         self.responseData = data;</span><br><span class="line">         &#125;</span><br><span class="line">        if ([self.response respondsToSelector:@selector(apiResponseSuccess:)]) &#123;</span><br><span class="line">            [self.response apiResponseSuccess:self.request];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>该方法会发送网络请求并且将请求后的数据复制给当前对象的相关属性，然后通过代理回到结果，并且将当前请求对象返回。</p><ol start="3"><li><p>调用方收到代理之后进行处理 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)apiResponseSuccess:(id&lt;APIRequestProtocol&gt;)request&#123;</span><br><span class="line">    [MBProgressHUD hideHUD];</span><br><span class="line">    self.productionArr =  [request fetchDataWithReformer:[LMProductReformer new]];</span><br><span class="line">    [self.tableView reloadData];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>收到回调之后首先对初始化一个LMProductionReform对象，该对象遵循了LMReformerProtocol协议，待会再来看里面的实现。</p><p>然后调用request的协议方法 <code>fetchDataWithReformer</code>该方法的实现在第一点已经提到了，该方法内部会看一下有没有传reformer进来，如果没有的话直接返回未经处理的对象，如果有的话那就调用reformer的LMReformerProtocol协议方法。</p><p>接下来来看<code>LMReformerProtocol</code>方法的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   - (id)reformDataWith:(LMBaseAPIManager *)apiManager&#123;</span><br><span class="line">    //这里根据不同的APIManager返回相应的数据</span><br><span class="line">    if ([apiManager isKindOfClass: [LMProductionAPIManager class]]) &#123;</span><br><span class="line">        NSDictionary *dict = apiManager.responseData;</span><br><span class="line">        NSArray *list = dict[@&quot;list&quot;];</span><br><span class="line">        NSMutableArray *mArr = [NSMutableArray arrayWithCapacity:list.count];</span><br><span class="line">        for (NSDictionary *dict in list) &#123;</span><br><span class="line">            NSDictionary *infoDict = @&#123;kLMProductionVer:dict[@&quot;ver&quot;],kLMProductionVerDesc:dict[@&quot;verDesc&quot;]&#125;;</span><br><span class="line">            [mArr addObject:infoDict];</span><br><span class="line">        &#125;</span><br><span class="line">        return mArr;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return  nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>reform在这里根据不同的APIManager进行不同的解析，返回不同的数据。</p><p>到这里，整个网络和去model的设计就完成了。每个API都应该对应一个APIManager，但是可以使用同一个reformer，然后reformer对apimanager做判断从而返回不同的数据。</p><p>值得注意的是：由于我们用字典的形式来存储数据，所以肯定会有hardcode，我们可以定义一个头文件了里面包含所有我们用到的字符串常量，然后在reformer的实现文件里面给这些常量赋值。<br>如在<code>LMProductReformKeys.h</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern NSString *const kLMProductionVer;</span><br><span class="line">extern NSString *const kLMProductionVerDesc;</span><br></pre></td></tr></table></figure><p>在<code>LMProductReformer.m</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString * const kLMProductionVer = @&quot;productionVer&quot;;</span><br><span class="line">NSString * const kLMProductionVerDesc = @&quot;productionVerDesc&quot;;</span><br></pre></td></tr></table></figure><p>这样只要引入LMProductReformer.h都可以使用该常量。</p><p>完整的<a href="https://github.com/codemonkeybulucck/NoModelExample.git" target="_blank" rel="noopener">demo</a></p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;偶然在网上看到&lt;a href=&quot;https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;casa的网络层设计方案&lt;/a&gt;，在以前的iOS开发中，用的最多的就是集约型的网络请求+去Model的形式，然而在看完这篇文章之后我觉得好像发现了新大陆，原来还可以这么玩。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://yoursite.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="去model" scheme="http://yoursite.com/tags/%E5%8E%BBmodel/"/>
    
  </entry>
  
  <entry>
    <title>快行指针</title>
    <link href="http://yoursite.com/2018/08/01/%E7%AE%97%E6%B3%95/%E5%BF%AB%E8%A1%8C%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2018/08/01/算法/快行指针/</id>
    <published>2018-08-01T15:11:07.000Z</published>
    <updated>2018-08-01T15:12:02.824Z</updated>
    
    <content type="html"><![CDATA[<p>快行指针的定义就是有两个指针访问链表，但是一个指针的速度比另外一个快，或者说一个指针在前，一个在后。</p><p>根据这个特性我们可以用来检测一个链表中是否有环。</p><blockquote><p>假设：一个指针的速度是另外一个指针的两倍，它们同时开始访问同一个链表，如果链表有环的情况下，那么快行指针总会追上慢行指针，也就是总有一个时刻快行指针和慢行指针指向同一个节点，当慢行指针跑一圈的时候，快行指针此时刚好跑了两圈。<br><a id="more"></a><br>以下是具体算法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:Equatable &#123;</span><br><span class="line">//遵守Equatable协议</span><br><span class="line">    static func == (lhs: ListNode, rhs: ListNode) -&gt; Bool &#123;</span><br><span class="line">        if lhs.val == rhs.val &amp;&amp; lhs.next == rhs.next&#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      public var val: Int</span><br><span class="line">      public var next: ListNode?</span><br><span class="line">      public init(_ val: Int) &#123;</span><br><span class="line">          self.val = val</span><br><span class="line">          self.next = nil</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class quickSolution &#123;</span><br><span class="line">    func checkCycle(_ l1:ListNode?)-&gt;Bool&#123;</span><br><span class="line">        guard let l1 = l1 else&#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        var slowNode:ListNode? = l1,fastNode:ListNode? = l1</span><br><span class="line">        while fastNode != nil &amp;&amp; fastNode?.next != nil &#123;</span><br><span class="line">            slowNode = slowNode?.next</span><br><span class="line">            fastNode = fastNode?.next!.next</span><br><span class="line">            if slowNode == fastNode &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们依然可以用这个方法来解决另外一个问题。<br>删除链表中的第n个节点，例如：1-&gt;3-&gt;6-&gt;5-&gt;2 ，这里要删除倒数第2个节点。那么删除后的链表为： 1-&gt;3-&gt;6-&gt;2。</p><blockquote><p>思路：<br>假设快行指针从一开始就比慢行指针快n个节点，然后他们以相同的速度前进，当快行指针走到链表的最后一个节点的时候，慢行指针的当前节点的下一个节点就是我们要删除的节点。</p></blockquote><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class DeleteSolution &#123;</span><br><span class="line">    func deleteNode(_ l1:ListNode?,n:Int)-&gt;ListNode?&#123;</span><br><span class="line">        guard let l1 = l1 else&#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        let dummy = ListNode(0)</span><br><span class="line">        dummy.next = l1</span><br><span class="line">        var slowNode:ListNode? = dummy</span><br><span class="line">        var fastNode:ListNode? = dummy</span><br><span class="line">        //设置快行指针比慢行指针快n个节点</span><br><span class="line">        for _ in 0 ..&lt; n &#123;</span><br><span class="line">            if fastNode == nil &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            fastNode = fastNode?.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //同时移动两个指针</span><br><span class="line">        while fastNode != nil &amp;&amp; fastNode?.next != nil &#123;</span><br><span class="line">            slowNode = slowNode?.next</span><br><span class="line">            fastNode = fastNode?.next</span><br><span class="line">        &#125;</span><br><span class="line">        //删除需要删除的节点</span><br><span class="line">        slowNode?.next = slowNode?.next?.next</span><br><span class="line">        return dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快行指针的定义就是有两个指针访问链表，但是一个指针的速度比另外一个快，或者说一个指针在前，一个在后。&lt;/p&gt;
&lt;p&gt;根据这个特性我们可以用来检测一个链表中是否有环。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设：一个指针的速度是另外一个指针的两倍，它们同时开始访问同一个链表，如果链表有环的情况下，那么快行指针总会追上慢行指针，也就是总有一个时刻快行指针和慢行指针指向同一个节点，当慢行指针跑一圈的时候，快行指针此时刚好跑了两圈。&lt;br&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://yoursite.com/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>dummy节点和尾巴插法</title>
    <link href="http://yoursite.com/2018/07/31/%E7%AE%97%E6%B3%95/dummy%E8%8A%82%E7%82%B9%E5%92%8C%E5%B0%BE%E5%B7%B4%E6%8F%92%E6%B3%95/"/>
    <id>http://yoursite.com/2018/07/31/算法/dummy节点和尾巴插法/</id>
    <published>2018-07-31T15:35:01.000Z</published>
    <updated>2018-07-31T15:36:54.856Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个链表和一个数X，要求将链表中所有小于X的值放到左边，等于或者大于X的值放到右边，并且原链表的节点顺序不变。</p><p>示例：<br>假设： 1-&gt;7-&gt;3-&gt;5-&gt;2-&gt;8-&gt;4，给定x=4<br>那么变换后的节点为： 1-&gt;3-&gt;2-&gt;7-&gt;5-&gt;8-&gt;4</p><a id="more"></a><blockquote><p>思路：<br>我们先把题目简单化，我们可以先找出链表中小于X的节点放到一个新的链表里面<br>然后再找出等于或者大于X的节点放到另外一个条链表<br>最后将第一条链表的next指向第二条链表的头结点，这样就完成了题目的要求。</p></blockquote><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">      public var val: Int</span><br><span class="line">      public var next: ListNode?</span><br><span class="line">      public init(_ val: Int) &#123;</span><br><span class="line">          self.val = val</span><br><span class="line">          self.next = nil</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class NewSoluction &#123;</span><br><span class="line">    func getNewList(_ l1:ListNode?,x:Int)-&gt;ListNode?&#123;</span><br><span class="line">        let headDummy = ListNode(0), tailDummy = ListNode(0)</span><br><span class="line">        var head = headDummy,tail = tailDummy</span><br><span class="line">        var node = l1</span><br><span class="line">        while node != nil &#123;</span><br><span class="line">            if node!.val &lt; x &#123;</span><br><span class="line">                head.next = node!</span><br><span class="line">                head = node!</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                tail.next = node!</span><br><span class="line">                tail = node!;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node!.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = nil;</span><br><span class="line">        //头链加上尾链</span><br><span class="line">        head.next = tailDummy.next</span><br><span class="line">        return headDummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：tail.next = nil 是为了防止形成环，因为<code>tail.next = node ! ,tail = node</code>这一句实际上是形成了环，所以需要将tail.next置空来打破环</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个链表和一个数X，要求将链表中所有小于X的值放到左边，等于或者大于X的值放到右边，并且原链表的节点顺序不变。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;假设： 1-&amp;gt;7-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;8-&amp;gt;4，给定x=4&lt;br&gt;那么变换后的节点为： 1-&amp;gt;3-&amp;gt;2-&amp;gt;7-&amp;gt;5-&amp;gt;8-&amp;gt;4&lt;/p&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://yoursite.com/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表结构" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>iOS 组件化实践《二》基于现有项目拆分组件化实践</title>
    <link href="http://yoursite.com/2018/07/31/iOS%20%E5%BC%80%E5%8F%91/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%BA%8C%E3%80%8B-%E5%9F%BA%E4%BA%8E%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/07/31/iOS 开发/组件化实践《二》-基于现有项目拆分组件化实践/</id>
    <published>2018-07-31T08:41:12.000Z</published>
    <updated>2018-07-31T08:45:00.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><blockquote><p>在<a href="http://lemon2well.top/2018/07/30/iOS%20开发/组件化实践《一》创建私有pod/" target="_blank" rel="noopener">第一篇</a>介绍中已经介绍了如果发布一个私有pod，下面将会介绍如何基于一个现有的项目拆分成组件化形式的项目。<br>假设我们现有的项目是有一个AViewController,还有一个BViewController，目前的功能是点击rootViewController页面的按钮会push到AviewController，然后点击AviewController的一个按钮会跳转到BViewController。这里是未拆分的<a href="https://github.com/codemonkeybulucck/TestModule" target="_blank" rel="noopener">demo</a></p></blockquote><a id="more"></a><h2 id="0x02-拆分组件"><a href="#0x02-拆分组件" class="headerlink" title="0x02 拆分组件"></a>0x02 拆分组件</h2><blockquote><p>现在我们要拆分AViewController和BViewController,将他们拆分成两个组件，并且按照Target-Action的形式提供对外的接口，通过中间件去调用Target对应的Action，在最上层是中间件的分类，给调用方提供具体且便利的方法和接口。</p></blockquote><h3 id="0x02-1-分析如何拆分AViewController"><a href="#0x02-1-分析如何拆分AViewController" class="headerlink" title="0x02.1 分析如何拆分AViewController"></a>0x02.1 分析如何拆分AViewController</h3><ol><li><p>首先AViewController，现在AViewController需要外部传一个NSString类型的参数进去，然后返回一个AViewController的对象。这个时候应该创建一个Target_AViewController的类，然后对外一个<code>Action_fectchAViewController:</code>的方法，这个方法需要接收一个字典类型的参数，到时我们会从这个字典中取出key为navTitle的值来作为AViewController的参数。以下是该方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   - (UIViewController*)Action_fetchAViewController:(NSDictionary*)params&#123;</span><br><span class="line">    AViewController *aViewControlelr = [[AViewController alloc]init];</span><br><span class="line">    NSString *title = params[@&quot;navTitle&quot;];</span><br><span class="line">    aViewControlelr.navTitle = title;</span><br><span class="line">    return aViewControlelr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>然后我们要创建CTMediator的分类<code>CTMediator+ModuleAActions</code>，这个分类方法对外提供了一个<code>fetchAViewController</code>的方法，到时调用方调用此方法即可获取到一个AViewController的实例，而不用自己去初始化AViewController。</p></li><li><p>那么上面那个分类具体做了什么操作呢，该方法会传一个“AViewController”和“fetchAViewController”来表明需要调用Target_AViewController的Action_fetchAViewller方法，也就是我们刚刚提供的Target_Action。本来调用方是不用通过类别来调用组件Target_Action的，因为可以通过CTMediator的<code>perform Target: action: params:</code>来直接调用。但是那样非常不友好以及不统一。<br>加上了该分类之后，可以做更多的容错处理以及有一个容易的入口。</p></li><li><p>所以在后面做成pod的时候，category是一个pod，它只依赖于CTMediator，调用方法是通过CTMediator通过runtime来找到Target_Action来调用。所以另外一个pod就是AViewController+Target_AViewController。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   - (UIViewController*)fetchAViewController&#123;</span><br><span class="line">    UIViewController *vc = [self performTarget:@&quot;AViewController&quot; action:@&quot;fetchAViewController&quot; params:@&#123;@&quot;navTitle&quot;:@&quot;This is A ViewController&quot;&#125; shouldCacheTarget:NO];</span><br><span class="line">    if ([vc isKindOfClass:[UIViewController class]]) &#123;</span><br><span class="line">        return vc;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [[UIViewController alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>以上提到的pod：</strong><br><a href="https://github.com/codemonkeybulucck/AViewControllerCategory" target="_blank" rel="noopener">CategoryAViewController</a><br><a href="https://github.com/codemonkeybulucck/LMAViewController" target="_blank" rel="noopener">AviewControllerPod</a><br><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="noopener">CTMediactor</a></p><h3 id="0x02-2-创建BViewController的category和Target-Action的pod"><a href="#0x02-2-创建BViewController的category和Target-Action的pod" class="headerlink" title="0x02.2 创建BViewController的category和Target_Action的pod"></a>0x02.2 创建BViewController的category和Target_Action的pod</h3><p>1、为什么需要先创建BViewController组件，因为AViewController会依赖于BViewController，所以我们先创建BViewController组件。</p><p>2、首先我们先创建BViewController私有pod，按照我的<a href="http://lemon2well.top/2018/07/30/iOS%20开发/组件化实践《一》创建私有pod/" target="_blank" rel="noopener">组件化实践《一》</a>创建好<a href="https://github.com/codemonkeybulucck/BViewController" target="_blank" rel="noopener">BViewController</a>的pod，这个pod不用依赖于任何其他组件，所以应该没啥困难。</p><p>3、接下来我们需要创建<a href="https://github.com/codemonkeybulucck/BCategory" target="_blank" rel="noopener">BViewControllerCategory</a>，这里有一点要注意的是在podspec文件的最下面需要加入<code>s.dependency &#39;CTMediator&#39;</code>，因为里面需要用到CTMediator的perform方法去调用到对应的组件。因为CTMediator已经发布到cocoapods所以可以直接用，如果这里的依赖是你自己改动之后的私有Mediator，记得在pod spec lint 的时候要加上<code>--sources=yourgithub/spec,master</code>将源改成你自己的私有索引库的地址，不然默认是从公有索引库里面找不到对应的Mediator。待会在AViewController调用B的时候会用到这个命令。</p><h3 id="0x02-3-创建AViewController的category和Target-Action的pod"><a href="#0x02-3-创建AViewController的category和Target-Action的pod" class="headerlink" title="0x02.3 创建AViewController的category和Target_Action的pod"></a>0x02.3 创建AViewController的category和Target_Action的pod</h3><p>1、方法同上，首先创建AViewController的<a href="https://github.com/codemonkeybulucck/AViewControllerCategory" target="_blank" rel="noopener">Category</a>组件，这里只需要注意在podspec文件的最下面需要加入<code>s.dependency &#39;CTMediator&#39;</code>。<br>2、 然后我们创建<a href="https://github.com/codemonkeybulucck/LMAViewController" target="_blank" rel="noopener">AViewController</a>私有pod，由于在AViewController里面我们有个按钮点击之后会push到BViewController，那必然要引入BViewController，但是在组件中不会直接引入BViewController，我们通过引入BViewControllerCategory来让程序编译的时候不要报错就行。podspec文件要加入<code>s.dependency &#39;BCategory&#39;</code>。</p><p>3、 验证，因为第二部中我们的私有工程依赖了另外一个私有工程，这个时候的<code>pod spec lint</code>和 <code>pod repo push</code>命令都要加上 <code>--source</code>说明</p><p><strong>注意：组件间的调用依然是利用Target对应的分类来调用。记住分类是统一的入口，组件里面的代码不会依赖于另外一个组件，而是依赖于对应的分类组件或者CTMediator，然后所有依赖的pod都要写到主工程的podfile里面</strong></p><h2 id="0x03-引用组件"><a href="#0x03-引用组件" class="headerlink" title="0x03 引用组件"></a>0x03 引用组件</h2><p>我们将AViewController和BViewController拆分后，我们创建一个demo来测试一下刚刚拆分的组件。创建一个OC项目，在项目的跟目录下执行<code>pod init</code>，然后在podfile文件里面写入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/codemonkeybulucck/LMSpec&apos;</span><br><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"></span><br><span class="line">target &apos;moduleTest&apos; do</span><br><span class="line">  # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line">  pod &apos;ACategory&apos;</span><br><span class="line">  pod &apos;AViewController&apos;,&apos;~&gt;0.1.1&apos;</span><br><span class="line">  pod &apos;BViewController&apos;</span><br><span class="line">  # Pods for moduleTest</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>完成后执行 <code>pod install</code>，成功之后再<code>#import &quot;CTMediator+ModuleAActions.h&quot;</code> 然后调用方式就变成了<br><code>UIViewController *vc = [[CTMediator sharedInstance] fetchAViewController];</code></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>组件化最核心的思想就是解耦，将庞大的项目抽丝剥茧，分离成互相独立的一个一个模块，每个模块都是可复用的。上述的方案其实已经做到了解耦，调用者只需要用到中间件的分类的方法接口而不需要引入实际的组件的类。<br>但是在分类里面有一个弊端就是：动态调用方法的时候需要硬编码也就是，这样容错率就很低，不过幸好这个东西是在分类中，在开发的过程中就可以发现的问题。<br>另外一个方面也不是所有的项目都适合用组件化，只有当项目规模扩大到一定的程度，并且人员众多的情况下用组件化的便捷性才体现出来。所以很多时候我们讨论架构或者讨论一种新的技术，并不是它就是最好的，没有什么东西是最好的，只有最合适的，因地制宜。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://lemon2well.top/2018/07/30/iOS%20开发/组件化实践《一》创建私有pod/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第一篇&lt;/a&gt;介绍中已经介绍了如果发布一个私有pod，下面将会介绍如何基于一个现有的项目拆分成组件化形式的项目。&lt;br&gt;假设我们现有的项目是有一个AViewController,还有一个BViewController，目前的功能是点击rootViewController页面的按钮会push到AviewController，然后点击AviewController的一个按钮会跳转到BViewController。这里是未拆分的&lt;a href=&quot;https://github.com/codemonkeybulucck/TestModule&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://yoursite.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="cocoapods" scheme="http://yoursite.com/tags/cocoapods/"/>
    
      <category term="组件化" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://yoursite.com/2018/07/31/%E7%AE%97%E6%B3%95/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/07/31/算法/无重复字符的最长子串/</id>
    <published>2018-07-31T02:30:35.000Z</published>
    <updated>2018-07-31T02:31:33.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><p>示例：</p><p>给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。</p><p>给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。</p><p>给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列  而不是子串。</p><a id="more"></a><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">leetcode链接</a></p><blockquote><p>解答思路：</p><ol><li>首先从头开始遍历字符串，并且将已经遍历过的字符串放到一个数组里面</li><li>但是放到数组里面的前提是当前遍历的字符并不存在在数组当中，也就是如果当前遍历的字符不在数组中，那么就将字符放到数组中，开始下一次遍历</li><li>如果当前当前的字符在数组中，那么找到该字符在数组中的下标，删除数组中从下标为0到该字符下标区间的元素，然后将当前字符放到数组里面开始下一次遍历。</li><li>每遍历一次，都要判断上一次的最长字符串maxCount是否小于当前数组的元素的数量，如果是，那么就更新maxCount。</li></ol></blockquote><p>下面是代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func _maxLongString(s:String!)-&gt;Int&#123;</span><br><span class="line">        if s.count == 0 &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">        var subArr = [CChar]()</span><br><span class="line">        var maxCount = 0;</span><br><span class="line">        var array = s.cString(using:.utf8)!</span><br><span class="line">        array.removeLast() //由于字符串会有一个结束符，所以需要删掉最后的结束符</span><br><span class="line">        for str in array&#123;</span><br><span class="line">            if subArr.contains(str) &#123;</span><br><span class="line">                let index:Int = subArr.index(of: str)!</span><br><span class="line">                let empty = 0..&lt;index+1</span><br><span class="line">                subArr.removeSubrange(empty)</span><br><span class="line">            &#125;</span><br><span class="line">            subArr.append(str)</span><br><span class="line">            maxCount = max(maxCount, subArr.count)</span><br><span class="line">        &#125;</span><br><span class="line">        return maxCount</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串&quot;&gt;&lt;/a&gt;无重复字符的最长子串&lt;/h1&gt;&lt;p&gt;给定一个字符串，找出不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。&lt;/p&gt;
&lt;p&gt;给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。&lt;/p&gt;
&lt;p&gt;给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列  而不是子串。&lt;/p&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://yoursite.com/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>非空链表相加</title>
    <link href="http://yoursite.com/2018/07/30/%E7%AE%97%E6%B3%95/%E9%9D%9E%E7%A9%BA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2018/07/30/算法/非空链表相加/</id>
    <published>2018-07-30T09:12:45.000Z</published>
    <updated>2018-07-30T09:33:42.698Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p><blockquote><p>思路：</p><ol><li>只要两个非空链表中的其中一个链表不为空的时候就循环便利两个链表</li><li>如果其中一个链表为空而另外一个链表不为空，那么为空的那个链表的值就为0</li><li>用一个carry位来表示是否有进位，0代表无进位，1代表有进位，因为链表中都是个位数，所以最大进位也只能为1，初始化进位为0</li><li>用x,y来表示当前两个链表的值，sum = x+y+carry为新链表的值，但是有可能有进位，所以新的carry = sum / 10,当前节点位的值为sum = sum %10。<a id="more"></a></li><li>创建一个新节点，将上述中sum的值赋给新节点，然后将新链表当前节点的next指向新节点，然后将当前节点指向到新节点</li><li>两个链表的当前节点都要指向下一个节点</li><li>当遍历完成之后，还需要判断一下carry的值是不是大于0，如果大于0则代表还需要创建一个节点，并且将新链表的节点的next指向该节点</li></ol></blockquote><p>以下是代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">      public var val: Int</span><br><span class="line">      public var next: ListNode?</span><br><span class="line">      public init(_ val: Int) &#123;</span><br><span class="line">          self.val = val</span><br><span class="line">          self.next = nil</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;</span><br><span class="line">        let resultNode = ListNode(0)</span><br><span class="line">        var currentNode = resultNode</span><br><span class="line">        var p = l1</span><br><span class="line">        var q = l2</span><br><span class="line">        var carry = 0 //表示进位</span><br><span class="line">        while p != nil || q != nil &#123;</span><br><span class="line">            //获取当前的值</span><br><span class="line">            var x = 0,y = 0;</span><br><span class="line">            if let p = p &#123;</span><br><span class="line">                x = p.val</span><br><span class="line">            &#125;</span><br><span class="line">            if let q = q &#123;</span><br><span class="line">                y = q.val</span><br><span class="line">            &#125;</span><br><span class="line">            let sum = x + y + carry</span><br><span class="line">            carry = sum / 10</span><br><span class="line">            let newSum = sum % 10;</span><br><span class="line">            currentNode.next = ListNode(newSum)</span><br><span class="line">            currentNode = currentNode.next!</span><br><span class="line">            p = p?.next</span><br><span class="line">            q = q?.next</span><br><span class="line">        &#125;</span><br><span class="line">        if carry &gt; 0 &#123;</span><br><span class="line">            currentNode.next = ListNode(carry)</span><br><span class="line">        &#125;</span><br><span class="line">        return resultNode.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只要两个非空链表中的其中一个链表不为空的时候就循环便利两个链表&lt;/li&gt;
&lt;li&gt;如果其中一个链表为空而另外一个链表不为空，那么为空的那个链表的值就为0&lt;/li&gt;
&lt;li&gt;用一个carry位来表示是否有进位，0代表无进位，1代表有进位，因为链表中都是个位数，所以最大进位也只能为1，初始化进位为0&lt;/li&gt;
&lt;li&gt;用x,y来表示当前两个链表的值，sum = x+y+carry为新链表的值，但是有可能有进位，所以新的carry = sum / 10,当前节点位的值为sum = sum %10。
    
    </summary>
    
      <category term="常见算法" scheme="http://yoursite.com/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS 组件化实践《一》创建私有pod</title>
    <link href="http://yoursite.com/2018/07/30/iOS%20%E5%BC%80%E5%8F%91/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%B8%80%E3%80%8B%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89pod/"/>
    <id>http://yoursite.com/2018/07/30/iOS 开发/组件化实践《一》创建私有pod/</id>
    <published>2018-07-30T03:41:12.000Z</published>
    <updated>2018-07-30T08:09:31.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>本次组件化实践的方式来自于<a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">casaty组件化方案</a>，该方案是基于target-action模式和Mediator模式，通过Mediator利用runtime的机制来调用对应的target-action。并且在上层通过category的方式暴露对外调用的接口，这样调用者在调用的时候就知道需要传递哪些参数。</p><a id="more"></a><p>具体的调用方式就是：<br><img src="http://pcd17v2u0.bkt.clouddn.com/WX20180730-160336@2x.png" alt="WX20180730-160336@2x"></p><blockquote><p>实际上是可以不使用category的形式而是直接调用CTMediactor的<code>- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget</code> 方法直接调用对应target的action，但是那样对于调用方来说极其不友好，最直观的感受就是不知道params应该传哪些参数。</p></blockquote><blockquote><p>利用catogory的方式暴露方法的好处在于<br>1、一个组件对应一个category，每个category提供了组件所有的调用方法，调用方直接调用，可以直观的看到需要传递哪些参数。<br>2、提供统一的调用入口，所有的组件的被调用都是通过category<br>3、可以做异常处理，将参数的校验提前，并且可以做请求转发。</p></blockquote><h2 id="0x02-组件化实践"><a href="#0x02-组件化实践" class="headerlink" title="0x02 组件化实践"></a>0x02 组件化实践</h2><p>在简单的介绍了组件化的实际逻辑之后下面开始真正的开始动手实现组件化实践流程。</p><blockquote><p>一个私有pod的创建具体分为以下几步：</p></blockquote><ol><li>创建工程</li><li>创建私有库，修改podSpec文件，将本地代码库和远程代码库关联起来，上传代码到远程仓库。</li><li>创建远程索引库和本地索引库，也就是用于放置podspec的地方，每个podspec文件可以索引到我们远程不同的代码私有库</li><li>本地测试podspec文件是否可用</li><li>向索引库Spec Repo中提交podspec</li><li>测试Spec Repo中的的 podspec 是否可用</li></ol><p>1、 首先到github里面创建一个空的工程，例如我要创建一个FirstViewController<br><img src="http://pcd17v2u0.bkt.clouddn.com/15329320727207.jpg" alt=""></p><hr><p>2、 创建私有库，终端运行<code>pod lib create FirstViewController</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:Module lemon$ pod lib create FirstViewController</span><br><span class="line">Cloning `https://github.com/CocoaPods/pod-template.git` into `FirstViewController`.</span><br><span class="line">Configuring FirstViewController template.</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">To get you started we need to ask a few questions, this should only take a minute.</span><br><span class="line"></span><br><span class="line">If this is your first time we recommend running through with the guide:</span><br><span class="line"> - https://guides.cocoapods.org/making/using-pod-lib-create.html</span><br><span class="line"> ( hold cmd and click links to open in a browser. )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line"> &gt; iOS //pod平台</span><br><span class="line"></span><br><span class="line">What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line"> &gt; ObjC //pod语言</span><br><span class="line"></span><br><span class="line">Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class="line"> &gt; No //是否需要提供demo</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line"> &gt; None //测试框架</span><br><span class="line"></span><br><span class="line">Would you like to do view based testing? [ Yes / No ]</span><br><span class="line"> &gt; No //是否需要测试视图</span><br><span class="line"></span><br><span class="line">What is your class prefix?</span><br><span class="line"> &gt; LM //demo类前缀</span><br><span class="line"></span><br><span class="line">Running pod install on your new library.</span><br><span class="line"></span><br><span class="line">Analyzing dependencies</span><br><span class="line">Fetching podspec for `FirstViewController` from `../`</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing FirstViewController (0.1.0)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br></pre></td></tr></table></figure><p>上述命令执行完成之后会本地帮我们生成一个pod的模板文件，我们在这里首先需要改动的就是FirstViewController.podspec文件，用xcode打开该文件。<br>目前我们需要注意下面几处地方：</p><ul><li><code>s.version          = &#39;1.0.0&#39;</code>    //pod的版本，后面将podSpec文件提交到私有repo的时候会验证远程的仓库中是否已经存在对应的tag，所以这个要与后面提交代码的时候的tag相同,我们先修改为1.0.0，可以按照你们自己的标准修改。</li><li><code>s.homepage         = &#39;https://github.com/codemonkeybulucck/FirstViewController&#39;</code>  //homepage这里填写在第一步中再github创建的远程仓库的地址即可。</li><li><p><code>s.source           = { :git =&gt; &#39;https://github.com/codemonkeybulucck/FirstViewController.git&#39;, :tag =&gt; s.version.to_s }</code>  //这里填写远程仓库的地址，记得后面要加上.git的后缀</p></li><li><p><code>s.ios.deployment_target = &#39;8.0&#39;</code> //该pod的最低运行环境</p></li><li><p><code>s.source_files = &#39;FirstViewController/Classes/**/*&#39;</code> //pod中源代码的路径，后面会将实际的代码放在Classes文件夹下面</p></li></ul><p>一些其他设置的说明：</p><p>  s.summary          = ‘A short description of FirstViewController.’  //pod的简述<br>  s.description      = &lt;&lt;-DESC //具体描述<br> s.license          = { :type =&gt; ‘MIT’, :file =&gt; ‘LICENSE’ } //许可证<br>  s.author           = { <a href="mailto:&#39;545390087@qq.com" target="_blank" rel="noopener">&#39;545390087@qq.com</a>‘ =&gt; <a href="mailto:&#39;codebulucck@163.com" target="_blank" rel="noopener">&#39;codebulucck@163.com</a>‘ } //作者信息<br> s.dependency ‘AFNetworking’, ‘~&gt; 2.3’ //依赖库，如果该pod依赖其他pod，可以在此处加上。</p><p>完成podspec文件修改之后我们可以将对应的组件代码放到Classes文件夹路径下面。下面将本地代码库和远程代码库关联起来，然后将本地代码推送到远程仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git remote add origin https://github.com/codemonkeybulucck/FirstViewController.git</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git add .</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git commit -m &quot;初始化&quot;</span><br><span class="line">[master 8ac032c] 初始化</span><br><span class="line"> 25 files changed, 1209 insertions(+)</span><br><span class="line"> create mode 100644 Example/FirstViewController.xcworkspace/contents.xcworkspacedata</span><br><span class="line"> create mode 100644 Example/FirstViewController.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist</span><br><span class="line"> create mode 100644 Example/Podfile.lock</span><br><span class="line"> create mode 100644 Example/Pods/Local Podspecs/FirstViewController.podspec.json</span><br><span class="line"> create mode 100644 Example/Pods/Manifest.lock</span><br><span class="line"> create mode 100644 Example/Pods/Pods.xcodeproj/project.pbxproj</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-dummy.m</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-prefix.pch</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-umbrella.h</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController.modulemap</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController.xcconfig</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/Info.plist</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Info.plist</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-acknowledgements.markdown</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-acknowledgements.plist</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-dummy.m</span><br><span class="line"> create mode 100755 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-frameworks.sh</span><br><span class="line"> create mode 100755 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-resources.sh</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-umbrella.h</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.debug.xcconfig</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.modulemap</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.release.xcconfig</span><br><span class="line"> create mode 100644 FirstViewController/Classes/FirstViewController.h</span><br><span class="line"> create mode 100644 FirstViewController/Classes/FirstViewController.m</span><br><span class="line"> delete mode 100644 FirstViewController/Classes/ReplaceMe.m</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git push origin master</span><br><span class="line">Counting objects: 62, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (55/55), done.</span><br><span class="line">Writing objects: 100% (62/62), 23.04 KiB | 2.56 MiB/s, done.</span><br><span class="line">Total 62 (delta 10), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (10/10), done.</span><br><span class="line">To https://github.com/codemonkeybulucck/FirstViewController.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure><hr><p>3、 创建远程索引库和本地索引库，同样在github创建一个新的仓库，仓库的名字叫做LMSpec，这个仓库是pod的索引库，也就是后面如果要引用组件pod的话只要引入这个LMSpec就能从里面找到对应的组件。<br>    创建完远程仓库之后我们创建一个本地索引库，并且将本地索引库和远程仓库连接起来。<br>    <code>pod repo add LMSpec https://github.com/codemonkeybulucck/LMSpec.git</code> 执行完这条命令之后，去到 <code>~/.cocoapods/repo</code>路径下就能看到有一个master和LMSpec，master是公有cocoapod的索引库，LMSpec就是我们自己新建的索引库。到此我们已经创建好代码库以及索引库了。</p><hr><p>4、本地测试podspec文件是否可用 本地测试podspec文件是否可用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ pod lib lint</span><br><span class="line"></span><br><span class="line"> -&gt; FirstViewController (1.0.0)</span><br><span class="line">    - WARN  | summary: The summary is not meaningful.</span><br><span class="line"></span><br><span class="line">[!] FirstViewController did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it).</span><br><span class="line">You can use the `--no-clean` option to inspect any issue.</span><br></pre></td></tr></table></figure><p>上述验证表明我们本地验证已经没有错误了，但是有一个警告，我们可以使用<br><code>pod lib lint --allow-warnings</code>来忽略警告。如果我们使用<code>pod spec lint</code>来验证的话，记得要先本地代码库打tag然后将tag推动到远程仓库才能通过验证，因为该命令是同时验证本地和远程仓库，因为我们还没有打tag推送到远程仓库，所以我们先用<code>pod lib lint</code>来验证。</p><hr><p>5、 向索引库Spec Repo中提交podspec<br>  在第四步中我们已经验证我们的podspec文件没有问题了，但是我们现在还不能推送到索引库，因为我们还没有打tag，这个tag应该是与podspec文件里面的version一致，不一致的话远程验证的时候是通不过验证的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git tag -a 1.0.0 -m &quot;第一个版本pod&quot;</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git push origin master 1.0.0</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 183 bytes | 183.00 KiB/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/codemonkeybulucck/FirstViewController.git</span><br><span class="line"> * [new tag]         1.0.0 -&gt; 1.0.0</span><br></pre></td></tr></table></figure><p>完成上述步骤后我们需要将podspec提交到索引库中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ pod repo push LMSpec FirstViewController.podspec --allow-warnings</span><br><span class="line"></span><br><span class="line">Validating spec</span><br><span class="line"> -&gt; FirstViewController (1.0.0)</span><br><span class="line">    - WARN  | summary: The summary is not meaningful.</span><br><span class="line"></span><br><span class="line">Updating the `LMSpec&apos; repo</span><br><span class="line"></span><br><span class="line">Already up to date.</span><br><span class="line"></span><br><span class="line">Adding the spec to the `LMSpec&apos; repo</span><br><span class="line"></span><br><span class="line"> - [Add] FirstViewController (1.0.0)</span><br><span class="line"></span><br><span class="line">Pushing the `LMSpec&apos; repo</span><br></pre></td></tr></table></figure><p>至此为止我们已经将podspec文件推送到本地LMSpec和远程LMSpec里面了，可以到 <code>~/.cocoapods/repo/LMSpec</code>文件夹下看有没有对应FirstViewControll文件夹。该文件夹下会有一个1.0.0的文件夹，也就是我们刚刚打的tag的数值。后续如果修改代码需要重新打tag,然后到时这里也会出现新的版本的代码。<br><strong>注</strong> 如果该私有库里面引用了其他的私有库，也就是podspec文件中s.dependency引用了其他私有库的信息，需要指定私有库的位置，那么推送命令将变为</p><p><code>pod repo push LMSpec FirstViewController.podspec --allow-warnings --sources=https://github.com/codemonkeybulucck/LMSpec,master</code> </p><hr><p>6、 测试Spec Repo中的的 podspec 是否可用<br>创建一个ModuleTest的工程，进入到工程里面先执行 <code>pod init</code> ，然后编辑podfile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/codemonkeybulucck/LMSpec&apos;</span><br><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"></span><br><span class="line">target &apos;moduleTest&apos; do</span><br><span class="line">  # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line">  pod &apos;FirstViewController&apos;</span><br><span class="line">  # Pods for moduleTest</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>执行<code>pod install</code>如果没出错就代表私有库已经添加成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;本次组件化实践的方式来自于&lt;a href=&quot;https://casatwy.com/iOS-Modulization.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;casaty组件化方案&lt;/a&gt;，该方案是基于target-action模式和Mediator模式，通过Mediator利用runtime的机制来调用对应的target-action。并且在上层通过category的方式暴露对外调用的接口，这样调用者在调用的时候就知道需要传递哪些参数。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://yoursite.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="cocoapods" scheme="http://yoursite.com/tags/cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="http://yoursite.com/2018/07/29/%E7%AE%97%E6%B3%95/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2018/07/29/算法/两数之和/</id>
    <published>2018-07-29T09:12:45.000Z</published>
    <updated>2018-07-29T09:13:15.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>给定一个数组和一个目标数，判断数组中是否有两个数的和等于该目标数，如果存在则输出它们在数组中的序号。</p><blockquote><p>解法1：第一眼看到上述题目我们第一时间的反应应该是通过两个循环遍历来找出它们的序号。第一个循环找出一个数X，然后用目标数减去该数值X得到第二个数Y，然后第二次循环找出有没有与Y相等的数值。这样时间的复杂度是O(n²)。</p></blockquote><a id="more"></a><blockquote><p>解法2：我们可以通过使用字典的的方式，数值作为字典的key，数组下标作为字典的value。我们可以在第一次便利的时候，用目标数减去循环得到的数X，然后得到目标数Y，然后判断字典中有没有以Y作为key的value。<br>如果有的话，那么此次循环的i就是第一个数值的下标，以Y作为key那个value就是第二个数值的下标。<br>如果不存在则将该次循环的下标和数值保存到字典里面。继续下一次遍历。<br>以下是Swift代码示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func _sum(_ array:[Int],targetNum:Int)-&gt;[Int]&#123;</span><br><span class="line">       var dict = [Int:Int]()</span><br><span class="line">       for(i,num) in array.enumerated()&#123;</span><br><span class="line">           let secondNum = targetNum - num</span><br><span class="line">           if let secondIndex = dict[secondNum]&#123;</span><br><span class="line">               return [i,secondIndex]</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               dict[num] = i</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return [0,0]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;两数之和&lt;/h1&gt;&lt;p&gt;给定一个数组和一个目标数，判断数组中是否有两个数的和等于该目标数，如果存在则输出它们在数组中的序号。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解法1：第一眼看到上述题目我们第一时间的反应应该是通过两个循环遍历来找出它们的序号。第一个循环找出一个数X，然后用目标数减去该数值X得到第二个数Y，然后第二次循环找出有没有与Y相等的数值。这样时间的复杂度是O(n²)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://yoursite.com/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字符串反转算法</title>
    <link href="http://yoursite.com/2018/07/29/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/07/29/算法/字符串反转算法/</id>
    <published>2018-07-29T09:09:32.000Z</published>
    <updated>2018-07-29T09:11:45.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h1><p>给定一个字符串，要求按照其按照单词的顺序进行反转<br>即： oc is the best language<br>反转后的字符串应该为： language is the bast oc</p><blockquote><p>思路：我们首先可以对给定的字符串进行普通的反转，然后将反转后的字符串进行切割成单词只有再反转会正常的单词。swift实现如下：</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func _reverseWold(_ s: String?)-&gt;String?&#123;</span><br><span class="line">        //首先先对整体字符串反转</span><br><span class="line">        guard let s = s else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        let rs = String(s.reversed())</span><br><span class="line">        //对反转后的字符串在切割成单词反转</span><br><span class="line">        var result = String()</span><br><span class="line">        let array = rs.split(separator: &quot; &quot;)</span><br><span class="line">        for (i,word) in array.enumerated()&#123;</span><br><span class="line">            let rw = String(word.reversed())</span><br><span class="line">            if i != array.count-1&#123;</span><br><span class="line">                result.append(rw+&quot; &quot;)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result.append(rw)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;字符串反转&quot;&gt;&lt;a href=&quot;#字符串反转&quot; class=&quot;headerlink&quot; title=&quot;字符串反转&quot;&gt;&lt;/a&gt;字符串反转&lt;/h1&gt;&lt;p&gt;给定一个字符串，要求按照其按照单词的顺序进行反转&lt;br&gt;即： oc is the best language&lt;br&gt;反转后的字符串应该为： language is the bast oc&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;思路：我们首先可以对给定的字符串进行普通的反转，然后将反转后的字符串进行切割成单词只有再反转会正常的单词。swift实现如下：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://yoursite.com/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串反转" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>iOS防止被逆向调试</title>
    <link href="http://yoursite.com/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%98%B2%E6%AD%A2%E8%A2%AB%E9%80%86%E5%90%91%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2018/07/25/iOS 开发/iOS防止被逆向调试/</id>
    <published>2018-07-25T06:50:23.000Z</published>
    <updated>2018-07-25T06:51:04.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><blockquote><p>反调试主要分为两种，第一种阻止调试器附加，第二种是检测是否有调试器存在</p></blockquote><a id="more"></a><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>第一种方法：</p><h3 id="0x01-ptrace"><a href="#0x01-ptrace" class="headerlink" title="0x01 ptrace"></a>0x01 ptrace</h3><blockquote><p>ptrace是系统用来对运行中的进程进行调试和跟踪的工具，通过ptrace，可以对另一个进程实现调试跟踪。但是里面提供了一个非常有用的参数，就是PT_DENY_ATTACH，const值是31，这个参数用户告诉系统阻止调试器附加。<br>在main.m里面加入以下代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line">#import &lt;dlfcn.h&gt;</span><br><span class="line">#import &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int  (*ptrace_ptr_t)(int _request,pid_t pid,caddr_t _addr,int _data);</span><br><span class="line">#ifndef PT_DENY_ATTACH</span><br><span class="line">#define PT_DENY_ATTACH 31</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">       // ptrace(PT_DENY_ATTACH,0,0,0); //系统函数并没有暴露出此方法所以不能直接通过此方式调用</span><br><span class="line">        void *handle = dlopen(0, RTLD_NOW|RTLD_GLOBAL);</span><br><span class="line">        ptrace_ptr_t ptrace_ptr = (ptrace_ptr_t)dlsym(handle, &quot;ptrace&quot;);</span><br><span class="line">        ptrace_ptr(PT_DENY_ATTACH,0,0,0);</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的代码中，本来是直接调用上面被注释的那一行代码就可以了，不过由于不是公开的函数所以没法直接调用。所以我们通过dlopen的方式，当path 参数为0是,他会自动查找 $LD_LIBRARY_PATH,$DYLD_LIBRARY_PATH, $DYLD_FALLBACK_LIBRARY_PATH 和 当前工作目录中的动态链接库，通过句柄找到对应的ptarce对应的地址，然后传入PT_DENY_ATTACH。</p></blockquote><h3 id="0x02-syscall"><a href="#0x02-syscall" class="headerlink" title="0x02 syscall"></a>0x02 syscall</h3><blockquote><p>另外一种方式可以使用syscall的方式来调用ptrace，syscall是系统提供的一个系统调用函数，因为上面的调用方式会容易被反反调试，通过NSFindSymbol找到_ptrace然后hook对应的函数，所以可以最好是通过syscall来反调试<br>在Kernel Syscalls里面找到<a href="https://www.theiphonewiki.com/wiki/Kernel_Syscalls" target="_blank" rel="noopener">ptrace</a>对应的const。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ joker -u ~/Documents/projects/iOS.6.0.iPod4.kernel </span><br><span class="line">This is an ARM binary. Applying iOS kernel signatures</span><br><span class="line">Entry point is 0x80085084....This appears to be XNU 2107.2.33</span><br><span class="line">Syscall names are @2a70f0</span><br><span class="line">Sysent offset in file/memory (for patching purposes): 0x2ef0c0/0x802f00c0</span><br><span class="line"></span><br><span class="line">Suppressing enosys (0x800b3429)  T = Thumb</span><br><span class="line">1. exit                  801d4a74 T</span><br><span class="line">2. fork                  801d7980 T</span><br><span class="line">3. read                  801eb584 T</span><br><span class="line">4. write                 801eb958 T</span><br><span class="line">5. open                  800b13a4 T</span><br><span class="line">6. close                 801ccab4 T</span><br><span class="line">7. wait4                 801d56bc T</span><br><span class="line">9. link                  800b18e8 T</span><br><span class="line">10. unlink               800b1ff0 T</span><br><span class="line">12. chdir                800b0c60 T</span><br><span class="line">13. fchdir               800b0af0 T</span><br><span class="line">14. mknod                800b14bc T</span><br><span class="line">15. chmod                800b2b40 T</span><br><span class="line">16. chown                800b2c9c T</span><br><span class="line">18. getfsstat            800b088c T</span><br><span class="line">20. getpid               801dc20c T</span><br><span class="line">23. setuid               801dc4c0 T</span><br><span class="line">24. getuid               801dc290 T</span><br><span class="line">25. geteuid              801dc2a0 T</span><br><span class="line">26. ptrace               801e812c T</span><br><span class="line">27. recvmsg              8020a8fc T</span><br><span class="line">28. sendmsg              8020a444 T</span><br><span class="line">29. recvfrom             8020a528 T</span><br><span class="line">30. accept               80209dfc T</span><br><span class="line">31. getpeername          8020abc8 T</span><br><span class="line">32. getsockname          8020ab18 T</span><br><span class="line">33. access               800b24ac T</span><br><span class="line">34. chflags              800b2928 T</span><br><span class="line">35. fchflags             800b29f0 T</span><br><span class="line">36. sync                 800b0320 T</span><br><span class="line">37. kill                 801dfdcc T</span><br><span class="line">39. getppid              801dc214 T</span><br><span class="line">41. dup                  801cab04 T</span><br><span class="line">42. pipe                 801edbe4 T</span><br><span class="line">43. getegid              801dc318 T</span><br><span class="line">46. sigaction            801deee8 T</span><br><span class="line">47. getgid               801dc308 T</span><br><span class="line">48. sigprocmask          801df42c T</span><br><span class="line">49. getlogin             801dd0e8 T</span><br><span class="line">50. setlogin             801dd160 T</span><br><span class="line">51. acct                 801c54ec T</span><br><span class="line">52. sigpending           801df5d0 T</span><br></pre></td></tr></table></figure><blockquote><p>注意一下代码中的26就是ptrace的const。<br>综上所述：调用syscall(26,31,0,0,0)就可以达到反调试的目的。</p></blockquote><h3 id="0x03-sysctl"><a href="#0x03-sysctl" class="headerlink" title="0x03 sysctl"></a>0x03 sysctl</h3><blockquote><p>可以通过sysctl查看内核进程状态标志位，如果一个进程在调试状态，会有一个标志位（info.kp_proc.p_flag）来标识当前是否正在调试。<br>代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BOOL existDebugger()&#123;</span><br><span class="line">    int name[4];//指定查询信息的数组</span><br><span class="line">    struct kinfo_proc info;//查询的返回结果</span><br><span class="line">    size_t info_size = sizeof(info);</span><br><span class="line">    info.kp_proc.p_flag = 0;</span><br><span class="line">    </span><br><span class="line">    name[0] = CTL_KERN;</span><br><span class="line">    name[1] = KERN_PROC;</span><br><span class="line">    name[2] = KERN_PROC_PID;</span><br><span class="line">    name[3] = getpid();</span><br><span class="line">    if (sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0) == -1) &#123;</span><br><span class="line">        NSLog(@&quot;sysctl error ...&quot;);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以定时执行以上代码，当检测到程序正在被调试，可以调用exit(0)来让程序奔溃或者做其他的操作</p></blockquote><h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><blockquote><p>syscall可以通过软中断实现从用户态切换到系统内核态的转换，同时可以通过arm 汇编实现以上功能。通过asm volatile内联汇编，实际上也是调用了ptrace。<br>代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __arm__</span><br><span class="line">        asm volatile(</span><br><span class="line">                     &quot;mov r0,#31\n&quot;</span><br><span class="line">                     &quot;mov r1,#0\n&quot;</span><br><span class="line">                     &quot;mov r2,#0\n&quot;</span><br><span class="line">                     &quot;mov r12,#26\n&quot;</span><br><span class="line">                     &quot;svc #80\n&quot;</span><br><span class="line"></span><br><span class="line">                     );</span><br><span class="line">#endif</span><br><span class="line">#ifdef __arm64__</span><br><span class="line">        asm volatile(</span><br><span class="line">                     &quot;mov x0,#26\n&quot;</span><br><span class="line">                     &quot;mov x1,#31\n&quot;</span><br><span class="line">                     &quot;mov x2,#0\n&quot;</span><br><span class="line">                     &quot;mov x3,#0\n&quot;</span><br><span class="line">                     &quot;mov x16,#0\n&quot;</span><br><span class="line">                     &quot;svc #128\n&quot;</span><br><span class="line">                     );</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;headerlink&quot; title=&quot;0x01&quot;&gt;&lt;/a&gt;0x01&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;反调试主要分为两种，第一种阻止调试器附加，第二种是检测是否有调试器存在&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://yoursite.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="反调试" scheme="http://yoursite.com/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>iOS字符串加密以及静态混淆</title>
    <link href="http://yoursite.com/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E6%B7%B7%E6%B7%86/"/>
    <id>http://yoursite.com/2018/07/25/iOS 开发/iOS字符串加密以及静态混淆/</id>
    <published>2018-07-25T06:48:36.000Z</published>
    <updated>2018-07-25T06:52:38.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-字符串加密"><a href="#0x01-字符串加密" class="headerlink" title="0x01 字符串加密"></a>0x01 字符串加密</h2><blockquote><h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>在开发中我们总是会用到加解密，有些同学可能不注意会直接把对称加密的key直接写到程序中，这样使用Hopper或者IDA静态分析的时候是可以直接看到加密的key，这样容易被别人破解，所以需要采用一些方法对文件里面的key进行加密，使得在静态分析阶段无法直接获取加密的key，增加逆向难度。</p><h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>在这里我们可以使用异或计算方法对某一个key进行加密，异或的原理是如果二进制位相同则为0，不相同则为1，如果a^b = c,那么b^c=a。</p></blockquote><a id="more"></a><blockquote><p>代码参考如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#define XOR_KEY 0xBB</span><br><span class="line"></span><br><span class="line">void xorString(unsigned char *str, unsigned char key)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char *p = str;</span><br><span class="line">    while( ((*p) ^=  key) != &apos;\0&apos;)  p++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testFunction</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char str[] = &#123;(XOR_KEY ^ &apos;e&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;n&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;k&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;e&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;y&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;\0&apos;)&#125;;</span><br><span class="line">    xorString(str, XOR_KEY);</span><br><span class="line">    static unsigned char result[6];</span><br><span class="line">    memcpy(result, str, 6);</span><br><span class="line">    NSLog(@&quot;%s&quot;,result);      //output: enkey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>如果在工程中需要加密的字符串很多，这个时候就要遍历文件进行加密，这个时候如果手动查找的话那工作量就会很大，还好Clang可以帮助我们完成这个事情。iOS中有一个libClang提供了Clang的C接口，用于源代码转换成抽象语法树，并对抽象语法树进行便利和分析。具体的操作思路可以看<a href="https://bbs.pediy.com/thread-217991.htm" target="_blank" rel="noopener">iOS加固浅谈之字符串加密</a></p></blockquote><h2 id="0x02-类和方法加密"><a href="#0x02-类和方法加密" class="headerlink" title="0x02 类和方法加密"></a>0x02 类和方法加密</h2><blockquote><h3 id="0x01-1"><a href="#0x01-1" class="headerlink" title="0x01"></a>0x01</h3><p>如果对程序的安全要求更高一点，可以对程序中所有的类和方法进行混淆，也就是用一些乱序无意义的字符串来对程序的类和方法进行替换。但是这个方法有一个弊端，至于什么弊端会在0x04说明</p><h3 id="0x02-1"><a href="#0x02-1" class="headerlink" title="0x02"></a>0x02</h3><p>第一种混淆方法是宏定义，通过增加一个pch文件，在pch文件中将类名和方法名定义成一些无意义的字符串，然后配置prefix Header的路径为pch的路径，这样在静态分析的时候看到的就是乱序的字符串。以下为PCH的内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ifndef PrefixHeader_pch</span><br><span class="line">#define PrefixHeader_pch</span><br><span class="line">// Classes</span><br><span class="line">#ifndef TestClass</span><br><span class="line">#define TestClass l4prfxSkn</span><br><span class="line">#endif</span><br><span class="line">// Methods</span><br><span class="line">#ifndef testClasssMehtod</span><br><span class="line">#define testClasssMehtod l9b0e29rLKJNqI23</span><br><span class="line">#endif // testClasssMehtod</span><br><span class="line">#ifndef testInstanceMethod</span><br><span class="line">#define testInstanceMethod e0lvc2hezXEA2jIBNw</span><br><span class="line">#endif // testInstanceMethod</span><br><span class="line"></span><br><span class="line">#endif /* PrefixHeader_pch */</span><br></pre></td></tr></table></figure><blockquote><p>下面是testClass.h</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface TestClass : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">- (void)testInstanceMethod;</span><br><span class="line">+ (void)testClasssMehtod;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>静态分析截图<br><img src="https://upload-images.jianshu.io/upload_images/2269918-0567c17a9a579829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><blockquote><p>通过上面我们已经可以看到静态分析之后完全看不出上面是哪个类调用了哪个方法。</p><h3 id="0x03-1"><a href="#0x03-1" class="headerlink" title="0x03"></a>0x03</h3><p>和字符串加密一样，一个项目中肯定有很多类和很多方法，如果我们手动去宏定义的话那这是一个巨大的工作量，不过还好Github已经有现成的项目来帮我们生成宏定义。<a href="https://github.com/Polidea/ios-class-guard" target="_blank" rel="noopener">ios-class-guard</a>这个项目可以把所有使用系统库符号的dump下来并过滤掉，只生成用户需要混淆的符号。然后将生成的符号添加到pch文件里面即可</p><h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>上面无序随机字符串加密的弊端就是在提交到AppStore审核的时候，苹果会认为你的APP可能会存在隐藏的功能然后拒接你的上架。<br>另外一种解决方法就是将上线无序随机字符串换成有意义的单词，使得方法名看起来是有意义的，但是它的意义却不是该方法真正的作用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-字符串加密&quot;&gt;&lt;a href=&quot;#0x01-字符串加密&quot; class=&quot;headerlink&quot; title=&quot;0x01 字符串加密&quot;&gt;&lt;/a&gt;0x01 字符串加密&lt;/h2&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;headerlink&quot; title=&quot;0x01&quot;&gt;&lt;/a&gt;0x01&lt;/h3&gt;&lt;p&gt;在开发中我们总是会用到加解密，有些同学可能不注意会直接把对称加密的key直接写到程序中，这样使用Hopper或者IDA静态分析的时候是可以直接看到加密的key，这样容易被别人破解，所以需要采用一些方法对文件里面的key进行加密，使得在静态分析阶段无法直接获取加密的key，增加逆向难度。&lt;/p&gt;
&lt;h3 id=&quot;0x02&quot;&gt;&lt;a href=&quot;#0x02&quot; class=&quot;headerlink&quot; title=&quot;0x02&quot;&gt;&lt;/a&gt;0x02&lt;/h3&gt;&lt;p&gt;在这里我们可以使用异或计算方法对某一个key进行加密，异或的原理是如果二进制位相同则为0，不相同则为1，如果a^b = c,那么b^c=a。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://yoursite.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="代码混淆" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    
  </entry>
  
  <entry>
    <title>LLDB解密framework</title>
    <link href="http://yoursite.com/2018/07/25/iOS%20%E9%80%86%E5%90%91/LLDB%E8%A7%A3%E5%AF%86framework/"/>
    <id>http://yoursite.com/2018/07/25/iOS 逆向/LLDB解密framework/</id>
    <published>2018-07-25T06:47:11.000Z</published>
    <updated>2018-07-25T06:55:20.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>除了使用dumpdecrypted去解密APP和framework的内容以外，也可以使用LLDB直接从内存中dump出解密后的模块。</p></blockquote><a id="more"></a><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>获取framework文件，查看文件对应的偏移<br>以下是要执行的命令以及解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lemons-iPhone5S:~ root# ps aux | grep WeChat  //查看Wechat的沙盒目录</span><br><span class="line">mobile    2636   0.0  2.7  1019472  27476   ??  Ss    9:14AM   0:15.37 /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app/WeChat</span><br><span class="line">root      3316   0.0  0.0   525920    224 s001  R+    4:52PM   0:00.01 grep WeChat</span><br><span class="line">lemons-iPhone5S:~ root# /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app</span><br><span class="line">-sh: /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app: is a directory</span><br><span class="line">lemons-iPhone5S:~ root# cd /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app</span><br><span class="line">找到对应的MMCommon.framework，将MMCommon.framework复制到mac</span><br></pre></td></tr></table></figure><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>在mac查看MMCommon.framework的加密偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd MMCommon.framework</span><br><span class="line">otool -hf MMCommon  //查看MMcommon的文件头部的基础信息</span><br><span class="line">otool -arch arm64 -l MMCommon | grep crypt //获取64位机器加密数据信息</span><br></pre></td></tr></table></figure><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p>使用LLDB附加越狱机器，查看MMcommon进程的偏移<br>image list MMCommon<br>通过如下命令dump出解密后的二进制数据<br>memory read –force –outfile ~/Desktop/outputStream –binary –count 3928342 16384+0x00000000384829894</p><ul><li>3928342 是在上述otool -arch 命令中获取到的cryptsize的值，表明当加密数据的的大小</li><li>16384 是在上述otool -arch命令汇总获取到的cryptoff的值，代表加密的数据在MMCommon中偏移</li><li>0x00000000384829894 是在上述image list MMCommon中的模块基地址</li></ul><p>上述命令执行完成之后会在桌面生成一个outputStream文件</p><h2 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h2><p>修复文件，因为dump出来的文件都没有mach-O文件头，所以需要把dump出来的数据放回原来的framework里面，替换原来加密的数据</p><p>dd seek=2384834 bs=1 conv=notrunc if=/Users/lemon/Desktop/outputSteam of=./MMCommon</p><p>lipo MMCommon -thin arm64 -output MMCommon_arm64</p><ul><li>2384834是上述otool -hf的时候architecture 1中的offset的值加上16384（加密数据偏移的值），两者相加，得到了写入的加密数据在文件中的偏移值。</li><li>替换之后，使用lipo 从FAT文件中提取arm64架构的文件。将MMcommon_arm64拖到MachOView中，修改cryptid为00000000。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;除了使用dumpdecrypted去解密APP和framework的内容以外，也可以使用LLDB直接从内存中dump出解密后的模块。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 逆向" scheme="http://yoursite.com/categories/iOS-%E9%80%86%E5%90%91/"/>
    
    
      <category term="LLDB" scheme="http://yoursite.com/tags/LLDB/"/>
    
  </entry>
  
  <entry>
    <title>dumpdecrypted介绍及其使用</title>
    <link href="http://yoursite.com/2018/07/25/iOS%20%E9%80%86%E5%90%91/dumpdecrypted%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/25/iOS 逆向/dumpdecrypted介绍及其使用/</id>
    <published>2018-07-25T06:45:16.000Z</published>
    <updated>2018-07-25T06:45:53.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><blockquote><p>dumpdecrypted 是一个开源的工具，它会注入可执行文件中，动态的从内存中dump解密后的内容。</p></blockquote><p>##2.原始版dumpdecrypted使用</p><p>###2.1下载以及编译dumpdecrypted</p><blockquote><p>从github下载源代码并且编译：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MacBookPro:dumpdecrypted lemon$ git clone https://github.com/stefanesser/dumpdecrypted.git</span><br><span class="line">Cloning into &apos;dumpdecrypted&apos;...</span><br><span class="line">remote: Counting objects: 31, done.</span><br><span class="line">remote: Total 31 (delta 0), reused 0 (delta 0), pack-reused 31</span><br><span class="line">Unpacking objects: 100% (31/31), done.</span><br><span class="line">MacBookPro:dumpdecrypted lemon$ cd dumpdecrypted/</span><br><span class="line">MacBookPro:dumpdecrypted lemon$ make</span><br><span class="line">`xcrun --sdk iphoneos --find gcc` -Os  -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -c -o dumpdecrypted.o dumpdecrypted.c</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-2-用PS命令定位待解密的可执行文件"><a href="#2-2-用PS命令定位待解密的可执行文件" class="headerlink" title="2.2 用PS命令定位待解密的可执行文件"></a>2.2 用PS命令定位待解密的可执行文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MacBookPro:~ lemon$ ssh 5s</span><br><span class="line">lemons-iPhone5S:~ root# ps -e | grep /var</span><br><span class="line">  481 ??         0:05.44 /usr/libexec/pkd -d/var/db/PlugInKit-Annotations</span><br><span class="line"> 6707 ??         0:06.07 /var/containers/Bundle/Application/4503A878-7B82-46C3-B938-8D8719A6D78E/Friday.app/Friday</span><br><span class="line"> 6715 ttys000    0:00.01 grep /var</span><br></pre></td></tr></table></figure><h3 id="2-3-获取目标APP的document目录"><a href="#2-3-获取目标APP的document目录" class="headerlink" title="2.3 获取目标APP的document目录"></a>2.3 获取目标APP的document目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lemons-iPhone5S:~ root# cat /var/containers/Bundle/Application/4503A878-7B82-46C3-B938-8D8719A6D78E/Friday.app/Info.plist | grep CFBundleIdentifier -A 1</span><br><span class="line">    &lt;key&gt;CFBundleIdentifier&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;com.xtuone.Friday&lt;/string&gt;</span><br></pre></td></tr></table></figure><h3 id="2-4-将dylib复制到document目录"><a href="#2-4-将dylib复制到document目录" class="headerlink" title="2.4 将dylib复制到document目录"></a>2.4 将dylib复制到document目录</h3><h4 id="2-4-1-通过私有api获取目标app的document目录"><a href="#2-4-1-通过私有api获取目标app的document目录" class="headerlink" title="2.4.1 通过私有api获取目标app的document目录"></a>2.4.1 通过私有api获取目标app的document目录</h4><blockquote><p>新建一个xcode项目，将以下代码复制到APPDelegate的application:didfinishLaunchingWithOptions:下，然后运行项目，就可以在控制器输出document的目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundleId = @&quot;com.xtuone.Friday&quot;;</span><br><span class="line">    NSURL *url = [[NSClassFromString(@&quot;LSApplicationProxy&quot;) performSelector:@selector(applicationProxyForIdentifier:) withObject:bundleId]performSelector:@selector(dataContainerURL)];</span><br><span class="line">    NSLog(@&quot;%@&quot;,[url.absoluteString stringByAppendingString:@&quot;/Documents&quot;]);</span><br></pre></td></tr></table></figure><blockquote><p>通过以上代码获得的document目录是：/var/mobile/Containers/Data/Application/06B16FDB-4EA1-4093-A729-613111061798/Documents</p></blockquote><p>####2.4.2 通过cycript获取目标app的document目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lemons-iPhone5S:~ root# cycript -p 6707</span><br><span class="line">cy# [[NSBundle mainBundle]bundleIdentifier]</span><br><span class="line">@&quot;com.xtuone.Friday&quot;</span><br><span class="line">cy# NSHomeDirectory()</span><br><span class="line">@&quot;/var/mobile/Containers/Data/Application/06B16FDB-4EA1-4093-A729-613111061798&quot;</span><br><span class="line">cy#</span><br></pre></td></tr></table></figure><h4 id="2-4-3-复制dumpdecrypted-dylib到上述的document路径中"><a href="#2-4-3-复制dumpdecrypted-dylib到上述的document路径中" class="headerlink" title="2.4.3 复制dumpdecrypted.dylib到上述的document路径中"></a>2.4.3 复制dumpdecrypted.dylib到上述的document路径中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 dumpdecrypted.dylib root@localhost:/var/mobile/Containers/Data/Application/06B16FDB-4EA1-4093-A729-613111061798/Documents</span><br></pre></td></tr></table></figure><h3 id="2-5-解密"><a href="#2-5-解密" class="headerlink" title="2.5 解密"></a>2.5 解密</h3><blockquote><p>通过DYLD_INSERT_LIBRARIES注入解密</p></blockquote><h2 id="3-通过frida-ios-dump-来给应用脱壳"><a href="#3-通过frida-ios-dump-来给应用脱壳" class="headerlink" title="3 通过frida-ios-dump 来给应用脱壳"></a>3 通过<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a> 来给应用脱壳</h2><h2 id="4-Clutch"><a href="#4-Clutch" class="headerlink" title="4 Clutch"></a>4 <a href="https://github.com/KJCracks/Clutch" target="_blank" rel="noopener">Clutch</a></h2><blockquote><p>clutch同样是一个开源解密工具，与dumpdecrypted不同的是，Clutch会生成一个新的进程，然后暂停进程并且dump内存来生成新的ipa。</p></blockquote><h3 id="4-1-下载并编译Clutch"><a href="#4-1-下载并编译Clutch" class="headerlink" title="4.1 下载并编译Clutch"></a>4.1 下载并编译Clutch</h3><blockquote><p>git clone  <a href="https://github.com/KJCracks/Clutch" target="_blank" rel="noopener">https://github.com/KJCracks/Clutch</a><br>下载完成之后用xcode打开工程，设置Debug生成所有的架构，设置Build Active Architecture 为 NO ，选择真机设备 command+B 编译。编译完成之后在本地的Build文件夹里面会有一个Clutch的命令行文件</p></blockquote><h3 id="4-2-将文件复制到设备中"><a href="#4-2-将文件复制到设备中" class="headerlink" title="4.2 将文件复制到设备中"></a>4.2 将文件复制到设备中</h3><blockquote><p>使用如下命令，把生成的Build/Clutch复制到设备/usr/bin目录下，并且设置可执行权限。<br>scp -P 2222 root@localhost:/usr/bin<br>ssh 5s<br>chmod +x /usr/bin/Cluch</p></blockquote><h3 id="4-3-Clutch解密"><a href="#4-3-Clutch解密" class="headerlink" title="4.3 Clutch解密"></a>4.3 Clutch解密</h3><blockquote><p>SSH到越狱设备，使用Clutch -i 运行获取目标target的BundleID<br>使用Clutch -b target.BundleID来解密</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lemons-iPhone5S:~ root# Clutch -b com.xtuone.Friday</span><br><span class="line">2018-06-21 16:46:11.732 Clutch[6958:1126993] command: Only dump binary files from specified bundleID</span><br><span class="line">Zipping Friday.app</span><br><span class="line">Dumping &lt;FridayExtensionOC&gt; (arm64)</span><br><span class="line">Patched cryptid (64bit segment)</span><br><span class="line">Writing new checksum</span><br><span class="line">2018-06-21 16:46:12.872 clutch[6960:1127016] command: Only dump binary files from specified bundleID</span><br><span class="line">Failed to dump framework (null) :(</span><br><span class="line">Dumping &lt;Friday&gt; (arm64)</span><br><span class="line">Patched cryptid (64bit segment)</span><br><span class="line">Writing new checksum</span><br><span class="line">Zipping lame.framework</span><br><span class="line">Zipping FridayExtensionOC.appex</span><br><span class="line">DONE: /private/var/mobile/Documents/Dumped/com.xtuone.Friday-iOS8.0-(Clutch-(null)).ipa</span><br><span class="line">Finished dumping com.xtuone.Friday in 20.8 seconds</span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>给应用砸壳实际上有两种方法，一种是基于DYLD_INSERT_LIBRARIES环境变量将动态库注入到目标进程，然后dump内存。另外一种是通过posix_spawnp创建一个进程，然后dump内存。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;&gt;&lt;/a&gt;1.介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;dumpdecrypted 是一个开源的工具，它会注入可执行文件中，动态的从内存中dump解密后的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##2.原始版dumpdecrypted使用&lt;/p&gt;
&lt;p&gt;###2.1下载以及编译dumpdecrypted&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从github下载源代码并且编译：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MacBookPro:dumpdecrypted lemon$ git clone https://github.com/stefanesser/dumpdecrypted.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Cloning into &amp;apos;dumpdecrypted&amp;apos;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Counting objects: 31, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Total 31 (delta 0), reused 0 (delta 0), pack-reused 31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Unpacking objects: 100% (31/31), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MacBookPro:dumpdecrypted lemon$ cd dumpdecrypted/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MacBookPro:dumpdecrypted lemon$ make&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;`xcrun --sdk iphoneos --find gcc` -Os  -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -c -o dumpdecrypted.o dumpdecrypted.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS 逆向" scheme="http://yoursite.com/categories/iOS-%E9%80%86%E5%90%91/"/>
    
    
      <category term="dumpdecrypted" scheme="http://yoursite.com/tags/dumpdecrypted/"/>
    
  </entry>
  
  <entry>
    <title>iOS 逆向常用工具</title>
    <link href="http://yoursite.com/2018/07/25/iOS%20%E9%80%86%E5%90%91/iOS-%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/07/25/iOS 逆向/iOS-逆向常用工具/</id>
    <published>2018-07-25T06:43:17.000Z</published>
    <updated>2018-07-25T06:46:09.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mac工具"><a href="#mac工具" class="headerlink" title="mac工具"></a>mac工具</h2><h3 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h3><ul><li><a href="https://iterm2.com/" target="_blank" rel="noopener">iTerm2</a></li></ul><blockquote><p>代替默认的Terminal，提供了很多高级设置，例如自动补全，高亮等等</p></blockquote><ul><li><a href="https://github.com.robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a></li></ul><blockquote><p>自定义主题，git显示，Tab补全等</p></blockquote><ul><li><a href="http://zipzapmac.com/go2shell" target="_blank" rel="noopener">Go2Shell</a></li></ul><blockquote><p>从finder中打开终端并且自动切换到当前目录</p></blockquote><ul><li><a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a></li></ul><blockquote><p>工作流软件，快速打开软件，添加自己的工作流。参见<a href="https://bestswifter.gitbook.io/effectivemac/mac-gong-zuo-liu/alfred-jian-jie" target="_blank" rel="noopener">bestswifter的博客</a></p></blockquote><a id="more"></a><h3 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h3><ul><li><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a></li></ul><blockquote><p>MacOS的包管理器，快速安装各种工作</p></blockquote><ul><li><a href="https://github.com/libimobiledevice" target="_blank" rel="noopener">libimobiledevice</a></li></ul><blockquote><p>提供了很多能与iOS交付的工具，例如端口映射查看日志，安装程序</p></blockquote><h3 id="逆向工具"><a href="#逆向工具" class="headerlink" title="逆向工具"></a>逆向工具</h3><ul><li><a href="http://www.newosxbook.com/tools/jtool.html" target="_blank" rel="noopener">jtool</a></li></ul><blockquote><p>查看文件的结构，代码签名</p></blockquote><ul><li><a href="http://www.capstone-engine.org/" target="_blank" rel="noopener">capstone</a></li></ul><blockquote><p>多平台，多架构支持的反汇编框架</p></blockquote><ul><li><a href="https://github.com/keystone-engine/keystone" target="_blank" rel="noopener">keystone</a></li></ul><blockquote><p>将汇编指令转换成Hex机器码</p></blockquote><ul><li><a href="https://github.com/radare/radare2" target="_blank" rel="noopener">redare2</a></li></ul><blockquote><p>一款开放源代码的逆向工程平台</p></blockquote><ul><li><a href="https://github.com/imkira/mobiledevice" target="_blank" rel="noopener">mobiledevice</a></li></ul><blockquote><p>安装app或者ipa包</p></blockquote><ul><li><a href="http://www.i-funbox.com/" target="_blank" rel="noopener">iFunBox</a></li></ul><blockquote><p>查看越狱设备的文件目录</p></blockquote><ul><li><a href="https://github.com/stefanesser/dumpdecrypted.git" target="_blank" rel="noopener">dumpdecrypted</a></li></ul><blockquote><p>dumpdecrypted 是一个开源的砸壳工具，它会注入可执行文件，动态的从内存中dump出解密后的内容。使用教程请看<a href="">这里</a></p></blockquote><ul><li><a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">class-dump</a></li></ul><blockquote><p>class-dump 是一个用于从可执行文件中获取类，方法和属性的工具，上述源代码在导出ARMV7架构的时候会出问题，原因是在读取类没有分64和32位系统进行不同的操作，最新的fix bug的源码在<a href="https://github.com/AloneMonkey/class-dump" target="_blank" rel="noopener">AloneMonkey/Class-dump</a></p></blockquote><ul><li><a href="https://revealapp.com" target="_blank" rel="noopener">Reveal</a></li></ul><blockquote><p>Reveal 是一个用户动态查看APP UI层级架构的工具，可以在开发过程中动态调试修改程序的样式，也可以注入第三方APP以查看应用的界面结构。<br>有两种方式可以使用Reveal，第一种是正向开发的时候通过pod的方式加入Reveal</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target &apos;RevealAPP&apos; do</span><br><span class="line">    pod &apos;Reveal-SDK&apos;, :configurations=&gt; [&apos;Debug&apos;]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>第二种方式是越狱设备注入Raveal,可以调试所有的APP，在越狱设备，可以将RevealServer重命名为libReveal.dylib，以及新建libReveal.plist文件，里面输入需要调试的APP的BundleID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   Filter = &#123;</span><br><span class="line">         Bundles = (</span><br><span class="line">             &quot;com.lemon.example&quot;,</span><br><span class="line">         );</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上两个文件复制到越狱设备的 /Library/MobileSubstrate/DynamicLibraries/目录下，这样可以通过Cydia Substrate的MobileLoader在程序运行的时候通过dyld_insert_libraries命令将自己加载到目标APP的Document目录下，然后查找上述路径的所有的plist，找到对应的Bundleid之后，通过dlopen()函数将动态库注入到APP中 </p><h2 id="越狱设备工具"><a href="#越狱设备工具" class="headerlink" title="越狱设备工具"></a>越狱设备工具</h2><ul><li>cydia</li></ul><blockquote><p>cydia是一个可以让用户在越狱设备上面安装各种插件的软件管理器，相当于越狱设备的APPStore</p></blockquote><ul><li>SSH</li></ul><blockquote><p>SSH是一种网络协议，用于计算机之前的加密登录，他存在多种实现，因为不同系统使用的越狱工具不一样，所以需要根据iOS的版本来进行设置。<br>iOS8 &amp; iOS9 ，可以通过安装OpenSSH来登录，安装方法：1.在cydia中搜索OpenSSH并且安装，安装完成之后打开Wifi设置界面，打开当前连接的wifi，获取ip地址(假设是192.168.2.21)，然后打开终端，输入以下命令后回车： ssh <a href="mailto:root@192.168.2.21" target="_blank" rel="noopener">root@192.168.2.21</a>  2.稍等片刻之后输入yes并且回车，然后输入默认密码alpine完成登录。（当远程主机的公钥被接受以后，他会保存到mac的$HOME/.ssh/known_hosts文件中，再次连接这台主机时，系统就会认出他的公钥已经保存到本地，从而跳过警告部分，直接提示用户输入密码。）<br>iOS10.0 &amp; iOS10.2 ，越狱工具yalu内置了一个相对轻量级的工具dropbear，供用户直接使用。安装方法：1.在cydia中搜索MTerminal和adv-cmds，然后运行ps aux | grep dropbear 命令。如果有输出内容，则代表默认支持usb连接，如果这是要连接，在mac上转发端口即可登录，命令如下：<br>iproxy 22 2222<br>ssh root@localhost -p 2222<br>如果要通过wifi连接，需要在终端设备执行一下命令<br>/usr/local/bin/dropbear -F -R -p 22<br>然后在mac上直接SSH登录<br>ssh <a href="mailto:root@192.168.2.21" target="_blank" rel="noopener">root@192.168.2.21</a></p></blockquote><ul><li><a href="通过cydia安装">iFile</a></li></ul><blockquote><p>查看越狱设备的文件目录</p></blockquote><ul><li><a href="从cydia安装">cydia substrate</a></li></ul><blockquote><p>cydia substrate是一个框架，允许第三方开发者在越狱系统方法里面打一下运行时补丁和扩展一些方法，是开发越狱插件的基石。cydia substrate主要包含三个模块，分别是MobileHooker,MObileLoader,Safe mode。<br>MobileHooker 用于替换系统或者应用的方法，它提供了MSHookMessageEX 来hook OC的函数，MSHookFunction来hook C函数。<br>MobileLoader 用于将第三方动态库加载到目标应用里面。首先它会通过dyld_insert_libraries将自己加载到目标程序里面，然后通过查找/Library/MobileSubstrate/DynamicLibraries/目录下的所有plist文件，如果plist文件里面包含有当前应用的BundleID，那么就会通过dlopen()函数打开对应的dylib文件。<br>safe mode 当插件加载导致了系统奔溃时，mobilesafety会捕捉到这个异常并且让设备进入安全模式。找到最近安装的导致奔溃的插件并且卸载即可退出安全模式。</p></blockquote><ul><li>adv-cmds</li></ul><blockquote><p>提供ps命令</p></blockquote><ul><li>appsync</li></ul><blockquote><p>让系统不再校验应用的签名</p></blockquote><ul><li>scp</li></ul><blockquote><p>对于iOS10以后的版本，使用yalu越狱之后就没有scp这个工具了，可以在网上找到scp的源代码使用iFunBox复制到设备的/usr/bin目录下，然后通过ssh访问该目录，执行以下命令：<br>cd /usr/bin<br>ldid -S scp<br>chmod 777 scp</p></blockquote><ul><li><a href="https://github.com/facebook/chisel" target="_blank" rel="noopener">chisel</a></li></ul><blockquote><p>提供便利的LLDB调试命令<br>安装教程</p><ol><li>brew install chisel</li><li>如果不存在~/.lldbinit文件那就创建一个文件，并且将以下代码放到该文件中<br>#~/.lldbinit<br>…<br>command script import /usr/local/opt/chisel/libexec/fblldb.py</li><li>重启Xcode或者在LLDB中输入 command source ~/.lldbinit命令在加载脚本。</li></ol></blockquote><h3 id="安全工具"><a href="#安全工具" class="headerlink" title="安全工具"></a>安全工具</h3><ul><li><a href="https://github.com/Polidea/ios-class-guard" target="_blank" rel="noopener">ios-class-guard</a></li></ul><blockquote><p>该工具是从class-dump fork出来的，用于dump出APP中的类和方法并且生成混淆代码，将生成的混淆的宏定义添加到项目的pch文件中，达到混淆所有的类和方法的作用</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;mac工具&quot;&gt;&lt;a href=&quot;#mac工具&quot; class=&quot;headerlink&quot; title=&quot;mac工具&quot;&gt;&lt;/a&gt;mac工具&lt;/h2&gt;&lt;h3 id=&quot;效率工具&quot;&gt;&lt;a href=&quot;#效率工具&quot; class=&quot;headerlink&quot; title=&quot;效率工具&quot;&gt;&lt;/a&gt;效率工具&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://iterm2.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iTerm2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;代替默认的Terminal，提供了很多高级设置，例如自动补全，高亮等等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com.robbyrussell/oh-my-zsh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;oh-my-zsh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;自定义主题，git显示，Tab补全等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zipzapmac.com/go2shell&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go2Shell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;从finder中打开终端并且自动切换到当前目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.alfredapp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Alfred&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;工作流软件，快速打开软件，添加自己的工作流。参见&lt;a href=&quot;https://bestswifter.gitbook.io/effectivemac/mac-gong-zuo-liu/alfred-jian-jie&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bestswifter的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 逆向" scheme="http://yoursite.com/categories/iOS-%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 逆向常用命令</title>
    <link href="http://yoursite.com/2018/07/25/iOS%20%E9%80%86%E5%90%91/iOS-%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/07/25/iOS 逆向/iOS-逆向常用命令/</id>
    <published>2018-07-25T06:42:03.000Z</published>
    <updated>2018-07-25T06:42:26.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-查看信息相关"><a href="#1-查看信息相关" class="headerlink" title="1. 查看信息相关"></a>1. 查看信息相关</h3><ul><li>查看越狱设备所有的APP的BundleID （前提需要安装frida-iOS-dump）</li></ul><blockquote><p>MacBookPro:frida-ios-dump-master lemon$ ./dump.py -l</p></blockquote><ul><li>查看设备UDID (前提需要安装ideviceinstall)</li></ul><blockquote><p>MacBookPro:~ lemon$ idevice_id  -l</p></blockquote><ul><li>查看iPA是否已经砸壳 (如果返回cryptid=0代表已砸壳，否则代表未砸壳)</li></ul><blockquote><p>MacBookPro:~ lemon$ otool -l target.app/target | grep cryptid</p></blockquote><a id="more"></a><ul><li>查看设备日志</li></ul><blockquote><p>MacBookPro:~ lemon$ idevicesyslog -u deviceudid</p></blockquote><ul><li>给特定的设备安装程序</li></ul><blockquote><p>MacBookPro:~ lemon$ ideviceinstaller -i target.ipa -u  deviceudid</p></blockquote><ul><li>砸壳 (使用frida)</li></ul><blockquote><p>MacBookPro:frida-ios-dump-master lemon$ ./dump.py BundleID</p></blockquote><ul><li>class-dump头文件</li></ul><blockquote><p>MacBookPro:~ lemon$ class-dump -s -S -H target.app/target -o /path/to/save/header</p></blockquote><ul><li>查看动态库架构</li></ul><blockquote><p>lipo -info</p></blockquote><ul><li>ssh</li></ul><blockquote><p>ssh root@deviceip</p></blockquote><ul><li>查找进程</li></ul><blockquote><p>ps aux | grep /App<br>ps -e | grep /Applications</p></blockquote><ul><li>查找文件</li></ul><blockquote><p>grep -r Header /System/Library/</p></blockquote><ul><li>分离fat binary</li></ul><blockquote><p>lipo -thin armv7 WeChat.decrypted -output WeChat_armv7.decrypted<br>lipo -thin arm64 xxx.decryptec -output xxx.arm64.decrypted</p></blockquote><h3 id="2-LLDB"><a href="#2-LLDB" class="headerlink" title="2. LLDB"></a>2. LLDB</h3><ul><li>打印UI结构</li></ul><blockquote><p>po [[[UIWindow keyWindow] rootViewController] _printHierarchy]    (iOS 8)<br>po [[UIWindow keyWindow] recursiveDescription]</p></blockquote><ul><li>打印调用栈信息</li></ul><blockquote><p>bt (backtrace)<br>bt all (all threads)</p></blockquote><ul><li>objc_msgSend参数打印</li></ul><blockquote><p>po $xo</p></blockquote><blockquote><p>p (char*)$x1</p></blockquote><blockquote><p>p (SEL)$x1</p></blockquote><ul><li>返回地址</li></ul><blockquote><p>p/x $lr</p></blockquote><ul><li>增加断点</li></ul><blockquote><p>b -a ox00002224</p></blockquote><ul><li>列举模块</li></ul><blockquote><p>image lisg -o -f </p></blockquote><ul><li>lldb基础指令</li></ul><blockquote><p>c<br>n<br>ni<br>br list<br>br del<br>br dis<br>br en</p></blockquote><ul><li>远程调试</li></ul><blockquote><p>debugserver *:1234 -a pid</p></blockquote><blockquote><p>debugserver -x backboard *:1234 /var/mobile/Containers/Bundle/Application/9DB7CE45-3B4C-42A3-9D4D-49A3A5122903/AlipayWallet.app/AlipayWallet</p></blockquote><ul><li>远程连接</li></ul><blockquote><p>proces connect connect://192.168.2.154:1234</p></blockquote><ul><li>lldb expr例子</li></ul><blockquote><p>(lldb) expr char <em>$str = (char </em>)malloc(8)</p><p>(lldb) expr (void)strcpy($str, “munkeys”)</p><p>(lldb) expr $str[1] = ‘o’</p><p>(char) $0 = ‘o’</p><p>(lldb) p $str</p><p>(char *) $str = 0x00007fd04a900040 “monkeys”</p><p>(lldb) x/4c $str</p><p>(lldb) x/1w <code>$str + 3</code></p><p>(lldb) expr (void)free($str)</p><p>(lldb) expr id $myView = (id)0x7f82b1d01fd0</p><p>(lldb) expr (void)[$myView setBackgroundColor:[UIColor blueColor]]</p><p>(lldb) expr (void)[CATransaction flush]</p><p>(lldb) po [$myButton allTargets]</p><p>(lldb) p (ptrdiff_t)ivar_getOffset((struct Ivar *)class_getInstanceVariable([MyView class], “_layer”))</p></blockquote><ul><li>给断点增加命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br command add 1</span><br><span class="line">Enter your debugger command(s).  Type &apos;DONE&apos; to end.</span><br><span class="line">&gt; register read $rdi </span><br><span class="line">&gt; c </span><br><span class="line">&gt; DONE</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><ul><li>修改寄存器的值</li></ul><blockquote><p>register write x0 1</p></blockquote><h3 id="3-Cycript"><a href="#3-Cycript" class="headerlink" title="3. Cycript"></a>3. Cycript</h3><ul><li>查看当前界面的元素层级结构</li></ul><blockquote><p>cy# [[UIApp keyWindow]recursiveDescription].toString()</p></blockquote><ul><li>查看当前keywindow的根控制器的所有subView</li></ul><blockquote><p>cy# [[[UIApp keyWindow] rootViewController] _printHierarchy].toString()</p></blockquote><ul><li>输出简单的视图信息</li></ul><blockquote><p>cy# [[UIApp keyWindow] _autolayoutTrace].toString()</p></blockquote><ul><li>查看一个实例的所有ivar</li></ul><blockquote><p>cy# [choose(SBApplication)[0] _ivarDescription].toString()</p></blockquote><ul><li>查看一个class的对象方法和类方法</li></ul><blockquote><p>cy# [choose(SBApplicationController)[0] _methodDescription].toString()</p></blockquote><ul><li>访问对象和实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0xb226710 url]</span><br><span class="line">@&quot;ww4fd1rfRDShBo_4K6rqfwAAACMAAQED&quot;</span><br><span class="line"></span><br><span class="line">cy# c = #0x1752d8c0</span><br><span class="line">cy#&quot;&lt;FavAudioPlayerController: 0x1752d8c0; frame = (0 0; 290 60); autoresize = W; layer = &lt;CALayer: 0x172dc2b0&gt;&gt;&quot;</span><br><span class="line">cy# c-&gt;m_audioInfo</span><br><span class="line">cy#&quot;&lt;FavAudioInfo: 0x172b2a30&gt;&quot;</span><br><span class="line">cy# c-&gt;m_audioInfo.m_nsAudioPath</span><br></pre></td></tr></table></figure><h3 id="4-ARM"><a href="#4-ARM" class="headerlink" title="4. ARM"></a>4. ARM</h3><h3 id="5-工具"><a href="#5-工具" class="headerlink" title="5. 工具"></a>5. 工具</h3><ul><li><a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpdecrypted</a></li><li><a href="https://github.com/theos/theos" target="_blank" rel="noopener">theos</a></li><li><a href="https://cgit.sukimashita.com/usbmuxd.git/" target="_blank" rel="noopener">usbmuxd</a> </li><li><a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a></li><li><a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">class-dummp</a></li><li><a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-查看信息相关&quot;&gt;&lt;a href=&quot;#1-查看信息相关&quot; class=&quot;headerlink&quot; title=&quot;1. 查看信息相关&quot;&gt;&lt;/a&gt;1. 查看信息相关&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;查看越狱设备所有的APP的BundleID （前提需要安装frida-iOS-dump）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MacBookPro:frida-ios-dump-master lemon$ ./dump.py -l&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;查看设备UDID (前提需要安装ideviceinstall)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MacBookPro:~ lemon$ idevice_id  -l&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;查看iPA是否已经砸壳 (如果返回cryptid=0代表已砸壳，否则代表未砸壳)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MacBookPro:~ lemon$ otool -l target.app/target | grep cryptid&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 逆向" scheme="http://yoursite.com/categories/iOS-%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>通过theos提供的logify来为类的所有方法添加追踪日志</title>
    <link href="http://yoursite.com/2018/07/25/iOS%20%E9%80%86%E5%90%91/%E9%80%9A%E8%BF%87theos%E6%8F%90%E4%BE%9B%E7%9A%84logify%E6%9D%A5%E4%B8%BA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E8%BF%BD%E8%B8%AA%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2018/07/25/iOS 逆向/通过theos提供的logify来为类的所有方法添加追踪日志/</id>
    <published>2018-07-25T06:40:31.000Z</published>
    <updated>2018-07-25T06:41:07.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>###logify是THEOS自带的为代码添加Log的工具，可以使用该工具给指定的类添加Log代码并且生成一个新的Tweak.xm文件</p><h2 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h2><h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h3><h4 id="2-1-1-安装Theos"><a href="#2-1-1-安装Theos" class="headerlink" title="2.1.1 安装Theos"></a>2.1.1 安装Theos</h4><p> 首先需要安装<a href="https://github.com/theos/theos" target="_blank" rel="noopener">Theos</a>，安装完成之后会默认安装此工具。</p><a id="more"></a><h4 id="2-1-2-将APP脱壳，有两种方式可以获得脱壳的APP"><a href="#2-1-2-将APP脱壳，有两种方式可以获得脱壳的APP" class="headerlink" title="2.1.2 将APP脱壳，有两种方式可以获得脱壳的APP"></a>2.1.2 将APP脱壳，有两种方式可以获得脱壳的APP</h4><h5 id="2-1-2-1-无越狱机"><a href="#2-1-2-1-无越狱机" class="headerlink" title="2.1.2.1 无越狱机"></a>2.1.2.1 无越狱机</h5><p>通过PP助手去越狱市场下载脱壳的ipa，有时下载下来的也不一定是脱壳后的，你可以通过在终端执行以下命令<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -l target.app/target | grep crypt</span><br></pre></td></tr></table></figure></p><p> 如果输出<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cryptoff 16384</span><br><span class="line">cryptsize 58753024</span><br><span class="line">cryptid 0 //0 代表已经砸壳，1代表未砸壳</span><br></pre></td></tr></table></figure></p><h5 id="2-1-2-2-有越狱机"><a href="#2-1-2-2-有越狱机" class="headerlink" title="2.1.2.2 有越狱机"></a>2.1.2.2 有越狱机</h5><p> 你需要一台越狱机器，安装完整版之后通过工具来脱壳，这个时候你也有两个方法获得脱壳应用。方法一：你可以使用<a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpdecrypted</a>工具来砸壳。方式二：你也可以使用庆总开源的工具<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-iOS-dump</a>一条命令行进行砸壳。</p><h4 id="2-1-3-class-dump-出头文件"><a href="#2-1-3-class-dump-出头文件" class="headerlink" title="2.1.3 class-dump 出头文件"></a>2.1.3 class-dump 出头文件</h4><p>通过以上的方式得到砸壳后的应用之后，需要利用<a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">clas-dump</a>工具dump出头文件。具体的用法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class-dump -s -S -H target.app/target -o /path/to/save/header</span><br></pre></td></tr></table></figure><h4 id="2-1-4-使用logify工具生成Tweak-xm文件"><a href="#2-1-4-使用logify工具生成Tweak-xm文件" class="headerlink" title="2.1.4 使用logify工具生成Tweak.xm文件"></a>2.1.4 使用logify工具生成Tweak.xm文件</h4><p>该文件里面会hook该头文件对应的类，并且会在代码里面加上Log打印<br>用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logify.pl HookHeader.h的全路径 &gt;Tweak.xm</span><br></pre></td></tr></table></figure><p>如果要跟踪多个头文件，则继续转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logify.pl 其它头文件 &gt;&gt; Tweak.xm</span><br></pre></td></tr></table></figure><p> <em>注意中间是 &gt;&gt;</em></p><h4 id="2-1-5-使用nic-pl命令来生成Theos工程，选择Teak工具。"><a href="#2-1-5-使用nic-pl命令来生成Theos工程，选择Teak工具。" class="headerlink" title="2.1.5 使用nic.pl命令来生成Theos工程，选择Teak工具。"></a>2.1.5 使用nic.pl命令来生成Theos工程，选择Teak工具。</h4><h4 id="2-1-6-创建完Tweak工程之后，将在2-1-4中生成的Tweak-xm替换掉工程中的Teak-xm-不过此时还需要对该文件做一些修改"><a href="#2-1-6-创建完Tweak工程之后，将在2-1-4中生成的Tweak-xm替换掉工程中的Teak-xm-不过此时还需要对该文件做一些修改" class="headerlink" title="2.1.6 创建完Tweak工程之后，将在2.1.4中生成的Tweak.xm替换掉工程中的Teak.xm.不过此时还需要对该文件做一些修改"></a>2.1.6 创建完Tweak工程之后，将在2.1.4中生成的Tweak.xm替换掉工程中的Teak.xm.不过此时还需要对该文件做一些修改</h4><p>a.去掉.cxx_destruct 方法</p><p>b.将HBLogDebug 改为NSLog</p><p>然后修改makefile文件，在最上面那一行增加<br>THEOS_DEVICE_IP = 你的设备的IP</p><h4 id="2-1-7"><a href="#2-1-7" class="headerlink" title="2.1.7"></a>2.1.7</h4><p> 使用一下make package install 生成deb包，并且安装到越狱设备上。</p><h4 id="2-1-8-运行目标APP，观察日志。"><a href="#2-1-8-运行目标APP，观察日志。" class="headerlink" title="2.1.8 运行目标APP，观察日志。"></a>2.1.8 运行目标APP，观察日志。</h4><p> 有两种方法可以观察日志，第一种是通过xcode-&gt;window-&gt;Device and simulators-&gt;view device logs 。<br> 第二种是通过idevicesyslog -u udid 来查看特定设备的日志。这种方式需要安装<a href="https://www.jianshu.com/p/746f3ddded1f" target="_blank" rel="noopener">libimobiledevice</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h2&gt;&lt;p&gt;###logify是THEOS自带的为代码添加Log的工具，可以使用该工具给指定的类添加Log代码并且生成一个新的Tweak.xm文件&lt;/p&gt;
&lt;h2 id=&quot;2-用法&quot;&gt;&lt;a href=&quot;#2-用法&quot; class=&quot;headerlink&quot; title=&quot;2.用法&quot;&gt;&lt;/a&gt;2.用法&lt;/h2&gt;&lt;h3 id=&quot;2-1-准备工作&quot;&gt;&lt;a href=&quot;#2-1-准备工作&quot; class=&quot;headerlink&quot; title=&quot;2.1 准备工作&quot;&gt;&lt;/a&gt;2.1 准备工作&lt;/h3&gt;&lt;h4 id=&quot;2-1-1-安装Theos&quot;&gt;&lt;a href=&quot;#2-1-1-安装Theos&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 安装Theos&quot;&gt;&lt;/a&gt;2.1.1 安装Theos&lt;/h4&gt;&lt;p&gt; 首先需要安装&lt;a href=&quot;https://github.com/theos/theos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Theos&lt;/a&gt;，安装完成之后会默认安装此工具。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 逆向" scheme="http://yoursite.com/categories/iOS-%E9%80%86%E5%90%91/"/>
    
    
      <category term="logify" scheme="http://yoursite.com/tags/logify/"/>
    
  </entry>
  
  <entry>
    <title>导出iOS真机缓存的dyld_shared_cache_arm64文件</title>
    <link href="http://yoursite.com/2018/07/25/iOS%20%E9%80%86%E5%90%91/%E5%AF%BC%E5%87%BAiOS%E7%9C%9F%E6%9C%BA%E7%BC%93%E5%AD%98%E7%9A%84dyld-shared-cache-arm64%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/07/25/iOS 逆向/导出iOS真机缓存的dyld-shared-cache-arm64文件/</id>
    <published>2018-07-25T06:37:48.000Z</published>
    <updated>2018-07-25T06:38:18.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1前言"><a href="#1前言" class="headerlink" title="1前言"></a>1前言</h3><p>在iOS系统中，存在着这么一个文件夹，/System/Library/Caches/com.apple.dyld，这个文件夹里面放着的是什么文件呢，在我的iphone5s中，两个文件dyld_shared_cache_armv7s和dyly_shared_arm64，这两个文件分别代表两个arm架构，一个是armv7s一个是arm64。</p><a id="more"></a><p>顾名思义，这两个都是缓存文件，里面放着的都是各种系统所可能用到的动态库。如Foundation.framework,Security.framework等等。在/System/Library/Frameworks/这个路径下面所有的动态库只放了一些配置文件，而真正的执行文件就在上面说的缓存文件里面。因为几乎所有的iOS程序都会用到系统库，当程序运行的时候会使用dyld(位于/usr/lib/dylb)程序进行连接，另一方面，由于每个iOS程序都会连接很多的动态库，如果需要一个一个连接会很耗时，如果把它们放在一个地方打包好，等到运行的时候全部连接岂不美滋滋，基于这些原因，就有了dyld_shared_cache_armv7s和dyld_shared_cache_armv64两个缓存文件（有些设备有可能还会有dyld_shared_cache_armv7）。</p><h4 id="2工具"><a href="#2工具" class="headerlink" title="2工具"></a>2工具</h4><p>上面我已经解释了为什么会存在这两个文件以及这两个文件的作用，在iOS逆向中，我们常常需要查看某一个系统类的实现，这个时候就要去对应的系统库里面查看，这些系统库就放在对应的缓存文件里面了。但是这些文件是经过处理的，不可以直接查看，所以需要用到一些工具来查看。这里介绍两个工具，一个是<a href="https://github.com/kennytm/Miscellaneous/downloads" target="_blank" rel="noopener">dyld_decache[v0.1c]</a> 另外一个是<a href="https://opensource.apple.com/source/dyld/dyld-195.6/launch-cache/dsc_extractor.cpp" target="_blank" rel="noopener">dsc_extractor</a>，<a href="https://www.jianshu.com/p/a7b1fed0359f" target="_blank" rel="noopener">编译方法</a> 。这两个工具的不同之处是，第一个工具是不可以用来解析arm64指令集的缓存文件的，而dsc_extractor是可以用来解析arm64指令集的缓存文件的，现在基本上大家用的都是arm64位指令集的设备了。（iPhone5s以上都是arm64位结构）</p><h4 id="3还原"><a href="#3还原" class="headerlink" title="3还原"></a>3还原</h4><p>通过2中的dyld_decache[v0.1c]工具和dsc_extractor我们可以还原出<br>dyld_shared_cache_armX缓存文件中隐藏的framework。下面是语法</p><p>#####3.1 dsc_extractor<br>usage: dsc_extractor <path-to-cache-file> <path-to-device-dir></path-to-device-dir></path-to-cache-file></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usage: dsc_extractor 你要解析的arm64的缓存文件路径 保存的路径</span><br></pre></td></tr></table></figure><p>解析过程中会出现类似于<br>0/969</p><p>1/969</p><p>2/969</p><p>3/969</p><p>4/969</p><p>5/969</p><p>…..</p><p>这样的文字。</p><h5 id="3-2-dyld-decache-v0-1c"><a href="#3-2-dyld-decache-v0-1c" class="headerlink" title="3.2 dyld_decache[v0.1c]"></a>3.2 dyld_decache[v0.1c]</h5><p>dyld_decache[v0.1c] -o 要保存的路径   你要解析的缓存文件路径</p><p>解析完成后会出现两个文件加，一个是system,另外一个usr，如无意外，所有的动态库都会在里面，接下来尽情的蹂躏他们吧。不过记得在开始这一切之前，要将iphone里面的dyld_shared_cache_arm64文件拷贝一份到OSX上面去操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1前言&quot;&gt;&lt;a href=&quot;#1前言&quot; class=&quot;headerlink&quot; title=&quot;1前言&quot;&gt;&lt;/a&gt;1前言&lt;/h3&gt;&lt;p&gt;在iOS系统中，存在着这么一个文件夹，/System/Library/Caches/com.apple.dyld，这个文件夹里面放着的是什么文件呢，在我的iphone5s中，两个文件dyld_shared_cache_armv7s和dyly_shared_arm64，这两个文件分别代表两个arm架构，一个是armv7s一个是arm64。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 逆向" scheme="http://yoursite.com/categories/iOS-%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>dsc_extractor的编译和使用</title>
    <link href="http://yoursite.com/2018/07/25/iOS%20%E9%80%86%E5%90%91/dsc-extractor%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/25/iOS 逆向/dsc-extractor的编译和使用/</id>
    <published>2018-07-25T06:34:46.000Z</published>
    <updated>2018-07-25T06:35:19.999Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1前言"><a href="#1前言" class="headerlink" title="1前言"></a>1前言</h3><p>在iOS逆向中，我们常常需要对dyld_shared_cache_armX类型的文件进行还原，第一个我们经常使用的是dyld_decache工具，但是这个工具并不能用从来还原dyld_shared_cache_arm64文件，也就是64位指令集架构的缓存文件，这个时候dsc_extractor就为你续命了。</p><a id="more"></a><h3 id="2编译"><a href="#2编译" class="headerlink" title="2编译"></a>2编译</h3><p>打开终端依次执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir dsc_extractor</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd dsc_extractor</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://opensource.apple.com/tarballs/dyld/dyld-210.2.3.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf dyld-210.2.3.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd dyld-210.2.3/launch-cache/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch dsc_extractor.patch</span><br></pre></td></tr></table></figure><p>通过上面的操作，我们下载下来了touch dsc_extractor的源码并且解压出来，并在其中创建了一个touch dsc_extractor.patch的空文件，接下来把以下内容复制到该文件里面去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">--- dyld-210.2.3/launch-cache/dsc_extractor.cpp  2012-05-21 02:35:15.000000000 -0400</span><br><span class="line">+++ dyld-210.2.3/launch-cache/dsc_extractor.cpp2013-07-26 16:05:03.000000000 -0400</span><br><span class="line">@@ -37,6 +37,7 @@</span><br><span class="line"> #include &lt;mach-o/arch.h&gt;</span><br><span class="line"> #include &lt;mach-o/loader.h&gt;</span><br><span class="line"> #include &lt;Availability.h&gt;</span><br><span class="line">+#include &lt;dlfcn.h&gt;</span><br><span class="line"> </span><br><span class="line"> #define NO_ULEB </span><br><span class="line"> #include &quot;Architectures.hpp&quot;</span><br><span class="line">@@ -456,7 +457,7 @@</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">-#if 1</span><br><span class="line">+/* #if 1 */</span><br><span class="line"> </span><br><span class="line"> typedef int (*extractor_proc)(const char* shared_cache_file_path, const char* extraction_root_path,</span><br><span class="line"> void (^progress)(unsigned current, unsigned total));</span><br><span class="line">@@ -468,7 +469,7 @@</span><br><span class="line"> return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">-void* handle = dlopen(&quot;/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle&quot;, RTLD_LAZY);</span><br><span class="line">+void* handle = dlopen(&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle&quot;, RTLD_LAZY);</span><br><span class="line"> if ( handle == NULL ) &#123;</span><br><span class="line"> fprintf(stderr, &quot;dsc_extractor.bundle could not be loaded\n&quot;);</span><br><span class="line"> return 1;</span><br><span class="line">@@ -484,7 +485,7 @@</span><br><span class="line"> fprintf(stderr, &quot;dyld_shared_cache_extract_dylibs_progress() =&gt; %d\n&quot;, result);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line">-#endif</span><br><span class="line">+/* #endif */</span><br></pre></td></tr></table></figure><h3>记住，在+/<em>endif </em>/后面是还有一行空行的。</h3><p>然后执行一下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch &lt; dsc_extractor.patch</span><br></pre></td></tr></table></figure><p>执行完成该命令后，你可以在dsc_extractor.patch文件的同级目录下看到一个dsc_extractor.cpp文件，接下来打开这个文件，要修改里面的内容。如下：<br>原处：230行</p><p>const char* afterSlash = &amp;dirs[1];<br>修改成：</p><p>char* afterSlash = &amp;dirs[1];  去除const<br>原处：460行</p><p>#if 0<br>修改成：</p><p>#if 1<br>原处：488行</p><p>/<em> #endif </em>/<br>修改成：</p><p>#endif 放开注释</p><p>修改完成后，回到终端，运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ -o dsc_extractor dsc_extractor.cpp dsc_iterator.cpp</span><br></pre></td></tr></table></figure><p>到了这里，dsc_extractor终于编译完成了，你可以在同级目录下看到dsc_extractor的执行文件。你可以把它复制到任何地方然后使用。</p><h3 id="3使用"><a href="#3使用" class="headerlink" title="3使用"></a>3使用</h3><p>编译dsc_extractor成功后，用iFunBox将iOS 里面的/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64复制到OSX的任何位置，然后在终端运行</p><p>dsc_extractor完成路径 arm64缓存文件路径  要保存文件的路径</p><p>然后终端显示<br>0/1004<br>1/1004<br>2/1004<br>3/1004<br>4/1004<br>5/1004<br>6/1004<br>7/1004<br>这样的文本的时候就成功了</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1前言&quot;&gt;&lt;a href=&quot;#1前言&quot; class=&quot;headerlink&quot; title=&quot;1前言&quot;&gt;&lt;/a&gt;1前言&lt;/h3&gt;&lt;p&gt;在iOS逆向中，我们常常需要对dyld_shared_cache_armX类型的文件进行还原，第一个我们经常使用的是dyld_decache工具，但是这个工具并不能用从来还原dyld_shared_cache_arm64文件，也就是64位指令集架构的缓存文件，这个时候dsc_extractor就为你续命了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 逆向" scheme="http://yoursite.com/categories/iOS-%E9%80%86%E5%90%91/"/>
    
    
      <category term="dsc-extractor" scheme="http://yoursite.com/tags/dsc-extractor/"/>
    
  </entry>
  
</feed>
