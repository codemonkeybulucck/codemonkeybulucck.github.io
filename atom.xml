<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lemon&#39;s blog</title>
  
  <subtitle>所有的东西你都要坚持到最后才知道值不值得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lemon2well.top/"/>
  <updated>2019-04-02T01:45:32.503Z</updated>
  <id>http://lemon2well.top/</id>
  
  <author>
    <name>lemon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>逆向微信根据手机号码搜索联系人获取WXID</title>
    <link href="http://lemon2well.top/2019/04/02/iOS%20%E9%80%86%E5%90%91/%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E6%A0%B9%E6%8D%AE%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E6%90%9C%E7%B4%A2%E8%81%94%E7%B3%BB%E4%BA%BA%E8%8E%B7%E5%8F%96WXID/"/>
    <id>http://lemon2well.top/2019/04/02/iOS 逆向/逆向微信根据手机号码搜索联系人获取WXID/</id>
    <published>2019-04-02T01:43:09.000Z</published>
    <updated>2019-04-02T01:45:32.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这段时间在忙着新版本SDK的开发，也在准备换工作的事情，虽然现在是“寒潮”，但是还是想走出舒适区，去感受一下春天的“寒冷”。也很久没有接触逆向方面的工作了，昨天一个大学同学问我，能不能通过一个人的手机号以及微信号找到那个人对应的wxid，其实我也不清楚，但是我们来尝试一下找一下。</p></blockquote><h3 id="1-wxid-是什么？"><a href="#1-wxid-是什么？" class="headerlink" title="1. wxid 是什么？"></a>1. wxid 是什么？</h3><p>wxid是顾名思义就是微信的ID，也就是一个手机号码刚注册的时候，微信给予用户的一个初始化ID，这个和后面的微信号其实是分开的，经过我测试，如果设置了微信号之后，可能原始的wxid就会被覆盖。但是也有一些是不会被覆盖的，这个就不清楚微信是怎么处理的了。</p><a id="more"></a><h3 id="2-开始wxid的寻找之旅"><a href="#2-开始wxid的寻找之旅" class="headerlink" title="2. 开始wxid的寻找之旅"></a>2. 开始wxid的寻找之旅</h3><h4 id="1-分析"><a href="#1-分析" class="headerlink" title="1. 分析"></a>1. 分析</h4><p>当我们通过手机号码查找一个人的时候，查找出来的界面是只会显示下面的信息，不会有wxid或者微信号这样的信息。</p><p><img src="media/15537420649103/15537427751243.jpg" alt="-w160"></p><p>但是直觉告诉我，既然已经搜出来这个人，那么这个控制器里面肯定有一个包含这个人信息的对象，看一下那个对象里面的全部信息，可能会找到我想要的。所以我们的目标就是找到这个对象的控制器，然后看看里面有没有一个类似于联系人之类的对象，然后再看一下这个对象里面的属性。Let’s do it.</p><h4 id="2-探究"><a href="#2-探究" class="headerlink" title="2. 探究"></a>2. 探究</h4><blockquote><p>在探究之前如果你不清楚LLDB+DebugServer的使用可以看<a href="http://lemon2well.top/2018/07/25/iOS%20逆向/LLDB-debugserver的使用/">这里</a></p></blockquote><h5 id="2-1-首先拿出我那台祖传的iPhone，连上数据线，然后SSH登陆上去："><a href="#2-1-首先拿出我那台祖传的iPhone，连上数据线，然后SSH登陆上去：" class="headerlink" title="2.1 首先拿出我那台祖传的iPhone，连上数据线，然后SSH登陆上去："></a>2.1 首先拿出我那台祖传的iPhone，连上数据线，然后SSH登陆上去：</h5><ul><li>iTerm打开一个窗口，将本地的2222端口映射到iPhone的22端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Last login: Thu Mar 28 11:20:01 on ttys003</span><br><span class="line">LemonsMcBookPro:~ lemon$ tcprelay.py -t 22:2222</span><br><span class="line">Forwarding local port 2222 to remote port 22</span><br></pre></td></tr></table></figure><ul><li>iTerm打开另外一个窗口，通过ssh连接上去</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LemonsMcBookPro:~ lemon$ ssh root@localhost -p 2222</span><br><span class="line">lemons-iPhone5S:~ root#</span><br></pre></td></tr></table></figure><h5 id="2-2-登陆上去之后，看一下当前微信的进程ID，然后通过将debugserver挂到微信上面，然后接受来自LLDB的命令，达到动态调试微信的目的。"><a href="#2-2-登陆上去之后，看一下当前微信的进程ID，然后通过将debugserver挂到微信上面，然后接受来自LLDB的命令，达到动态调试微信的目的。" class="headerlink" title="2.2 登陆上去之后，看一下当前微信的进程ID，然后通过将debugserver挂到微信上面，然后接受来自LLDB的命令，达到动态调试微信的目的。"></a>2.2 登陆上去之后，看一下当前微信的进程ID，然后通过将debugserver挂到微信上面，然后接受来自LLDB的命令，达到动态调试微信的目的。</h5><ul><li>先在手机运行微信，然后查找微信的进程ID，然后通过debugserver监听来自1234端口的消息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LemonsMcBookPro:~ lemon$ ssh root@localhost -p 2222</span><br><span class="line">lemons-iPhone5S:~ root# ps -e | grep /var</span><br><span class="line">  632 ??         0:04.03 /usr/libexec/pkd -d/var/db/PlugInKit-Annotations</span><br><span class="line"> 1902 ??         0:11.14 /var/containers/Bundle/Application/2A191819-B0B1-41DB-813A-ED369475D3B9/NewsLite.app/NewsLite</span><br><span class="line"> 1910 ??         0:02.20 /var/containers/Bundle/Application/0841859F-B658-4A66-AB81-6B51C4A04D7B/Chain.app/Chain</span><br><span class="line"> 1991 ??         0:45.40 /var/containers/Bundle/Application/81DE6416-3F32-4C7E-BD0C-ABA1585E77E2/wework.app/wework</span><br><span class="line"> 2612 ??         2:16.97 /var/containers/Bundle/Application/5FE48592-3233-47A2-B933-C2F0CF277F14/WeChat.app/WeChat</span><br><span class="line"> 2721 ??         0:31.45 /var/containers/Bundle/Application/A7E1F925-9859-4C2C-9092-C10B719E604F/AndFetion.app/AndFetion</span><br><span class="line"> 2996 ??         0:04.00 /var/containers/Bundle/Application/06B248D3-61C9-48EC-98BF-A95BEFC782BA/WhatsApp.app/WhatsApp</span><br><span class="line"> 3392 ttys000    0:00.01 grep /var</span><br><span class="line">lemons-iPhone5S:~ root# debugserver *:1234 -a 2612</span><br><span class="line">debugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-340.3.124</span><br><span class="line"> for arm64.</span><br><span class="line">Attaching to process 2612...</span><br><span class="line">Listening to port 1234 for a connection from *...</span><br></pre></td></tr></table></figure><ul><li>此时debugserver正在监听1234端口的消息。此时我们还是通过将本地的1234端口映射到iPhone的1234端口，然后连接本地的1234端口。<br>iTerm 打开一个新窗口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Last login: Thu Mar 28 11:20:24 on ttys003</span><br><span class="line">LemonsMcBookPro:~ lemon$ tcprelay.py -t 1234:1234</span><br><span class="line">Forwarding local port 1234 to remote port 1234</span><br><span class="line">Incoming connection to 1234</span><br><span class="line">Waiting for devices...</span><br></pre></td></tr></table></figure><p>  iTerm 打开一个新窗口</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Last login: Thu Mar 28 11:31:52 on ttys005</span><br><span class="line">LemonsMcBookPro:~ lemon$ lldb</span><br><span class="line">(lldb) process connect connect://localhost:1234</span><br><span class="line">Process 2612 stopped</span><br><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = signal SIGSTOP</span><br><span class="line">    frame #0: 0x00000001819b0fd8 libsystem_kernel.dylib`mach_msg_trap + 8</span><br><span class="line">libsystem_kernel.dylib`mach_msg_trap:</span><br><span class="line">-&gt;  0x1819b0fd8 &lt;+8&gt;: ret</span><br><span class="line"></span><br><span class="line">libsystem_kernel.dylib`mach_msg_overwrite_trap:</span><br><span class="line">    0x1819b0fdc &lt;+0&gt;: mov    x16, #-0x20</span><br><span class="line">    0x1819b0fe0 &lt;+4&gt;: svc    #0x80</span><br><span class="line">    0x1819b0fe4 &lt;+8&gt;: ret</span><br><span class="line">Target 0: (WeChat) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><ul><li>此时微信的进程已经停止了，并且正在等待我们的命令。我们先输入<strong>c</strong>让进程继续。(这是LLDB的基础命令，c代表continue)</li></ul><h5 id="2-3-打开目标界面，查找目标对象"><a href="#2-3-打开目标界面，查找目标对象" class="headerlink" title="2.3 打开目标界面，查找目标对象"></a>2.3 打开目标界面，查找目标对象</h5><ul><li><p>上面我们已经将LLDB挂到微信上面了，接下来我们先搜索一个手机号，然后去到添加联系人界面。<br><img src="media/15537420649103/15537443880035.jpg" alt="-w160"></p></li><li><p>我们搜索到联系人之后，我们需要找到当前界面的控制器。下面是关键命令:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(lldb) process interrupt</span><br><span class="line">(lldb) po [[[UIApplication sharedApplication]keyWindow]recursiveDescription]</span><br><span class="line">&lt;MMUILongPressImageView: 0x140982bf0; baseClass = UIImageView; frame = (3 3; 64 64); opaque = NO; layer = &lt;CALayer: 0x14338b660&gt;&gt;</span><br><span class="line">&lt;UIImageView: 0x14337eb10; frame = (0 0; 70 70); hidden = YES; userInteractionEnabled = NO; layer = &lt;CALayer: 0x14337ecc0&gt;&gt;</span><br><span class="line">&lt;MMCPLabel: 0x1433cf8f0; baseClass = UILabel; frame = (107 0; 88 27); text = &apos;默默等待&apos;; tag = 90220; gestureRecognizers = &lt;NSArray: 0x143517010&gt;; layer = &lt;_UILabelLayer: 0x1402ac6c0&gt;&gt;</span><br><span class="line">&lt;_UILabelContentLayer: 0x143398ee0&gt; (layer)</span><br><span class="line">&lt;UIView: 0x1433e1600; frame = (304 1.5; 0 24); layer = &lt;CALayer: 0x1433e1520&gt;&gt;</span><br><span class="line">(lldb) po [0x1433cf8f0 nextResponder]</span><br><span class="line">&lt;MMUIButton: 0x143581b10; baseClass = UIButton; frame = (0 0; 320 77); opaque = NO; tag = 90221; layer = &lt;CALayer: 0x14354ff50&gt;&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [0x143581b10 nextResponder]</span><br><span class="line">&lt;UIView: 0x140982a80; frame = (0 0; 320 105); layer = &lt;CALayer: 0x143541d80&gt;&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [0x140982a80 nextResponder]</span><br><span class="line">&lt;WCStoryTableView: 0x13f5f7a00; baseClass = UITableView; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x143510ee0&gt;; layer = &lt;CALayer: 0x1433f3570&gt;; contentOffset: &#123;0, -64&#125;; contentSize: &#123;320, 504&#125;&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [0x13f5f7a00 nextResponder];</span><br><span class="line">&lt;MMUIButton: 0x1426b1960; baseClass = UIButton; frame = (0 0; 320 1136); opaque = NO; autoresize = W; gestureRecognizers = &lt;NSArray: 0x14315c0c0&gt;; layer = &lt;CALayer: 0x14093f9a0&gt;&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [0x1426b1960 nextResponder]</span><br><span class="line">&lt;UIView: 0x14354d550; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x13ef32f00&gt;&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [0x1426b1960 nextResponder];</span><br><span class="line">&lt;UIView: 0x14354d550; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x13ef32f00&gt;&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [0x14354d550 nextResponder];</span><br><span class="line">&lt;ContactInfoViewController: 0x13fc0c400&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>process interrupt</strong>: 中断当前进程<br><strong>[[[UIApplication sharedApplication]keyWindow]recursiveDescription]</strong> : 答应当前界面的信息，此时会显示所有的界面的元素。</p></blockquote><p>此时我们可以根据名字“默默等待”来找到到对应的Label，然后通过这个label的找到对应ViewController。使用nextResponder一级一级的找到对应的ViewController。通过上面的信息我们可以看到当前的ViewController是ContactInfoViewController。</p><p>#####2.4 打印对象属性。</p><ul><li>打印ContactInfoViewController的所有成员变量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [0x13fc0c400 _ivarDescription]</span><br><span class="line">&lt;ContactInfoViewController: 0x13fc0c400&gt;:</span><br><span class="line">in ContactInfoViewController:</span><br><span class="line">m_uiVerify (unsigned int): 0</span><br><span class="line">m_contact (CContact*): &lt;CSearchedContact: 0x1433b0550&gt;</span><br><span class="line">m_chatContact (CContact*): nil</span><br><span class="line">m_delegate (&lt;contactInfoDelegate&gt;*): nil</span><br><span class="line">m_InfoDelegate (&lt;ContactInfoViewControllerDelegate&gt;*): nil</span><br><span class="line">m_oContactInfoAssist (CBaseContactInfoAssist*): &lt;WeixinContactInfoAssist: 0x14331a240&gt;</span><br><span class="line">m_contactVerifyLogic (CContactVerifyLogic*): nil</span><br><span class="line">m_nsLocation (NSString*): nil</span><br><span class="line">m_bPopToRootWhenDelete (BOOL): &lt;00&gt;</span><br><span class="line">m_uiFromScene (unsigned int): 6</span><br><span class="line">m_wcOperateMode (int): 0</span><br><span class="line">m_popToViewControllerClassWhenDelete (Class): (null)</span><br><span class="line">m_searchScene (int): 0</span><br><span class="line">m_userData (id): nil</span><br><span class="line">m_clickHelper (FavClickStreamHelper*): &lt;FavClickStreamHelper: 0x14260e330&gt;</span><br><span class="line">m_CurrentWidth (double): 320</span><br><span class="line">m_forwardLogic (ForwardMessageLogicController*): nil</span><br><span class="line">_startTime (unsigned int): 1553744360</span><br><span class="line">m_sendVerifylogicVC (SendVerifyMsgLogicController*): nil</span><br><span class="line">_isFullScreenShowStory (BOOL): &lt;00&gt;</span><br><span class="line">_hasStoryData (BOOL): &lt;00&gt;</span><br><span class="line">_canShowStoryView (BOOL): &lt;01&gt;</span><br><span class="line">_isShowingStoryPreview (BOOL): &lt;00&gt;</span><br><span class="line">m_uiAddFriendStatScene (int): 0</span><br><span class="line">_m_qrCodeAddFriendScene (int): 0</span><br><span class="line">_searchFromIndex (unsigned int): 0</span><br><span class="line">_favId (unsigned int): 0</span><br><span class="line">_verifyUserInfoList (NSMutableDictionary*): nil</span><br><span class="line">_searchId (NSString*): nil</span><br><span class="line">_searchKeyword (NSString*): nil</span><br><span class="line">........</span><br></pre></td></tr></table></figure><blockquote><p>这个时候我们可以看到在最上面有一个<code>m_contact (CContact*): &lt;CSearchedContact: 0x1433b0550&gt;</code>我猜测这个应该是我们搜索出来的微信号信息的对象，我们可以试着打印一下这个对象看看。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [0x1433b0550 _ivarDescription]</span><br><span class="line">&lt;CSearchedContact: 0x1433b0550&gt;:</span><br><span class="line">in CSearchedContact:</span><br><span class="line">matchType (unsigned int): 2</span><br><span class="line">searchString (NSString*): @&quot;18575784615&quot;&lt;__NSCFString: 0x1435838e0&gt;</span><br><span class="line">in CContact:</span><br><span class="line">m_uiChatRoomStatus (unsigned int): 0</span><br><span class="line">m_nsChatRoomMemList (NSString*): nil</span><br><span class="line">m_nsChatRoomAdminList (NSString*): nil</span><br><span class="line">m_uiChatRoomAccessType (unsigned int): 0</span><br><span class="line">m_uiChatRoomMaxCount (unsigned int): 0</span><br><span class="line">m_uiChatRoomVersion (unsigned int): 0</span><br><span class="line">m_ChatRoomDetail (ChatRoomDetail*): nil</span><br><span class="line">m_nsChatRoomData (NSString*): nil</span><br><span class="line">m_ChatRoomData (ChatRoomData*): nil</span><br><span class="line">m_nsCountry (NSString*): @&quot;CN&quot;&lt;NSTaggedPointerString: 0xa00000000004e432&gt;</span><br><span class="line">m_nsProvince (NSString*): @&quot;Anhui&quot;&lt;NSTaggedPointerString: 0xa00006975686e415&gt;</span><br><span class="line">m_nsCity (NSString*): @&quot;Fuyang&quot;&lt;NSTaggedPointerString: 0xa00676e617975466&gt;</span><br><span class="line">m_nsSignature (NSString*): @&quot;&quot;&lt;__NSCFConstantString: 0x10adaff28&gt;</span><br><span class="line">m_uiCertificationFlag (unsigned int): 0</span><br><span class="line">m_nsCertificationInfo (NSString*): @&quot;&quot;&lt;__NSCFConstantString: 0x10adaff28&gt;</span><br><span class="line">m_nsOwner (NSString*): nil</span><br><span class="line">m_nsFBNickName (NSString*): nil</span><br><span class="line">m_nsFBID (NSString*): nil</span><br><span class="line">m_uiNeedUpdate (unsigned int): 0</span><br><span class="line">m_nsWCBGImgObjectID (NSString*): @&quot;0&quot;&lt;NSTaggedPointerString: 0xa000000000000301&gt;</span><br><span class="line">m_iWCFlag (int): 0</span><br><span class="line">m_pcWCBGImgID (NSString*): @&quot;&quot;&lt;__NSCFConstantString: 0x10adaff28&gt;</span><br><span class="line">m_nsExternalInfo (NSString*): @&quot;&quot;&lt;__NSCFConstantString: 0x10adaff28&gt;</span><br><span class="line">m_nsBrandSubscriptConfigUrl (NSString*): @&quot;&quot;&lt;__NSCFConstantString: 0x10adaff28&gt;</span><br><span class="line">m_uiBrandSubscriptionSettings (unsigned int): 0</span><br><span class="line">m_subBrandInfo (SubscriptBrandInfo*): &lt;SubscriptBrandInfo: 0x140936fe0&gt;</span><br><span class="line">m_nsBrandIconUrl (NSString*): @&quot;&quot;&lt;__NSCFConstantString: 0x10adaff28&gt;</span><br><span class="line">m_isExtInfoValid (BOOL): &lt;01&gt;</span><br><span class="line">externalInfoJSONCache (NSDictionary*): nil</span><br><span class="line">m_isShowRedDot (BOOL): &lt;00&gt;</span><br><span class="line">m_nsMobileHash (NSString*): nil</span><br><span class="line">m_nsMobileFullHash (NSString*): nil</span><br><span class="line">m_nsLinkedInID (NSString*): nil</span><br><span class="line">m_nsLinkedInName (NSString*): nil</span><br><span class="line">m_nsLinkedInPublicUrl (NSString*): nil</span><br><span class="line">m_uiDeleteFlag (unsigned int): 0</span><br><span class="line">m_nsDescription (NSString*): nil</span><br><span class="line">m_nsCardUrl (NSString*): nil</span><br><span class="line">m_nsWorkID (NSString*): nil</span><br><span class="line">m_nsLabelIDList (NSString*): nil</span><br><span class="line">m_arrPhoneItem (NSArray*): &lt;__NSArrayM: 0x1433d60a0&gt;</span><br><span class="line">m_lockForChatRoomData (NSRecursiveLock*): &lt;NSRecursiveLock: 0x1406dada0&gt;</span><br><span class="line">_appBrandInfo (CAppBrandInfo*): nil</span><br><span class="line">_m_bFromNewDB (BOOL): &lt;01&gt;</span><br><span class="line">_m_hasNewBizMsg (BOOL): &lt;00&gt;</span><br><span class="line">_m_uiLastUpdate (unsigned int): 0</span><br><span class="line">_m_uiMetaFlag (unsigned int): 0</span><br><span class="line">_m_uiDebugModeType (unsigned int): 0</span><br><span class="line">_m_uiWxAppOpt (unsigned int): 0</span><br><span class="line">_uiLastUpdateAppVersionInfoTime (unsigned int): 0</span><br><span class="line">openIMAppid (NSString*): nil</span><br><span class="line">openIMInfo (COpenIMInfo*): nil</span><br><span class="line">_m_dicWeiDianInfo (NSDictionary*): nil</span><br><span class="line">_m_nsWeiDianInfo (NSString*): nil</span><br><span class="line">in CBaseContact:</span><br><span class="line">m_nsUsrName (NSString*): @&quot;v1_81f423f663f69d690124bb98c81aade8c47642dfb41842bb2bdfd85907d912df04b2f31b8f910255577a8cde8dc835d4@stranger&quot;&lt;__NSCFString: 0x1434c5630&gt;</span><br><span class="line">m_nsEncodeUserName (NSString*): nil</span><br><span class="line">m_nsAliasName (NSString*): @&quot;yao1054057455&quot;&lt;__NSCFString: 0x1432f4c60&gt;</span><br><span class="line">m_uiConType (unsigned int): 0</span><br><span class="line">m_nsNickName (NSString*): @&quot;默默等待&quot;&lt;__NSCFString: 0x1434b18c0&gt;</span><br><span class="line">m_nsFullPY (NSString*): @&quot;wxid0rxnvbwkf1n512132&quot;&lt;__NSCFString: 0x14324d5f0&gt;</span><br><span class="line">m_nsShortPY (NSString*): @&quot;mmdd&quot;&lt;__NSCFString: 0x143526120&gt;</span><br><span class="line">m_nsRemark (NSString*): nil</span><br><span class="line">m_nsRemarkPYShort (NSString*): nil</span><br><span class="line">m_nsRemarkPYFull (NSString*): nil</span><br><span class="line">m_nsDisplayNamePY (NSString*): nil</span><br><span class="line">m_uiSex (unsigned int): 2</span><br><span class="line">m_uiType (unsigned int): 0</span><br><span class="line">m_uiChatState (unsigned int): 0</span><br><span class="line">m_dtUsrImg (NSData*): nil</span><br><span class="line">m_nsImgStatus (NSString*): @&quot;IMG_HAS&quot;&lt;__NSCFConstantString: 0x104085c48&gt;</span><br><span class="line">m_nsHDImgStatus (NSString*): nil</span><br><span class="line">m_nsHeadImgUrl (NSString*): @&quot;http://wx.qlogo.cn/mmhead/ver_1/x0enJ9WJoJ9lSdibxAk8ukuriaLjBphAFdnAfib9pLM6fZXJclib1uyenjSr3fUdVSBOAfdlAAyrs8JhSbbOatpRUTgeqO4ReTkNG9ahRpJJHms/132&quot;&lt;__NSCFString: 0x1426bc500&gt;</span><br><span class="line">m_nsHeadHDImgUrl (NSString*): @&quot;http://wx.qlogo.cn/mmhead/ver_1/x0enJ9WJoJ9lSdibxAk8ukuriaLjBphAFdnAfib9pLM6fZXJclib1uyenjSr3fUdVSBOAfdlAAyrs8JhSbbOatpRUTgeqO4ReTkNG9ahRpJJHms/0&quot;&lt;__NSCFString: 0x14354d710&gt;</span><br><span class="line">m_nsHeadHDMd5 (NSString*): nil</span><br><span class="line">m_nsDraft (NSString*): nil</span><br><span class="line">m_uiDraftTime (unsigned int): 0</span><br><span class="line">m_nsAtUserList (NSString*): nil</span><br><span class="line">m_uiQQUin (unsigned int): 0</span><br><span class="line">m_nsMobileIdentify (NSString*): nil</span><br><span class="line">m_uiFriendScene (unsigned int): 15</span><br><span class="line">m_uiImgKey (unsigned int): 0</span><br><span class="line">m_uiExtKey (unsigned int): 0</span><br><span class="line">m_uiImgKeyAtLastGet (unsigned int): 0</span><br><span class="line">m_uiExtKeyAtLastGet (unsigned int): 0</span><br><span class="line">m_hasDetectPlugin (BOOL): &lt;01&gt;</span><br><span class="line">m_isPlugin (BOOL): &lt;00&gt;</span><br><span class="line">m_hasDetectSelf (BOOL): &lt;01&gt;</span><br><span class="line">m_isSelf (BOOL): &lt;00&gt;</span><br><span class="line">m_nsAntispamTicket (NSString*): @&quot;v2_2e4d1f9deb2d50cec867afc7481db2adc7bf821f79562b66d83225ae2338039a7abd1160dcc4a7122640fb42e0784801@stranger&quot;&lt;__NSCFString: 0x143539fe0&gt;</span><br><span class="line">_externalInfoJSONCache (NSDictionary*): nil</span><br><span class="line">in NSObject:</span><br><span class="line">isa (Class): CSearchedContact (isa, 0x81a104c3d59d)</span><br></pre></td></tr></table></figure><p>结果没有让我们失望，到这里已经看到了m_nsFullPY这个属性包含的就是wxid。这次逆向很简单，都没有用到静态分析看汇编代码等方法，直接就能实现我们想做的。</p><p>最后有个小tips，一般通过wxid是加不了好友的，但是在wxid前面加几个汉字可以搜索到好友哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这段时间在忙着新版本SDK的开发，也在准备换工作的事情，虽然现在是“寒潮”，但是还是想走出舒适区，去感受一下春天的“寒冷”。也很久没有接触逆向方面的工作了，昨天一个大学同学问我，能不能通过一个人的手机号以及微信号找到那个人对应的wxid，其实我也不清楚，但是我们来尝试一下找一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-wxid-是什么？&quot;&gt;&lt;a href=&quot;#1-wxid-是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. wxid 是什么？&quot;&gt;&lt;/a&gt;1. wxid 是什么？&lt;/h3&gt;&lt;p&gt;wxid是顾名思义就是微信的ID，也就是一个手机号码刚注册的时候，微信给予用户的一个初始化ID，这个和后面的微信号其实是分开的，经过我测试，如果设置了微信号之后，可能原始的wxid就会被覆盖。但是也有一些是不会被覆盖的，这个就不清楚微信是怎么处理的了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 逆向" scheme="http://lemon2well.top/categories/iOS-%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS中常见的八种锁</title>
    <link href="http://lemon2well.top/2018/10/31/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%AB%E7%A7%8D%E9%94%81/"/>
    <id>http://lemon2well.top/2018/10/31/iOS 开发/iOS中常见的八种锁/</id>
    <published>2018-10-31T03:19:26.000Z</published>
    <updated>2018-10-31T03:19:52.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要锁"><a href="#为什么需要锁" class="headerlink" title="为什么需要锁"></a>为什么需要锁</h2><p>在iOS中相信大家都用过多线程，多线程带来的好处显而易见，但是我们需要关注一下多线程有可能带来的问题。假设我们有一个这样的场景，我们有两条线程A和线程B，A线程做的事情是修改这个对象之后读取这个对象的数据，这个时候B线程可能也在修改这个对象。这个时候有两种情况（取决于B线程修改对象的时机）：</p><blockquote><ol><li>正常的情况，A线程修改对象以及读取对象之后，B线程才开始修改这个对象。</li><li>异常的情况，A线程修改对象之后，B线程立刻修改了这个帝乡，然后A线程读取对象。这个时候A线程读取到的数据就出错了。</li></ol></blockquote><p>这就是我们常说的Data race，当两个线程同时在访问修改同一个块内存的时候，就有可能得到意想不到的结果。</p><a id="more"></a><p>基于上面的前提，我们在出现了用<code>锁</code>来解决问题的方法。下面我们就来说说iOS中的锁。</p><p>在ibireme写的<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的OSSpinLock</a>中给出了常用的锁的性能如下所示：</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15407991692950.png" alt=""></p><p>在解释下面的锁之前，我们先说说两种类型的锁，一种是自旋锁，一种是互斥锁。</p><h2 id="按照功能来区分锁"><a href="#按照功能来区分锁" class="headerlink" title="按照功能来区分锁"></a>按照功能来区分锁</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><blockquote><p><code>互斥锁</code>是为了保护一个临界区或者资源不能同时被多个小城访问。当临界区加上互斥锁以后，其他的调用方不能获得锁，只有当互斥锁的持有方释放锁之后其他调用方才能获得锁。<br>如果调用方在获得锁的时候发现<code>互斥锁</code>已经被其他方持有，那么该调用方只能进入睡眠状态，这样不会占用CPU资源。但是会有时间的消耗，系统的运行时基于CPU时间调度的，每次线程可能有100ms的运行时间，频繁的CPU切换也会消耗一定的时间。</p></blockquote><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><blockquote><p><code>自旋锁</code>和互斥锁相似，但是自旋锁不会引起休眠,当自旋锁被别的线程锁定的时候，那么调用方会一直处于等待的状态，用一种生活化的例子来说就像是上厕所，当你要上厕所发现里面已经有人的时候，你就会一直等在外面，直到他出来你就立刻抢占厕所。<br>由于调用方会一直循环看该自旋锁的的保持者是否已经释放了资源，所以总的效率来说比互斥锁高。但是自旋锁只用于短时间的资源访问，如果不能短时间内获得锁，就会一直占用着CPU，造成效率低下。</p></blockquote><h2 id="常见的锁的类型"><a href="#常见的锁的类型" class="headerlink" title="常见的锁的类型"></a>常见的锁的类型</h2><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><p><code>OSSpinLock</code>是自旋锁，也正是由于它是自旋锁，所以容易发生优先级反转的问题。在ibireme的文章中已经写到，当一个低优先级线程获得锁的时候，如果此时一个高优先级的系统到来，那么会进入忙等状态，不会进入睡眠，此时会一直占用着系统CPU时间，导致低优先级的无法拿到CPU时间片，从而无法完成任务也无法释放锁。除非能保证访问锁的线程全部处于同一优先级，否则系统所有的自旋锁都会出现优先级反转的问题。现在苹果的<code>OSSpinLock</code>已经被替换成<code>os_unfair_lock</code><br><code>typedef int32_t OSSpinLock OSSPINLOCK_DEPRECATED_REPLACE_WITH(os_unfair_lock);</code></p><h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><p><code>dispatch_semaphore</code>主要提供了三个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_create(long value);//创造信号量</span><br><span class="line">dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout); //等待信号</span><br><span class="line">dispatch_semaphore_signal(dispatch_semaphore_t dsema);//发送信号</span><br></pre></td></tr></table></figure><p><code>dispatch_semaphore</code>是GCD用来同步的一种方式，<code>dispatch_semephore_create</code>方法用户创建一个<code>dispatch_semephore_t</code>类型的信号量，初始的参数必须大于0，该参数用来表示该信号量有多少个信号，简单的说也就是同事允许多少个线程访问。<br><code>dispatch_semaphore_wait()</code>方法是等待一个信号量，该方法会判断signal的信号值是否大于0，如果大于0则不会阻塞线程，消耗点一个信号值，执行后续任务。如果信号值等于0那么就和NSCondition一样，阻塞当前线程进入等待状态，如果等待时间未超过timeout并且<code>dispatch_semaphore_signal</code>释放了了一个信号值，那么就会消耗掉一个信号值并且向下执行。如果期间一直不能获得信号量并且超过超时时间，那么就会自动执行后续语句。</p><h3 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread-mutex"></a>pthread-mutex</h3><blockquote><p><code>pthread-mutex</code>是互斥锁，互斥锁与信号量的机制非常相似，不会处于忙等状态，而是会阻塞线程并休眠。</p></blockquote><p><code>pthread-mutex</code>提供了几个常用的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_init(pthread_mutex_t * __restrict, const pthread_mutexattr_t * __restrict);//初始化锁</span><br><span class="line">int pthread_mutex_lock(pthread_mutex_t *); //加锁</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t *); //解锁</span><br></pre></td></tr></table></figure><p><code>pthread_mutex_init</code>方法用来初始化一个锁，需要传入一个pthread_mutex_t的对象，并且需要设置互斥锁的类型。互斥锁有四种类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PTHREAD_MUTEX_NORMAL : 默认值普通锁，当一个线程加锁以后，其他线程进入按照优先顺序进入等待队列，并且解锁的时候按照先入先出的方式获得锁。</span><br><span class="line">PTHREAD_MUTEX_ERRORCHECK : 检错锁，当同一个线程获得同一个锁的时候，则返回EDEADLK，否则与普通锁处理一样。</span><br><span class="line">PTHREAD_MUTEX_RECURSIVE : 递归锁。这里有别于上面的检错锁，同一个线程可以递归获得锁，但是加锁和解锁必须要一一对应。</span><br><span class="line">PTHREAD_MUTEX_DEFAULT : 适应锁，等待解锁之后重新竞争，没有等待队列。</span><br></pre></td></tr></table></figure><h3 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h3><p><code>NSLock</code>遵循<code>NSLocking</code>协议，同时也是互斥锁，提供了lock和unlock方法来进行加锁和解锁。<br><code>NSLock</code>内部是封装了<code>pthread_mutext</code>，类型是<code>PTHREAD_MUTEXT_ERRORCHECK</code>，它会损失一定的性能换来错误提示。</p><h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h3><p><code>NSCondition</code>是封装了一个互斥锁和信号量，它把前者的lock以及后者的wait/signal统一到<code>NSCondition</code>对象中，是基于条件变量<code>pthread_cond_t</code>来实现的，和信号量相似，如果当前线程不满足条件，那么就会进入睡眠状态，等待其他线程释放锁或者释放信号之后，就会唤醒线程。类似于生产者和消费者模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">NSCondition *lock = [[NSCondition alloc] init];</span><br><span class="line">    NSMutableArray *array = [[NSMutableArray alloc] init];</span><br><span class="line">    //消费者</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        while (!array.count) &#123;</span><br><span class="line">            [lock wait];</span><br><span class="line">        &#125;</span><br><span class="line">        [array removeAllObjects];</span><br><span class="line">        NSLog(@&quot;array removeAllObjects&quot;);</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //生产者</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        sleep(1);//以保证让线程2的代码后执行</span><br><span class="line">        [lock lock];</span><br><span class="line">        [array addObject:@1];</span><br><span class="line">        NSLog(@&quot;array addObject:@1&quot;);</span><br><span class="line">        [lock signal];</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h3><blockquote><p><code>NSRecursiveLock</code>实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中</p></blockquote><p><code>NSRecursiveLock</code>内部是通过pthread_mutex_lock来实现的，在内部会判断锁的类型，如果是递归锁，就允许递归调用，内部仅仅是将计数器+1。当调用unlock的时候，就将计数器减1。NSRecursiveLock内部使用的pthread_mutex_t的类型是<code>PTHREAD_MUTEXT_RECURSIVE</code></p><h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><p><code>NSConditonLock</code> 是借助NSCondition，本质上是生产者-消费者模式，<code>NSConditonLock</code>内部持有了一个<code>NSCondition</code>对象和<code>_condition_value</code>属性，当调用<code>- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;</code>初始化的时候会传入一个condition参数，该参数会赋值<code>_condition_value</code>属性。</p><ul><li><p>在<code>NSConditionLock</code>r中，对应的消费者就是<code>- (void)lockWhenCondition:(NSInteger)condition;</code>方法，首先会调用[condition lock]，然后开始进入阻塞状态，如果condition=_condition_value，那么就会休眠，直到代码调用<code>- (void)unlockWithCondition:(NSInteger)condition;</code>才会唤起</p></li><li><p><code>- (void)unlockWithCondition:(NSInteger)condition;</code>就是对应的生产者方法，内部会设置condition=_contion_value，并且发送广播告诉所有的消费者，表示生产完成，然后调用[condition unlock]释放锁。</p></li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><p>@synchronized是OC层面上的锁，是所有的锁之中性能最差的。<br>@synchronized后面紧跟一个OC对象，实际上是将这个对象当做锁来使用。这是通过一个哈希表来实现的，OC在底层维护了一个互斥锁的数组，通过对象的哈希值去得到对象的互斥锁。<br>具体的实现原理可以参考萧玉大神的这篇文章: <a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">关于 @synchronized，这儿比你想知道的还要多</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的分析我们知道锁的性能由高到低分别是<br><code>OSSpinLock(已经不推荐使用)</code>-&gt;<code>dispatch_semaphore</code>-&gt;<code>pthread_mutext</code>-&gt;<code>NSLock</code>-&gt;<code>NSCondition</code>-&gt;<code>NSRecursiveLock</code>-&gt;<code>NSConditonLock</code>-&gt;<code>@synchronized</code></p><p>我们再来梳理一下它们的关系：</p><ol><li><code>dipatch_semaphore</code>是GCD同步的一种方式，通过dispatch_semaphore_t信号量来实现。<br>2.<code>pthread_mutex</code>是互斥锁，提供了四种不同类型，不会像自旋锁一样忙等，而是会进入休眠等待。<br>3.<code>NSLock</code>是封装了<code>prthread_mutex</code>，锁的类型是<code>PTHREAD_MUTEX_ERRORCHECK</code>，也就是当同一个线程获得同一个锁的时候，会返回错误。<br>4.<code>NSCondition</code>是基于条件变量<code>pthread_cond_t</code>实现的，和信号量相似，当不满足条件的时候就会进入休眠等待，知道condition对象发出signal信号，才会被唤醒执行。<br>5.<code>NSRecursiveLock</code>是递归锁，同样是封装了<code>pthread_mutex</code>来实现，但是锁的类型是<code>PTHREAD_MUTEX_RECURSIVE</code>，允许统一递归获得锁，但是要注意加锁和解锁要一一对应。<br>6.<code>NSConditionLock</code>是基于<code>NSCondition</code>实现的，同样也是生产者和消费者模式。<br>7.<code>@synchronized</code>是OC层面的锁，传入一个OC对象，通过对象的哈希值来作为标识符得到互斥锁，存入到一个数组里面。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/57f6e9f85bbb50005b126e5f" target="_blank" rel="noopener">深入理解iOS中的锁</a><br><a href="https://www.jianshu.com/p/938d68ed832c" target="_blank" rel="noopener">iOS中保证线程安全的几种方式与性能对比</a><br><a href="https://www.jianshu.com/p/ddbe44064ca4" target="_blank" rel="noopener">iOS 常见知识点（三）：Lock</a><br><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的OSSpinLock</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么需要锁&quot;&gt;&lt;a href=&quot;#为什么需要锁&quot; class=&quot;headerlink&quot; title=&quot;为什么需要锁&quot;&gt;&lt;/a&gt;为什么需要锁&lt;/h2&gt;&lt;p&gt;在iOS中相信大家都用过多线程，多线程带来的好处显而易见，但是我们需要关注一下多线程有可能带来的问题。假设我们有一个这样的场景，我们有两条线程A和线程B，A线程做的事情是修改这个对象之后读取这个对象的数据，这个时候B线程可能也在修改这个对象。这个时候有两种情况（取决于B线程修改对象的时机）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;正常的情况，A线程修改对象以及读取对象之后，B线程才开始修改这个对象。&lt;/li&gt;
&lt;li&gt;异常的情况，A线程修改对象之后，B线程立刻修改了这个帝乡，然后A线程读取对象。这个时候A线程读取到的数据就出错了。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是我们常说的Data race，当两个线程同时在访问修改同一个块内存的时候，就有可能得到意想不到的结果。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS动手实现KVO</title>
    <link href="http://lemon2well.top/2018/10/10/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0KVO/"/>
    <id>http://lemon2well.top/2018/10/10/iOS 开发/iOS动手实现KVO/</id>
    <published>2018-10-10T07:11:44.000Z</published>
    <updated>2018-10-10T07:16:26.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是KVO"><a href="#什么是KVO" class="headerlink" title="什么是KVO"></a>什么是KVO</h2><blockquote><p>KVO(key-value observing)是观察者模式的一种实现，通过监听对象的某一个属性，当属性的值发生改变的时候，监听者会获得通知。</p></blockquote><h2 id="KVO的使用以及缺点"><a href="#KVO的使用以及缺点" class="headerlink" title="KVO的使用以及缺点"></a>KVO的使用以及缺点</h2><p>我们来看一下是如何使用系统的KVO的。<br>系统提供了三个重要的方法，一个是设置监听，一个是监听回调，另外一个是移除监听。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0));</span><br></pre></td></tr></table></figure><p>怎么使用我就不说了，我来说说系统的KVO的缺点。</p><ol><li>当一个观察者监听了很多对象的时候，所有的回调方法都在一个地方处理，这样就要做很多的判断来根据不同的对象不同的属性来做相应的响应。</li><li>没有提供<code>@selector</code>的形式以及<code>block</code>的形式，而且还要处理父类的情况，如果父类同样也监听了对象的同一属性，你不知道父类是否对这个消息感兴趣，还要根据context来处理，这样显得很混乱。</li></ol><h2 id="KVO的实现"><a href="#KVO的实现" class="headerlink" title="KVO的实现"></a>KVO的实现</h2><p>基于以上的缺点考虑，我们想自己实现一个KVO，并且以block的形式进行回调，那么我们首先要知道KVO的实现原理。</p><p>在苹果的开发者网站上面有透露了KVO的实现，虽然没有透露内部的细节，但是我们也可以知道一个大概。</p><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling.<br>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.<br>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.<br>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p></blockquote><p>上面的话翻译过来就是KVO的实现是基于一个叫做isa-swizzling的技术，也就是改变isa的指针，我们知道每个对象都有一个isa指针指向他的类，后面调用方法的时候根据isa指针找到对应的类然后调用相应的方法。当一个对象被注册监听的时候，系统会创建一个该对象所属的类的子类，然后修改子类的setter方法，该setter方法里面会调用父类的setter实现，然后实现通知告诉观察者。最后改变该对象的isa指针，指向我们自定义的kvo类。最后当我们给一个属性赋值的时候，其实调用的setter方法应不是原来的类的setter，而是系统创建的kvo子类。</p><p>基于以上的原理，我们来开始动手实现一个通过block回调的kvo</p><h2 id="实现带有block的KVO"><a href="#实现带有block的KVO" class="headerlink" title="实现带有block的KVO"></a>实现带有block的KVO</h2><p>我们创建一个NSObject的category，然后向外面提供两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^lmObserveBlock)(id observer, NSString *key ,id oldValue, id newValue);</span><br><span class="line"></span><br><span class="line">@interface NSObject (LMKVO)</span><br><span class="line">- (void)lm_AddObserver:(id)observer</span><br><span class="line">                  key:(NSString *)key</span><br><span class="line">         observeBlock:(lmObserveBlock)block;</span><br><span class="line"></span><br><span class="line">- (void)lm_removeObserver:(id)observer</span><br><span class="line">                   key:(NSString*)key;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>我们首先来看看添加监听的方法：</p><p>下面的代码主要做了下面四件事：</p><blockquote><ol><li>判断对象的类是否存在setter方法，不存在的话则直接返回</li><li>判断对象的isa指针指向的类是否是kvo类，不是的话就通过objc_allocateClassPair()以及objc_registerClassPair()两个主要方法来注册一个kvo类，修改对象的isa指针。</li><li>判断kvo类是否已经存在setter方法，不存在的话则创建setter方法.</li><li>通过obj_getAssociatedObject以及objc_setAssociatedObject来动态给分类增加一个array的属性，通过该属性保存所有的obverve信息，以便后面属性值发生改变的时候调用。</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)lm_AddObserver:(id)observer</span><br><span class="line">                   key:(NSString *)key</span><br><span class="line">          observeBlock:(lmObserveBlock)block&#123;</span><br><span class="line">    SEL selForSetter = NSSelectorFromString([self setterName:key]);</span><br><span class="line">    Method setterMethod = class_getInstanceMethod([self class], selForSetter);</span><br><span class="line">    //lei判断如果父类不存在setter方法，那么直接返回</span><br><span class="line">    if (!setterMethod) &#123;</span><br><span class="line">        NSLog(@&quot;父类方法不存在setter&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断对象的isa指针指向的类是否是kvo，如果不是则创建该类的子类，并且将对象的isa指向该子类。</span><br><span class="line">    Class class = object_getClass(self);</span><br><span class="line">    NSString *className = NSStringFromClass(class);</span><br><span class="line">    </span><br><span class="line">    if (![className hasPrefix:LMKVOPREFIX]) &#123;</span><br><span class="line">        //创建一个新的类并且修改isa指针</span><br><span class="line">        class = [self makeNewClassWithClassName:className];</span><br><span class="line">        object_setClass(self, class);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //判断新创建的类是否已经实现了setter方法，如果没有则创建新的setter方法</span><br><span class="line">    if (![self hasSelector:selForSetter]) &#123;</span><br><span class="line">        const char *types = method_getTypeEncoding(setterMethod);</span><br><span class="line">        class_addMethod(class, selForSetter, (IMP)kvo_setter, types);</span><br><span class="line">    &#125;</span><br><span class="line">    //保存observerInfo</span><br><span class="line">    LMObserverInfo *info = [[LMObserverInfo alloc] initWithObserver:observer key:key block:block];</span><br><span class="line">    NSMutableArray *observers = objc_getAssociatedObject(self,(__bridge const void * _Nonnull)(LMKVOAssociatedObservers));</span><br><span class="line">    if (!observers) &#123;</span><br><span class="line">        observers = [NSMutableArray array];</span><br><span class="line">        objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(LMKVOAssociatedObservers), observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    if ([self containsSameObserver:observer key:key]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [observers addObject:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来看一下移除监听的方法实现：</p><p>这里就是在我们之前保存的数组中找到对应的observe和key，然后移除相应的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)lm_removeObserver:(id)observer</span><br><span class="line">                   key:(NSString*)key&#123;</span><br><span class="line">    NSMutableArray *observers = objc_getAssociatedObject(self,(__bridge const void * _Nonnull)(LMKVOAssociatedObservers));</span><br><span class="line">    LMObserverInfo *specialInfo = [self containsSameObserver:observer key:key];</span><br><span class="line">    if (specialInfo) &#123;</span><br><span class="line">        [observers removeObject:specialInfo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的逻辑很简单，看看demo就一目了然了。<br>这里是[demo][<a href="https://github.com/codemonkeybulucck/LMKVOTool]" target="_blank" rel="noopener">https://github.com/codemonkeybulucck/LMKVOTool]</a></p><p>参考：<a href="https://github.com/okcomp/ImplementKVO" target="_blank" rel="noopener">ImplementKVO</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是KVO&quot;&gt;&lt;a href=&quot;#什么是KVO&quot; class=&quot;headerlink&quot; title=&quot;什么是KVO&quot;&gt;&lt;/a&gt;什么是KVO&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;KVO(key-value observing)是观察者模式的一种实现，通过监听对象的某一个属性，当属性的值发生改变的时候，监听者会获得通知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;KVO的使用以及缺点&quot;&gt;&lt;a href=&quot;#KVO的使用以及缺点&quot; class=&quot;headerlink&quot; title=&quot;KVO的使用以及缺点&quot;&gt;&lt;/a&gt;KVO的使用以及缺点&lt;/h2&gt;&lt;p&gt;我们来看一下是如何使用系统的KVO的。&lt;br&gt;系统提供了三个重要的方法，一个是设置监听，一个是监听回调，另外一个是移除监听。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="kvo" scheme="http://lemon2well.top/tags/kvo/"/>
    
  </entry>
  
  <entry>
    <title>atomic是不是线程安全的</title>
    <link href="http://lemon2well.top/2018/09/30/iOS%20%E5%BC%80%E5%8F%91/atomic%E6%98%AF%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84/"/>
    <id>http://lemon2well.top/2018/09/30/iOS 开发/atomic是不是线程安全的/</id>
    <published>2018-09-30T08:01:01.000Z</published>
    <updated>2018-09-30T08:07:17.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><p>我们先来看看什么叫做线程安全。</p><blockquote><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。</p></blockquote><a id="more"></a><h2 id="atomic不安全？"><a href="#atomic不安全？" class="headerlink" title="atomic不安全？"></a>atomic不安全？</h2><p>OK，接下来我们来看看一段经典的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic,copy) NSString *name;</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        @synchronized(self)&#123;</span><br><span class="line">            for (int i = 0; i&lt;100; i++) &#123;</span><br><span class="line">                self.name = @&quot;lemon&quot;;</span><br><span class="line">                NSLog(@&quot;线程A ： %@&quot;,self.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        @synchronized(self)&#123;</span><br><span class="line">            for (int i = 0; i&lt;100; i++) &#123;</span><br><span class="line">                self.name = @&quot;well&quot;;</span><br><span class="line">                NSLog(@&quot;线程B ： %@&quot;,self.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>我们定义了一个atomic的name属性，然后我们在两个线程里面分别修改了这个属性的值，按照上面的定义，我们的设想应该是：线程A后面的一定是lemon，线程B后面的一定是well，但是结果是线程A后面跟着的是lemon或者well，线程B打印的是lemon或者well。也就是说取值是不确定的，基于上面的结果，大多数人认为<strong>atomic是不安全的</strong>。But这不是这篇文章的结论。</p><h2 id="atomic-是安全的"><a href="#atomic-是安全的" class="headerlink" title="atomic 是安全的"></a>atomic 是安全的</h2><p>我们来关注一下atomic，atomic是原子属性，什么是原子属性呢？</p><p><code>狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完（理论上拥有CPU时间片无限长）。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现，但一句高级语言的代码却不是原子的，因为它最终是由多条汇编语言完成，CPU在进行时间片切换时，大多都会在某条代码的执行过程中。但在多核处理器下，则需要硬件支持</code></p><p>在<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-723</a>中我们可以看到atomic的实现，利用了TLS(Thread-Local Storage)局部线程存储实现了原子属性，这里用了最重要的两个函数:<code>pthread_setspecific</code>以及<code>pthread_getspecific</code>。也就是说atomic是安全的。</p><p>这里就有矛盾了，为什么上面说atomic是线程不安全的，这里又说是安全的，Excuse me?</p><p>或许我们换一种说法，atomic是线程安全的，但是不能保证指向的对象是线程安全的。怎么解释这句话呢？</p><p>也就是大家常说的，atomic只对getter和setter加锁，而没有办法保证对象的数据完整性。</p><blockquote><p>我们要明白一个概念，当我们访问name的时候，其实这里我们访问的有可能是name本身，也有可能是name指向的内存地址。<br>比如 <code>self.name = @&quot;lemon&quot;</code>是在访问指针本身，这个是受atomic保护的。<br>而<code>[self.name rangOfString:@&quot;lemon&quot;]</code>是在访问name指向的字符串所在的内存区域，atomic无法保证访问指向的内容的读写安全。这是不一样的概念。</p></blockquote><p>我们来看一下以下的示例来说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) NSMutableString *name;</span><br><span class="line">//注意这里用的是NSMutableString</span><br><span class="line"></span><br><span class="line"> self.name = [NSMutableString string]; //ThreadA</span><br><span class="line"> [self.name appendString:@&quot;ddd&quot;];//ThreadB</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们线程A对name做了初始化操作，然后我们线程B做了赋值操作。系统为我们分配的地址是0x192838452，然后我们需要将这个地址写到name这里，假设写到一半的时候，B开始读取name并且赋值了，这个时候拿到的可能是一个0x19283000，那这个时候就有问题了，我们拿到的地址根本不是我们想要的，最好的情况这是一个野指针不会造成任何问题，但是如果这一块区域是系统的某一个关键的地方，要是被我们不小心给改了那可能问题就有点大了。</p><p>如果在上面的示例中我们将nonatomic改成atomic，那么就能保证将0x192838452这个值写到name里面的时候不会有另外一条线程来读取它，也就能保证保证读取出来的值是正确的，而不会是其他异常的值。</p><p>所以atomic的工作就是保护name这个指针的读写操作不会同时进行。至于name指向的内容，则不在atomic保护的范围之内。所以我们其实是有点误解atomic，以为它是可以保护name指向的内存地址的内容完整性。<code>其实这并不是它的工作</code></p><h2 id="线程安全如何实现？"><a href="#线程安全如何实现？" class="headerlink" title="线程安全如何实现？"></a>线程安全如何实现？</h2><p>这里我们首先要说两个概念：</p><p>第一个是上面说的<code>原子性</code><br>第二个是<code>CPU时间片轮转算法</code>：</p><blockquote><p>现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片，如果线程在时间片结束前阻塞或结束，则CPU当即进行切换。由于线程切换需要时间，如果时间片太短，会导致大量CPU时间浪费在切换上；而如果这个时间片如果太长，会使得其它线程等待太久。</p></blockquote><p>然后我们要明确一下，哪几种情况是线程安全的：</p><ol><li>如果线程是串行访问内存，那么是线程安全的。</li><li>如果操作是原子性的，那么也是线程安全的。</li></ol><p>所以在多线程的情况下，我们只要做到原子性，那么就可以保证线程安全。那么我们如何做到原子性呢？</p><ol><li>64位系统的地址总线对于读写指令可以支持8个字节的长度，所以我们常见的char,int,long 这些比较小的数据类型，一定是原子性的，所以这些数据类型一定不会有两个线程同时读写操作。</li><li>如果是常见的对象类型，那么就需要在上层加锁来处理了，原子性其实也是可以根据对象来分为大粒度和小粒度的，也就是说我们可以通过锁把一系列的操作先执行完成，然后再释放锁。</li></ol><p>在最开始的例子中，我们可以通过@synchronized来实现。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       @synchronized(self)&#123;</span><br><span class="line">           for (int i = 0; i&lt;100; i++) &#123;</span><br><span class="line">               self.name = @&quot;lemon&quot;;</span><br><span class="line">               NSLog(@&quot;线程A ： %@&quot;,self.name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       @synchronized(self)&#123;</span><br><span class="line">           for (int i = 0; i&lt;100; i++) &#123;</span><br><span class="line">               self.name = @&quot;well&quot;;</span><br><span class="line">               NSLog(@&quot;线程B ： %@&quot;,self.name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>不过根据<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的osspinlock</a>一文中，说到，使用@synchronized的性能是最低的，所以我们获取可以考虑使用<br>dispatch_semaphore_t来处理。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>atomic是线程安全的，但是它不能保证指针指向的地址也是线程安全的。在我们一开始写的例子中，它其实是不能决定哪条线程先执行，但是它已经保证了结果一定是well或者lemon，而不是其他的字符，这就是它起的作用。至于要保证上层读写统一的话，那就是需要用锁来解决了。</p><p>最后，国庆快乐！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是线程安全&quot;&gt;&lt;a href=&quot;#什么是线程安全&quot; class=&quot;headerlink&quot; title=&quot;什么是线程安全&quot;&gt;&lt;/a&gt;什么是线程安全&lt;/h2&gt;&lt;p&gt;我们先来看看什么叫做线程安全。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。&lt;br&gt;或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="atomic" scheme="http://lemon2well.top/tags/atomic/"/>
    
      <category term="锁" scheme="http://lemon2well.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的load和initialize方法</title>
    <link href="http://lemon2well.top/2018/09/11/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E7%9A%84load%E5%92%8Cinitialize%E6%96%B9%E6%B3%95/"/>
    <id>http://lemon2well.top/2018/09/11/iOS 开发/iOS中的load和initialize方法/</id>
    <published>2018-09-11T03:21:13.000Z</published>
    <updated>2018-09-11T03:21:32.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道在NSObject中有两个初始化的方法，<code>+(void)load</code>以及<code>+ (void)initialize</code>方法，这两个方法都是由系统来自动调用，不需要我们手动来调用，我们经常会在这两个方法的内部做一些magic的事情。</p><p>下面我们首先对这两个方法做一个初步的使用，看看他们两的调用时机以及异同。</p><p><strong>当然如果已经知道了他们的异同以及调用顺序的可以直接看总结或者源码分析</strong></p><a id="more"></a><h2 id="调用时机以及调用策略"><a href="#调用时机以及调用策略" class="headerlink" title="调用时机以及调用策略"></a>调用时机以及调用策略</h2><p>我们创建一个xcode工程，然后建立了一个person类，以及一个student类，student类继承于person类，person类里面有一个sayHello的类方法，然后我们创建了一个分类，Student(Extension),我们分别在这三个类下面重写了<code>load</code>以及<code>initialize</code>方法，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//Persom.m</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@implementation Person</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;person load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    NSLog(@&quot;person initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)hello&#123;</span><br><span class="line">    NSLog(@&quot;Person say hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Student.m</span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line">@implementation Student</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;student load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    NSLog(@&quot;student initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)hello&#123;</span><br><span class="line">    NSLog(@&quot;student say hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Student+Extension.m</span><br><span class="line">#import &quot;Student+Extension.h&quot;</span><br><span class="line">@implementation Student (Extension)</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;Student Category load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    NSLog(@&quot;Student Category initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后我们在ViewController的<code>touchBegan</code>方法里面加入<code>[Studnet hello]</code>，程序启动之后会打打印出以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-10 16:51:26.487852+0800 Runtime[38325:14188628] person load</span><br><span class="line">2018-09-10 16:51:26.489395+0800 Runtime[38325:14188628] student load</span><br><span class="line">2018-09-10 16:51:26.489825+0800 Runtime[38325:14188628] Student Category load</span><br></pre></td></tr></table></figure><blockquote><p>通过上面的打印信息我们可以看出，load方法是由系统自动执行，并且调用的顺序是父类-&gt;子类-&gt;分类。</p></blockquote><p>接下来我们点击屏幕，打印以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-10 16:53:36.481032+0800 Runtime[38325:14188628] person initialize</span><br><span class="line">2018-09-10 16:53:36.481312+0800 Runtime[38325:14188628] Student Category initialize</span><br><span class="line">2018-09-10 16:53:36.481437+0800 Runtime[38325:14188628] student say hello</span><br></pre></td></tr></table></figure><blockquote><p>通过打印信息我们知道，只有当该类第一次接收到消息的时候才会调用initialize方法，同样会优先调用父类的initialize方法，但是我们的子类同样也实现了initialize方法，这里只打印了分类的方法，会不会是分类的方法把子类的方法覆盖了？</p></blockquote><p>下面我们来验证一下，我们通过修改将分类的initialize方法注释掉，然后重新运行点击屏幕，打印信息如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-10 17:00:22.099887+0800 Runtime[39163:14201501] person initialize</span><br><span class="line">2018-09-10 17:00:22.100215+0800 Runtime[39163:14201501] student initialize</span><br><span class="line">2018-09-10 17:00:22.101254+0800 Runtime[39163:14201501] student say hello</span><br></pre></td></tr></table></figure><blockquote><p>果然验证了我们的猜想，分类的initialize确实会覆盖原类的initialize方法。但是我们还有一个疑问，如果子类也不实现initialize方法的话，这样还会调用到父类的initialize方法吗？</p></blockquote><p>接下来我们将Student类的initialize方法注释掉，看一下打印信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-10 17:02:47.361138+0800 Runtime[39388:14205240] person initialize</span><br><span class="line">2018-09-10 17:02:47.361337+0800 Runtime[39388:14205240] person initialize</span><br><span class="line">2018-09-10 17:02:47.361451+0800 Runtime[39388:14205240] student say hello</span><br></pre></td></tr></table></figure><blockquote><p>通过打印信息我们看出来了，如果子类没有实现对应的initialize方法，那么将会调用父类的initialize方法。可是为什么父类initialize方法会被调用两次呢，是不是每个子类第一次收到消息的时候都会先调用父类的initialize方法呢？</p></blockquote><p>接下来我们将ViewController的<code>TouchBegan</code>方法修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Person hello];</span><br><span class="line">[Student hello];</span><br></pre></td></tr></table></figure><p>我们来看看打印信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-09-10 17:06:34.228551+0800 Runtime[39744:14211193] person initialize</span><br><span class="line">2018-09-10 17:06:34.228788+0800 Runtime[39744:14211193] Person say hello</span><br><span class="line">2018-09-10 17:06:34.229098+0800 Runtime[39744:14211193] person initialize</span><br><span class="line">2018-09-10 17:06:34.229187+0800 Runtime[39744:14211193] student say hello</span><br></pre></td></tr></table></figure><blockquote><p>通过打印信息我们看到了当Person收到hello消息的时候，会调用自身的initialize方法，当Person的子类Student收到消息的时候，同样调用了父类的initialize方法（这个是因为之类没有实现initialize方法，刚刚已经论证。），通过和上个打印信息对比，我们发现了如果子类第一次收到消息之前，父类没有收到过消息，也就是没有调用过initialize方法，会先调用initialize初始化父类，如果父类initialize方法已经被调用过，那么就不会调用父类的initialize的方法，而且调用自身的initialize方法，如果自身的initialize方法没有实现，那么就调用父类initialize方法。</p></blockquote><p><strong>我们做了这么多的对比论证，接下来我们来总结一下我们上面得到的结论</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过代码我们可以总结出以下的信息：</p><blockquote><ul><li>调用时机<br> <code>+(void)load</code>是在类或者分类加入到Objective-C Runtime的时候调用<br> <code>+(void)initialize</code>是在类或者子类第一次收到消息的时候调用（类消息或者对象消息）</li></ul></blockquote><blockquote><ul><li>调用顺序<br>   <code>+(void)load</code>方法的调用顺序是，父类-&gt;子类-&gt;分类。<br>   <code>+(void)initialize</code>方法的顺序是，父类-&gt;子类（如果有分类，分类方法会替换子类的方法，只执行分类的实现）</li></ul></blockquote><blockquote><ul><li>调用次数<br> <code>+(void)load</code>方法只会调用一次<br> <code>+(void)initialize</code>有可能会调用多次，如果子类没有实现该方法，则子类第一次收到消息的时候会调用父类的方法。<br>  值得一提的是，如果在子类收到消息之前，父类及其其他子类没有收到过消息，那么会先调用父类的<code>initialize</code>方法再调用子类的<code>initialize</code>方法</li></ul></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>这一系列的对比实验下来我们得出了自己的论证结果，但是从实现原理上面来说我还是对它们的底层实现很感兴趣，接下来我们就来看看源码实现。</p><p>源码我这边下载的是 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-723</a>版本。</p><h2 id="void-load"><a href="#void-load" class="headerlink" title="+ (void)load"></a>+ (void)load</h2><p>我们首先来看看在load方法是在哪里调用的以及在load方法之前都做了什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//在_objc_init运行时初始化方法里面会注册load_images的回调，当有新的镜像加载到runtime时，都会通知load_images方法</span><br><span class="line">_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line">//处理由DYLD(动态链接器)映射加载的镜像里面处理load方法</span><br><span class="line">load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    // Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    // Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过上面的代码我们可以到和load有关的方法有两个，一个是prepare_load_methods以及call_load_methods。下面我们分别来看看这两个方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        if (!cls) continue;  // category for ignored weak-linked class</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过上面的代码我们可以看到，这个方法是为了做一些准备工作。首先会获取镜像里面的所有的Classlist，然后遍历该classList，调用schedule_class_load，传入每一个class。然后全部遍历完成之后会获取category，同样的遍历之后直接加入到loadable_categories列表中。<strong>这样是为了保证class的load方法在category的load方法之前调用。</strong></p></li><li><p>接下来我们来看看schedule_class_load 方法：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());  // _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    // Ensure superclass-first ordering</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该方法会获取该类的父类然后递归调用<code>schedule_class_load</code>方法，保证父类的load方法在子类的load方法之前执行。然后将class 加入到loadable_classes里面。</li></ul><p><strong>综上所述，prepare_load_methods这个方法就是将满足load方法的class和category分别存放到loadble_classs以及loadable_categories里面</strong></p><p>接下来我们来看看<code>call_load_methods</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading = NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    void *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        // 1. Repeatedly call class +loads until there aren&apos;t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. Call category +loads ONCE</span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        // 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这一步就是调用loabable_classes 以及 loadable_categories中准备好的load方法，并且class优先于category先调用。接下来我们以call_class_loads为例来看看代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    // Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes = loadable_classes;</span><br><span class="line">    int used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = 0;</span><br><span class="line">    loadable_classes_used = 0;</span><br><span class="line">    </span><br><span class="line">    // Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Destroy the detached list.</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从全局变量loadable_classes中得到所有可供调用的class，然后将变量进行清零操作，然后遍历加载所有的class,通过<code>(*load_method)(cls, SEL_load);</code>的方式调用+(void)load方法，这里是通过直接调用函数的内存地址的方式来实现调用load方法，而不是objc常见的msg_send()方法。<br><strong>所以这里就可以解释了为什么子类没有实现load方法的时候不会调用到父类的load方法，因为不是通过msg_send的方式去调用的。也就是每个类的load方法都是独立的，不会有消息的转发等情况发生，也就是利用这个特性，我们可以在这里做<a href="https://nshipster.com/method-swizzling/" target="_blank" rel="noopener">method swizzling</a></strong></li></ul><h2 id="void-initialize"><a href="#void-initialize" class="headerlink" title="+ (void)initialize"></a>+ (void)initialize</h2><p>接下来我们来看看<code>+ (void)initialize</code>方法是如何被调用的，我们来关注一下runtime-new.mm文件里面的lookUpImpOrForward方法，我相信有些人看到这个方法应该觉得有点熟悉，这里就是返回一个方法的实现或者消息转发的时候就会调用该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        // If sel == initialize, _class_initialize will send +initialize and </span><br><span class="line">        // then the messenger will send +initialize again after this </span><br><span class="line">        // procedure finishes. Of course, if this is not being called </span><br><span class="line">        // from the messenger then it won&apos;t happen. 2778172</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过上面的关键代码我们可以看出当一个类的方法任何一个方法被调用的时候，就会判断该类是否已经调用了initialize方法，如果没有调用的话就会通过<code>void_class_initialize(Class cls)</code>方法来调用initialize方法，接下来我们来看具体实现。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    bool reallyInitialize = NO;</span><br><span class="line"></span><br><span class="line">    // Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    // See note about deadlock above.</span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized())   &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    &#123;</span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">            cls-&gt;setInitializing();</span><br><span class="line">            reallyInitialize = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        // We successfully set the CLS_INITIALIZING bit. Initialize the class.</span><br><span class="line">        </span><br><span class="line">        // Record that we&apos;re initializing this class so we can message it.</span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        if (MultithreadedForkChild) &#123;</span><br><span class="line">            // LOL JK we don&apos;t really call +initialize methods after fork().</span><br><span class="line">            performForkChildInitialize(cls, supercls);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // Send the +initialize message.</span><br><span class="line">        // Note that +initialize is sent to the superclass (again) if </span><br><span class="line">        // this class doesn&apos;t implement +initialize. 2157218</span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: thread %p: calling +[%s initialize]&quot;,</span><br><span class="line">                         pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Exceptions: A +initialize call that throws an exception </span><br><span class="line">        // is deemed to be a complete and successful +initialize.</span><br><span class="line">        //</span><br><span class="line">        // Only __OBJC2__ adds these handlers. !__OBJC2__ has a</span><br><span class="line">        // bootstrapping problem of this versus CF&apos;s call to</span><br><span class="line">        // objc_exception_set_functions().</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @try</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">        //通过objc_msgSend方法调用initialize方法</span><br><span class="line">           ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @catch (...) &#123;</span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: +[%s initialize] &quot;</span><br><span class="line">                             &quot;threw an exception&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            @throw;</span><br><span class="line">        &#125;</span><br><span class="line">        @finally</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            // Done initializing.</span><br><span class="line">            lockAndFinishInitializing(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过上面的代码我们看到了该方法首先会获取该类的父类，并且递归调用<code>_class_initialize</code>方法保证父类的方法优先于子类执行。然后我们看到了有一行很关键的代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">  asm(&quot;&quot;);</span><br></pre></td></tr></table></figure><ul><li>+(void)initialize方法是通过objc_msgSend方法来调用的，区别于load方法通过方法内存地址调用，所以根据objc_msgSend的特性，如果一个子类没有实现initialize方法，那么将会调用父类的initialize方法，如果分类实现了initialize方法，那么将会替换子类方法。</li></ul><p><strong>综上所述，一个类的initialize方法是有可能被调用多次的，如果他有对应的子类并且子类没有实现对应的initialize方法的时候本类的initialize方法就会被调用多次。所以为了保证一个类的initialize方法里面的逻辑只会被调用一次，我们可以通过以下的代码判断</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">  if (self == [ClassName self]) &#123;</span><br><span class="line">    // ... do the initialization ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们知道在NSObject中有两个初始化的方法，&lt;code&gt;+(void)load&lt;/code&gt;以及&lt;code&gt;+ (void)initialize&lt;/code&gt;方法，这两个方法都是由系统来自动调用，不需要我们手动来调用，我们经常会在这两个方法的内部做一些magic的事情。&lt;/p&gt;
&lt;p&gt;下面我们首先对这两个方法做一个初步的使用，看看他们两的调用时机以及异同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然如果已经知道了他们的异同以及调用顺序的可以直接看总结或者源码分析&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS图片解码实践</title>
    <link href="http://lemon2well.top/2018/09/04/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/"/>
    <id>http://lemon2well.top/2018/09/04/iOS 开发/iOS图片解码实践/</id>
    <published>2018-09-04T03:40:15.000Z</published>
    <updated>2018-09-04T06:31:00.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在iOS中，大多数的APP都有不可或缺的图片资源，同时也很容易因为对图片的处理不恰当造成性能低下，不要让图片成为你的APP的性能杀手。</p><p>一张图片从磁盘中加载出来，同时显示到屏幕上，经过了一系列的复杂处理，其中包括了对图片的解码，我们今天就来做一次图片的解码实践。</p><h2 id="图片显示过程"><a href="#图片显示过程" class="headerlink" title="图片显示过程"></a>图片显示过程</h2><p>平时我们对于图片的显示，一般都是使用以下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIImage *image = [UIImage imageNamed:@&quot;icon&quot;];</span><br><span class="line">self.imageView.image = image;</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>简单的两行代码其实里面包含了下面几步:</p><ol><li>首先会调用 <a href="https://developer.apple.com/library/ios/documentation/graphicsimaging/conceptual/ImageIOGuide/imageio_intro/ikpg_intro.html#//apple_ref/doc/uid/TP40005462-CH201-TPXREF101" target="_blank" rel="noopener">image/io</a>从磁盘中加载一张图片，这个时候，图片还没有解码。</li><li>将image复制给imageView的image</li><li>然后一个隐式的CATransaction捕获到图层树的变化</li><li>在主线程runloop下一次迭代到来的时候，Core Animation会提交这个隐式transaction，这个过程会对图片进行copy操作，根据图片的不同，可能会涉及以下的一些甚至全部的步骤。</li></ol></blockquote><blockquote><pre><code>I. 为文件管理IO和解压缩操作分配内存缓存区域II. 从磁盘中读取数据到内存中III. 将压缩的图片数据解码成未压缩的图片数据，这通常是一个非常频繁耗时的CPU操作IV. CoreAnimation将未压缩位图数据渲染到layer上。</code></pre></blockquote><p>从上面的步骤可以看出，图片的解码主是主要耗时的原因，如果一个APP中只有几张图片是这样设置当然是没问题的，可是如果在一个TableView中有大量的图片在滚动，如果这个时候在不断的解码显示那必然会导致界面卡顿。</p><h2 id="为什么需要解码"><a href="#为什么需要解码" class="headerlink" title="为什么需要解码"></a>为什么需要解码</h2><p>实际上我们使用的JPEG或者PNG格式的图片，都是一种经过压缩的位图图形格式，只不过PNG是无损压缩并且支持alpha通道，而JEPG是有损压缩，并且可以指定压缩比。下面是iOS中提供的获得上述格式图片的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN  NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull image);                               // return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format</span><br><span class="line">UIKIT_EXTERN  NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull image, CGFloat compressionQuality);  // return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)</span><br></pre></td></tr></table></figure><p>接下来我们就要了解一下位图：</p><blockquote><p>A bitmap image (or sampled image) is an array of pixels (or samples). Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images.</p></blockquote><p>其实位图就是一个像素数组，每个像素都代表了图片中独立的一个点，每一个点其实又包含了以下内容：</p><blockquote><p>Bits per component ：一个像素中每个独立的颜色分量使用的 bit 数；<br>Bits per pixel ：一个像素使用的总 bit 数；<br>Bytes per row ：位图中的每一行使用的字节数。</p></blockquote><p>这里不多说，具体的可以查看<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBECCFG" target="_blank" rel="noopener">像素格式</a>。</p><p>我们知道位图是经过压缩后的，我们可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIImage *image = [UIImage imageNamed:@&quot;icon&quot;];</span><br><span class="line">CFDataRef rawData = CGDataProviderCopyData(CGImageGetDataProvider(image.CGImage));</span><br></pre></td></tr></table></figure><p>得到原始的数据大小，一般该数据的大小的计算方式是：</p><blockquote><p>图片像素宽<em> 图片像素高  </em> 每个像素所占的字节数4</p></blockquote><p>所以图片当前的大小并不等于解码后的大小，所以我们才需要解码之后才能得到原始的数据大小，只有使用原始数据才能正确的显示出图片。</p><h2 id="正确的解码姿势"><a href="#正确的解码姿势" class="headerlink" title="正确的解码姿势"></a>正确的解码姿势</h2><p>上面已经知道了图片显示是会在主线程解压缩图片之后然后渲染到屏幕上，首先我们可以在子线程中做解码的操作，在子线程中重新绘制图片，得到解码后的图片，然后渲染到屏幕上。</p><p>我们先上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (void)decodeImage:(UIImage *)image completion:(void(^)(UIImage *image))completion&#123;</span><br><span class="line">    if (!image) return;</span><br><span class="line">    //在子线程执行解码操作</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</span><br><span class="line">        CGImageRef imageRef = image.CGImage;</span><br><span class="line">        //获取像素宽和像素高</span><br><span class="line">        size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">        size_t height = CGImageGetHeight(imageRef);</span><br><span class="line">        if (width == 0 || height == 0) return ;</span><br><span class="line">        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask;</span><br><span class="line">        BOOL hasAlpha = NO;</span><br><span class="line">        //判断颜色是否含有alpha通道</span><br><span class="line">        if (alphaInfo == kCGImageAlphaPremultipliedLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">            alphaInfo == kCGImageAlphaLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaFirst) &#123;</span><br><span class="line">            hasAlpha = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        //在iOS中，使用的是小端模式，在mac中使用的是大端模式，为了兼容，我们使用kCGBitmapByteOrder32Host，32位字节顺序，该宏在不同的平台上面会自动组装换成不同的模式。</span><br><span class="line">        /*</span><br><span class="line">         #ifdef __BIG_ENDIAN__</span><br><span class="line">         # define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Big</span><br><span class="line">         # define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Big</span><br><span class="line">         #else    //Little endian.</span><br><span class="line">         # define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Little</span><br><span class="line">         # define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Little</span><br><span class="line">         #endif</span><br><span class="line">         */</span><br><span class="line">        </span><br><span class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        //根据是否含有alpha通道，如果有则使用kCGImageAlphaPremultipliedFirst，ARGB否则使用kCGImageAlphaNoneSkipFirst，RGB</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        //创建一个位图上下文</span><br><span class="line">        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0,  CGColorSpaceCreateDeviceRGB(), bitmapInfo);</span><br><span class="line">        if (!context) return;</span><br><span class="line">        //将原始图片绘制到上下文当中</span><br><span class="line">        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</span><br><span class="line">        //创建一张新的解压后的位图</span><br><span class="line">        CGImageRef newImage = CGBitmapContextCreateImage(context);</span><br><span class="line">        CFRelease(context);</span><br><span class="line">        UIImage *originImage =[UIImage imageWithCGImage:newImage scale:[UIScreen mainScreen].scale orientation:image.imageOrientation];</span><br><span class="line">        //回到主线程回调</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            completion(originImage);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><table><thead><tr><th>图片尺寸</th><th>未解码直接渲染时间(ms)</th><th>解码后渲染时间(ms)</th></tr></thead><tbody><tr><td>128x96.jpg</td><td>0.99</td><td>0.08</td></tr><tr><td>128x96.png</td><td>0.80</td><td>0.08</td></tr><tr><td>256x192.jpg</td><td>3.01</td><td>0.14</td></tr><tr><td>256x192.png</td><td>2.30</td><td>0.17</td></tr><tr><td>512x384.jpg</td><td>4.83</td><td>0.28</td></tr><tr><td>512x384.png</td><td>6.03</td><td>0.28</td></tr><tr><td>1024x768.jpg</td><td>13.83</td><td>1.43</td></tr><tr><td>1024x768.png</td><td>18.31</td><td>1.12</td></tr><tr><td>2048x1536.jpg</td><td>31.72</td><td>3.99</td></tr><tr><td>2048x1536.png</td><td>75.05</td><td>5.16</td></tr></tbody></table><p>通过上面的对比我们可以看出，解码后的图片的渲染速度远远高于未解码后的图片的渲染速度，并且由于我们在子线程中进行解码，所以也不会造成主线程的UI卡顿。</p><h2 id="Demo-is-here"><a href="#Demo-is-here" class="headerlink" title="Demo is here"></a>Demo is here</h2><p>最后，按照常规，这里应该有一份<a href="https://github.com/codemonkeybulucck/ImageUncompressing" target="_blank" rel="noopener">demo</a>;</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在iOS中，大多数的APP都有不可或缺的图片资源，同时也很容易因为对图片的处理不恰当造成性能低下，不要让图片成为你的APP的性能杀手。&lt;/p&gt;
&lt;p&gt;一张图片从磁盘中加载出来，同时显示到屏幕上，经过了一系列的复杂处理，其中包括了对图片的解码，我们今天就来做一次图片的解码实践。&lt;/p&gt;
&lt;h2 id=&quot;图片显示过程&quot;&gt;&lt;a href=&quot;#图片显示过程&quot; class=&quot;headerlink&quot; title=&quot;图片显示过程&quot;&gt;&lt;/a&gt;图片显示过程&lt;/h2&gt;&lt;p&gt;平时我们对于图片的显示，一般都是使用以下的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIImage *image = [UIImage imageNamed:@&amp;quot;icon&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.imageView.image = image;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>你看那个程序员，他孤不孤独</title>
    <link href="http://lemon2well.top/2018/08/31/%E6%9D%82%E8%B0%88/%E4%BD%A0%E7%9C%8B%E9%82%A3%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E4%BB%96%E5%AD%A4%E4%B8%8D%E5%AD%A4%E7%8B%AC/"/>
    <id>http://lemon2well.top/2018/08/31/杂谈/你看那个程序员，他孤不孤独/</id>
    <published>2018-08-31T02:28:41.000Z</published>
    <updated>2018-08-31T02:29:25.970Z</updated>
    
    <content type="html"><![CDATA[<p>今天是星期五，对于大多数人来说估计已经在琢磨着周末去哪里浪了，或者周末在家睡个天昏地暗，享受一下这难得不用早起挤车挤地铁的周末。</p><p>龙哥看看手表，凌晨四点整，刚吃完酸菜牛肉面的龙哥打算下班回家。这已经是龙哥这周第三次加班到凌晨了，只有星期二的时候休息了一天没加班，因为项目快要上线了，估计周末还得在办公室度过。</p><p>作为“资深”程序员的龙哥虽然才工作三年多，但是已经有五年的工作经验了。如果是同行的话估计会懂这句话是啥意思，那多出来的一年半的工作经验就是加班多出来的。</p><a id="more"></a><p>加班对于龙哥来说已经司空见惯了，因为加班，他认识了很多出租车司机，通过出租车司机他就能知道今天哪里哪里又发生什么大事了，哪里的休闲会所能提供最好质量的服务，哪里的人最没素质。龙哥每次就这么坐在车上听司机闲扯着，也不会反驳司机说的不对的事情。对于龙哥来说他每天凌晨碰到的这些人就是他的私人新闻导播，只不过有点不一样的是，这些新闻往往被放大很多倍，甚至有些是谣言，不过他并不在意，毕竟这是一天中最有趣的时刻，或者更确切的说，这是龙哥最不孤独的时刻。</p><p>刚刚说了龙哥中间有一天不加班，其实是去帮女生搬家了，据说还请女生吃饭了。<br>那天我还问了龙哥，对话是这样的：<br>我：”龙哥，你去帮女生搬家，应该她请你吃饭才对啊，怎么变成你请她吃饭了？”<br>龙哥笑着说：”我请她吃饭是因为我已经很久没有和别人一起吃饭了，每天下班基本上都是自己随便吃一点就解决了，应该还要感谢她陪我吃饭。“<br>我：“那这样说的话，以后你想找别人陪你吃饭了你就找我，这样的好事别便宜别人了，但是前提是你买单”。<br>龙哥：“滚”。（请自行脑补龙哥臭脸的样子）</p><p>龙哥没有女朋友，据他说是大学的时候谈过一次恋爱，分手的原因和很多人一样，毕业之后大家意向不同，龙哥想去北上广深这些大城市工作，那里的IT就业环境是其他二线城市不能比的，但是他前女友想留在老家找个教师的工作，家里的生活压力相对小点，然后他们就和平分手了。</p><p>我问过龙哥想过重新找个女朋友吗？龙哥也很实诚，说想过，但是有个事情他意想不到。因为大学是在师范院校读的计算机专业，所以大学的时候身边的女生也相对较多一点，找女朋友机会也多一点。没想到毕业之后进去的科技公司，身边纯一色的抠脚大汉，根本没有途径去认识女生。好不容易来了一个女同事，要不就是有男朋友，要不就是已婚，再要不就是他喜欢的女生他还没行动又成为别人的女朋友了。</p><p>后来龙哥就对谈恋爱这个事情不强求了，佛系找女朋友，有也行，没有也行，不争不抢。</p><p>龙哥不喜欢待在家里，就喜欢在外边溜达，龙哥自己一个人住，广州的城中村大家都知道，即使是一房一厅也小得可怜，握手楼，一栋挨着一栋。打开窗没有阳光，看到的都是水泥钢筋，关上门也不隔音，听到的都是嘈杂噪音。这个时节的广州，基本上每天都下雨，龙哥家里也潮湿，之前听他说家里的柜子都因为潮湿木头膨胀倒塌了，不过他又把它给修好了，后来逢人他就炫耀他会修柜子这个事情。</p><p>龙哥爱好不多，如果发呆算是爱好的话那他就只有一个爱好。我经常看到他坐在座位上发呆，也不知道他在想些什么，不过我知道他很少和人说他自己的私事，他朋友不多，我算是他比较好的朋友，不过我也没听他向我抱怨过什么或者说一些，那一次龙哥发呆真的吓到我了。</p><p>那是我们俩在加班的时候，我和龙哥算是同道中人，我也是加班狂魔。除了工作原因外，我是想着攒多一点假期后面调休出去旅游一趟，至于龙哥，我问过他，但是我觉得他是在逃避一些什么东西。</p><p>我印象最深刻的时候是那一天，星期五，已经是凌晨三点钟了，办公室的人都走光了，就只有我和龙哥还在工作，我突然觉得肚子有点饿，我就和龙哥说，“龙哥，你饿吗？和你一起下去吃点东西”。龙哥抬头看着我，“我有点忙，商品详情功能我快写完了，你帮我买一个方便面上来可以吗？惯例，酸菜牛肉面”。“OK，那我帮你买上来。”然后我就下去买方便面了，龙哥总是对酸菜牛肉面情有独钟，每次都是吃这个面，而我讨厌酸菜牛肉面，我喜欢吃点健康的，蔬菜面。不到十分钟我就把面买上来了。</p><p>然后我就看到了以下的一幕，办公司所有的灯都关掉了，就只有我们俩头顶那两盏灯还开着，在暗黄的灯光的照耀下，龙哥双手交叉抱在胸前，后背靠在座位上，身体侧着对着电脑，眼镜好像看着斜上方的横梁，但是处于放空的状态，准确来说应该是双目无神，他看起来整个人静止了。</p><p>说实话我刚看到那一刻的时候我第一想法就是打120，龙哥是不是出事了， 因为我从来没有见过他这么疲惫，脸上毫无表情，一副与世隔绝的样子。那时我真的被吓到了，后来我看龙哥眨了一下眼睛，我才放下心来。</p><p>我记得我问过龙哥，“你孤独吗？”，龙哥说了下面一段话：</p><blockquote><p>“你试过凌晨三点钟突然惊醒吗？我试过！我醒来之后我看着四周黑暗一片，我看向窗外，只有微微的光亮。后来我打开灯，四周是亮白的墙，但是我还是很怕，感觉我被别人困在房子里面了，孤独感包围着我，我那晚一宿没睡，第二天六点钟我就出门去上班了，我不想再有那样的时刻。”</p></blockquote><p>可能发呆的这一刻龙哥什么都没有在想，也有可能是想起了那天的情景，那种孤独感蔓延到了公司，同样在三点钟，将龙哥包围了。</p><p>或许龙哥真的在逃避，他是在逃避孤独，我见过他一个人抱着爆米花去电影院看爱情电影，旁边都是一对对的情侣；我见过他一个人去吃海底捞，店员看他是一个人来的对面给他放了一个大的公仔；我见过他一个人去KTV，唱了一晚上《男人KTV》。</p><p>现在是凌晨四点钟，终于把商品详情功能完成了，刚吃完酸菜牛肉面，还有点饱，写完这篇文章就打算回去睡觉，今天有点累，不过我还是宁愿凌晨三点钟睡觉也不愿凌晨三点钟醒来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是星期五，对于大多数人来说估计已经在琢磨着周末去哪里浪了，或者周末在家睡个天昏地暗，享受一下这难得不用早起挤车挤地铁的周末。&lt;/p&gt;
&lt;p&gt;龙哥看看手表，凌晨四点整，刚吃完酸菜牛肉面的龙哥打算下班回家。这已经是龙哥这周第三次加班到凌晨了，只有星期二的时候休息了一天没加班，因为项目快要上线了，估计周末还得在办公室度过。&lt;/p&gt;
&lt;p&gt;作为“资深”程序员的龙哥虽然才工作三年多，但是已经有五年的工作经验了。如果是同行的话估计会懂这句话是啥意思，那多出来的一年半的工作经验就是加班多出来的。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://lemon2well.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS中的圆角处理（终结篇）</title>
    <link href="http://lemon2well.top/2018/08/29/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E7%9A%84%E5%9C%86%E8%A7%92%E5%A4%84%E7%90%86%EF%BC%88%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%89/"/>
    <id>http://lemon2well.top/2018/08/29/iOS 开发/iOS中的圆角处理（终结篇）/</id>
    <published>2018-08-29T09:18:46.000Z</published>
    <updated>2018-08-30T01:52:22.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发中，我们经常用到圆角的处理，圆角看起来会比直角更加美观和柔美。但是设置圆角往往会带来一定的性能损耗，损耗的来源主要由于大量的离屏渲染，接下来我们就来讲一下如果实现高性能的圆角。我们下面来看以下几种设置圆角的方式以及它们对性能的影响。</p><h2 id="CornerRadius-masksToBounds"><a href="#CornerRadius-masksToBounds" class="headerlink" title="CornerRadius+masksToBounds"></a>CornerRadius+masksToBounds</h2><p>第一种方式就是我们最常用的设置圆角的方式，我们首先来看看<code>cornerRadius</code>的定义是什么：</p><blockquote><p>The radius to use when drawing rounded corners for the layer’s background. Animatable.<br>Setting the radius to a value greater than 0.0 causes the layer to begin drawing rounded corners on its background. By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to YES causes the content to be clipped to the rounded corners.<br>The default value of this property is 0.0.</p></blockquote><a id="more"></a><p>通过上面的解释我们可以看到cornerRadius只是对view的背景颜色和边框起作用，对于一些像ImageView以及Label等含有内部子视图的就不起作用了，这个时候我们往往还要添下下面这一句来让label生成一个适配圆角的剪切蒙版，该蒙版与label的边界相匹配，这样就达到了圆角的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label.layer.masksToBounds = YES;</span><br></pre></td></tr></table></figure><p>但是这样就会导致另外一个问题，离屏渲染。前面我们已经说了大量的离屏渲染会导致性能下降，最直观的感受就是如果在一个tableView中有大量的离屏渲染，就会导致FPS下降导致掉帧，界面看起来卡顿。</p><h3 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h3><p>我们通过模拟器的 <code>Color-Off-screen-Render</code>可以看到那个元素产生了离屏渲染了，和很多人说的不一样，不可以统筹的说<code>创建圆角是产生离屏渲染的原因</code><br>正确的来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.layer.cornerRadius = 5;</span><br><span class="line">view.layer.maskToBounds = YES;</span><br></pre></td></tr></table></figure></p><p>这两句代码合在一起才是产生离屏渲染的原因。如下图所示，每个cell的第一和第二个的ImageView都是执行了上面的两句代码，产生了离屏幕渲染，而第三个棕色的圆形则是一个view，代码里面仅使用了<code>view.layer.cornerRadius</code>，所以没有产生离屏渲染。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/sim.png" alt="si"></p><p>如上所示，当一个tableView的离屏渲染达到了44个的时候，FPS下降到了35左右，性能下降得很厉害。所以如果一个界面上需要有很多的圆角的时候，这种方式不可取。</p><h2 id="CAShapeLayer-UIBezierPath"><a href="#CAShapeLayer-UIBezierPath" class="headerlink" title="CAShapeLayer+UIBezierPath"></a>CAShapeLayer+UIBezierPath</h2><p>这种方式简直是噩梦，我们先来看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> CAShapeLayer *mask = [CAShapeLayer new];</span><br><span class="line">    mask.path = [UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:10].CGPath;</span><br><span class="line">imageView.layer.mask = mask;</span><br></pre></td></tr></table></figure><p>我们首先创建一个mask，然后通过贝塞尔曲线覆盖到原来的imageView上面，几行代码搞定。</p><h3 id="性能影响-1"><a href="#性能影响-1" class="headerlink" title="性能影响"></a>性能影响</h3><p>然后我们来看看界面是否会产生离屏渲染。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/sim2.png" alt="si"></p><p>如果不看一下真的吓一跳，全部的元素都产生了离屏渲染，还不如第一种方式。然后我们看一下FPS是10，其实都不用看FPS，直接页面上都能看出来了，卡到怀疑人生。</p><p>上面的方式是创建子控件的时候直接添加mask，还有一种方式是在 <code>-(void)drawRect:(CGRect)rect</code>里面添加mask，这样方式更加糟糕，因为不恰当的使用这个方法会导致内存暴增。举个例子，iPhone6 上与屏幕等大的 UIView，即使重写一个空的 drawRect 方法，它也至少占用 750 <em> 1134 </em> 4 字节 ≈ 3.4 Mb 的内存。在 <a href="http://bihongbo.com/2016/01/03/memoryGhostdrawRect/" target="_blank" rel="noopener">内存恶鬼drawRect</a> 及其后续中，作者详细介绍了其中原理，据他测试，在 iPhone6 上空的、与屏幕等大的视图重写 drawRect 方法会消耗 5.2 Mb 内存。总之，能避免重写 drawRect 方法就尽可能避免。</p><h2 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a>Core Graphics</h2><p>我们知道UIView其实是由CALayer和UIResponder组成，一个负责显示，一个负责响应。但是CALayer也只是一个普通的类，它并不能直接渲染到屏幕上，我们看到屏幕上面的东西其实也只是一张张图片，那为什么我们可以看到CALayer的内容呢。因为CALayer有一个content的属性，该属性可以传一个id类型的对象，当你传的对象为CGImage的时候，才会显示出来。</p><p>那通过Core Graphics 我们可以画出一个具有圆角的图片，然后添加到layer上面。</p><p>不过UIVIew和UIImageView的实现方式不一样，UIView的方式是创建一个空白的图片，然后插入到视图的最下面。而UIImageView是将在原来Image的基础上重新绘制一张带有圆角的图片，然后赋值给ImageView。</p><p>以下是关键代码：</p><p>UIVIew:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)lm_drawRectWithRoundedCorner:(CGFloat)radius</span><br><span class="line">                              borderWidth:(CGFloat)borderWidth</span><br><span class="line">                              borderColor:(UIColor *)borderColor</span><br><span class="line">                          backGroundColor:(UIColor*)bgColor&#123;</span><br><span class="line">    CGSize size = self.bounds.size;</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale);</span><br><span class="line">    CGContextRef contextRef =  UIGraphicsGetCurrentContext();</span><br><span class="line">    </span><br><span class="line">    CGContextSetLineWidth(contextRef, borderWidth);</span><br><span class="line">    CGContextSetStrokeColorWithColor(contextRef, borderColor.CGColor);</span><br><span class="line">    CGContextSetFillColorWithColor(contextRef, bgColor.CGColor);</span><br><span class="line">    </span><br><span class="line">    CGFloat halfBorderWidth = borderWidth / 2.0;</span><br><span class="line">    CGFloat width = size.width;</span><br><span class="line">    CGFloat height = size.height;</span><br><span class="line">    </span><br><span class="line">    CGContextMoveToPoint(contextRef, width - halfBorderWidth, radius + halfBorderWidth);</span><br><span class="line">    CGContextAddArcToPoint(contextRef, width - halfBorderWidth, height - halfBorderWidth, width - radius - halfBorderWidth, height - halfBorderWidth, radius);  // 右下角角度</span><br><span class="line">    CGContextAddArcToPoint(contextRef, halfBorderWidth, height - halfBorderWidth, halfBorderWidth, height - radius - halfBorderWidth, radius); // 左下角角度</span><br><span class="line">    CGContextAddArcToPoint(contextRef, halfBorderWidth, halfBorderWidth, width - halfBorderWidth, halfBorderWidth, radius); // 左上角</span><br><span class="line">    CGContextAddArcToPoint(contextRef, width - halfBorderWidth, halfBorderWidth, width - halfBorderWidth, radius + halfBorderWidth, radius); // 右上角</span><br><span class="line">    CGContextDrawPath(contextRef, kCGPathFillStroke);</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>UIImageVIew:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)lm_drawRectWithRoundedCorner:(CGFloat)radius</span><br><span class="line">                                     size:(CGSize)size&#123;</span><br><span class="line">    </span><br><span class="line">    CGRect rect = CGRectMake(0, 0, size.width, size.height);</span><br><span class="line">    </span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(rect.size, false, [UIScreen mainScreen].scale);</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, radius)];</span><br><span class="line">    CGContextAddPath(context, path.CGPath);</span><br><span class="line">    </span><br><span class="line">    CGContextClip(context);</span><br><span class="line">    </span><br><span class="line">    [self drawInRect:rect];</span><br><span class="line">    CGContextDrawPath(context, kCGPathFillStroke);</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return  image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能影响-2"><a href="#性能影响-2" class="headerlink" title="性能影响"></a>性能影响</h3><p><img src="http://pcd17v2u0.bkt.clouddn.com/sim3.png" alt="si"></p><p>从上面的图片我们可以看出，设置圆角已经没有离屏渲染了，通过Core Animation可以看出FPS也回到60左右，界面也没有卡顿了。</p><font color="#dd0000">注意：即使我们使用了这种方式，我们还是要谨慎直接设置view.backGroundColor，因为我们没有设置maskToBounds属性，所以以这样的方式设置了背景颜色依然会导致没有圆角效果。<br>如果想要背景颜色，可以在画圆角图片的时候改变一下backGroundColor。</font><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，我们得出以下的结论：</p><ol><li>layer.cornerRadius不会触发离屏渲染，该属性只是对边框和背景颜色起作用，适用于内部没有其他控件的view。</li><li>CAShapeLayer+UIBezierPath会触发离屏渲染。</li><li>最好的方式就是使用Core Graphics的方式绘制圆角图片。</li><li>当然，还是那句话，根据场景来使用，如果界面中圆角的地方不多，第一种方式是最简单快捷，效率最高的。如果用到的圆角很多，那还是使用Core Graphics的方式把。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>本文章的代码已经放到Github，需要的可以自取。<a href="https://github.com/codemonkeybulucck/CornerViewDemo" target="_blank" rel="noopener">CornerViewDemo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在开发中，我们经常用到圆角的处理，圆角看起来会比直角更加美观和柔美。但是设置圆角往往会带来一定的性能损耗，损耗的来源主要由于大量的离屏渲染，接下来我们就来讲一下如果实现高性能的圆角。我们下面来看以下几种设置圆角的方式以及它们对性能的影响。&lt;/p&gt;
&lt;h2 id=&quot;CornerRadius-masksToBounds&quot;&gt;&lt;a href=&quot;#CornerRadius-masksToBounds&quot; class=&quot;headerlink&quot; title=&quot;CornerRadius+masksToBounds&quot;&gt;&lt;/a&gt;CornerRadius+masksToBounds&lt;/h2&gt;&lt;p&gt;第一种方式就是我们最常用的设置圆角的方式，我们首先来看看&lt;code&gt;cornerRadius&lt;/code&gt;的定义是什么：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The radius to use when drawing rounded corners for the layer’s background. Animatable.&lt;br&gt;Setting the radius to a value greater than 0.0 causes the layer to begin drawing rounded corners on its background. By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to YES causes the content to be clipped to the rounded corners.&lt;br&gt;The default value of this property is 0.0.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Runloop黑魔法之复活APP</title>
    <link href="http://lemon2well.top/2018/08/23/iOS%20%E5%BC%80%E5%8F%91/Runloop%E9%BB%91%E9%AD%94%E6%B3%95%E4%B9%8B%E5%A4%8D%E6%B4%BBAPP/"/>
    <id>http://lemon2well.top/2018/08/23/iOS 开发/Runloop黑魔法之复活APP/</id>
    <published>2018-08-23T02:18:42.000Z</published>
    <updated>2018-08-23T02:19:09.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Runloop黑魔法之复活APP"><a href="#Runloop黑魔法之复活APP" class="headerlink" title="Runloop黑魔法之复活APP"></a>Runloop黑魔法之复活APP</h1><p>看到这个标题是不是觉得很酷炫，但是我还要是解释一下标题是什么意思，以免有人说我标题党，我现在要做的就是当APP发生Crash的时候，不要让APP闪退，而是重新复活。</p><blockquote><p>换句话可以这么形容，把一个Crash信息吞掉，大家当没事发生过。</p></blockquote><p>说得这么牛批，这个东西有什么实际的用处呢？额，其实还真的没啥实际的用处，不过我们当发生异常信息的时候可以友好的弹一个框告诉用户当前发生了异常，是选择上传异常信息继续运行还是直接退出，当然继续运行依然会有Crash风险。</p><p>接下来我们就来实现这么一个事情吧。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>大家都知道，我们的APP能随时的处理事件就是因为有Runloop的存在，Runloop顾名思义就是一个环，不断的跑，并且Runloop是事件驱动的，也就是说没有事情做得时候就休眠，当有事情做的时候就做事情。</p><p>Runloop实际上是一个对象，这个对象管理了其所需要的消息和事件，并且提供了一个入口函数。线程执行了该函数之后，就会一直处于Runloop的内部，而Runloop的内部就会一直处于接受消息-&gt;处理-&gt;等待-&gt;接受消息这样的循环中。直到这个循环结束，线程才会退出。</p><p>想想如果我们的APP接受到Exception消息的时候，我们先获得当前的Runloop，然后获取所有的mode，自行创建一个死循环，让runloop在里面执行不同的mode，这样就相当于让Runloop起死回生了，这样APP也复活了。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>在我前面写得这一篇<a href="http://lemon2well.top/2018/08/22/iOS%20%E5%BC%80%E5%8F%91/iOS%E6%94%B6%E9%9B%86Crash%E4%BF%A1%E6%81%AF%E4%B8%8A%E6%8A%A5/">iOSCrash信息上报和处理</a>中我们已经实现了监听Exception事件，所以我们在监听到该事件之后插入以下代码即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获得当前的runloop并且重新启动</span><br><span class="line">   CFRunLoopRef runloop = CFRunLoopGetCurrent();</span><br><span class="line">   NSArray *modes = CFBridgingRelease(CFRunLoopCopyAllModes(runloop));</span><br><span class="line">   while (!self.isExit) &#123;</span><br><span class="line">       for (NSString *mode in modes) &#123;</span><br><span class="line">           CFRunLoopRunInMode((CFStringRef)mode, 0.001, false);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们来逐行看一下上面的代码，首先我们获取到当前的Runloop，然后我们获取到当前Runloop的所有mode，然后我们创建一个循环，在里面不断的跑所有的mode，这样就实现了APP的复活。</p><p><a href="https://github.com/codemonkeybulucck/RunloopResurgenceAPP" target="_blank" rel="noopener">这里</a>是完整的demo</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Runloop是个好东西，它能做的事情远远超出我们的想像，虽然我们开发中很少直接去接触Runloop，但是它却起着无比重要的作用，所以下面提供一些关于Runloop的资料介绍：</p><p><a href="https://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="noopener">sunnyxx线下分享Runloop</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">ibireme深入理解Runloop</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Runloop黑魔法之复活APP&quot;&gt;&lt;a href=&quot;#Runloop黑魔法之复活APP&quot; class=&quot;headerlink&quot; title=&quot;Runloop黑魔法之复活APP&quot;&gt;&lt;/a&gt;Runloop黑魔法之复活APP&lt;/h1&gt;&lt;p&gt;看到这个标题是不是觉得很酷炫，但是我还要是解释一下标题是什么意思，以免有人说我标题党，我现在要做的就是当APP发生Crash的时候，不要让APP闪退，而是重新复活。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;换句话可以这么形容，把一个Crash信息吞掉，大家当没事发生过。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说得这么牛批，这个东西有什么实际的用处呢？额，其实还真的没啥实际的用处，不过我们当发生异常信息的时候可以友好的弹一个框告诉用户当前发生了异常，是选择上传异常信息继续运行还是直接退出，当然继续运行依然会有Crash风险。&lt;/p&gt;
&lt;p&gt;接下来我们就来实现这么一个事情吧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>iOSCrash信息上报和处理</title>
    <link href="http://lemon2well.top/2018/08/22/iOS%20%E5%BC%80%E5%8F%91/iOSCrash%E4%BF%A1%E6%81%AF%E4%B8%8A%E6%8A%A5%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>http://lemon2well.top/2018/08/22/iOS 开发/iOSCrash信息上报和处理/</id>
    <published>2018-08-22T09:41:36.000Z</published>
    <updated>2018-08-23T01:46:25.542Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发中，最严重的bug估计就是应用奔溃，如果应用奔溃了，除了做好挨骂的准备，还需要冷静的下来去处理这个事情，接下来我们来看看需要做什么事情。</p><h2 id="获取crash信息"><a href="#获取crash信息" class="headerlink" title="获取crash信息"></a>获取crash信息</h2><p>我们首先第一个事情就是要知道应用的奔溃信息是什么，这里有几种方式去获取奔溃信息。</p><ol><li>使用Bugly，友盟等第三方SDK登入后台查看奔溃信息</li><li>代码自动上传奔溃信息到服务器，然后通过恢复dSYM文件来查看奔溃信息</li><li>通过使用当前发生应用奔溃的设备导出相关的奔溃信息</li><li>如果是线上的应用，还可以通过itunesConnect来查看（非即时）</li></ol><a id="more"></a><p>第一种集成第三方SDK的方案基本上不用我们管，只需要根据文档集成即可。<br>下面我们要讲的是第二种和第三种方案，第四种方案其实和第三种方案差不多，为什么要区分这两种方案呢，因为第二种方案中我们可以直接拿到奔溃的堆栈和具体信息，也就是可以看出在那段代码奔溃以及具体的奔溃内容。但是第三种和第四种方案我们拿到的奔溃信息是经过处理的奔溃信息，如下面所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Incident Identifier: 66BAB91F-07F7-4242-B8EF-8CC1771E5EF0</span><br><span class="line">CrashReporter Key:   bb6af27d5f29cc19a8df5dbdff702227fdb1232b</span><br><span class="line">Hardware Model:      iPhone8,1</span><br><span class="line">Process:             testImageSourceCode [25042]</span><br><span class="line">Path:                /private/var/containers/Bundle/Application/C8A371D9-3F19-4A17-A817-5FF35A40C8E7/testImageSourceCode.app/testImageSourceCode</span><br><span class="line">Identifier:          com.cmcc.enterprise-classID.onecardmultinumber.sdk</span><br><span class="line">Version:             1 (1.0)</span><br><span class="line">Code Type:           ARM-64 (Native)</span><br><span class="line">Role:                Foreground</span><br><span class="line">Parent Process:      launchd [1]</span><br><span class="line">Coalition:           com.cmcc.enterprise-classID.onecardmultinumber.sdk [8274]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Date/Time:           2018-08-22 15:35:09.3494 +0800</span><br><span class="line">Launch Time:         2018-08-22 15:35:03.3154 +0800</span><br><span class="line">OS Version:          iPhone OS 11.3.1 (15E302)</span><br><span class="line">Baseband Version:    4.56.00</span><br><span class="line">Report Version:      104</span><br><span class="line"></span><br><span class="line">Exception Type:  EXC_CRASH (SIGABRT)</span><br><span class="line">Exception Codes: 0x0000000000000000, 0x0000000000000000</span><br><span class="line">Exception Note:  EXC_CORPSE_NOTIFY</span><br><span class="line">Triggered by Thread:  0</span><br><span class="line"></span><br><span class="line">Application Specific Information:</span><br><span class="line">abort() called</span><br><span class="line"></span><br><span class="line">Filtered syslog:</span><br><span class="line">None found</span><br><span class="line"></span><br><span class="line">Last Exception Backtrace:</span><br><span class="line">0   CoreFoundation                0x184152d8c __exceptionPreprocess + 228</span><br><span class="line">1   libobjc.A.dylib               0x18330c5ec objc_exception_throw + 55</span><br><span class="line">2   CoreFoundation                0x1840eb750 _CFThrowFormattedException + 111</span><br><span class="line">3   CoreFoundation                0x18401b90c -[__NSArrayI objectAtIndex:] + 131</span><br><span class="line">4   testImageSourceCode           0x100d55ee4 _hidden#0_ + 24292 (__hidden#4_:14)</span><br><span class="line">5   testImageSourceCode           0x100d5ed6c _hidden#425_ + 60780 (__hidden#452_:131)</span><br><span class="line">6   UIKit                         0x18de826c8 -[UIApplication sendAction:to:from:forEvent:] + 95</span><br><span class="line">7   UIKit                         0x18dfa38a4 -[UIControl sendAction:to:forEvent:] + 79</span><br><span class="line">8   UIKit                         0x18de8877c -[UIControl _sendActionsForEvents:withEvent:] + 439</span><br><span class="line">9   UIKit                         0x18dfbe1dc -[UIControl touchesEnded:withEvent:] + 571</span><br><span class="line">10  UIKit                         0x18df05a48 -[UIWindow _sendTouchesForEvent:] + 2427</span><br><span class="line">11  UIKit                         0x18defa8f8 -[UIWindow sendEvent:] + 3159</span><br><span class="line">12  UIKit                         0x18def9238 -[UIApplication sendEvent:] + 339</span><br><span class="line">13  UIKit                         0x18e6dac0c __dispatchPreprocessedEventFromEventQueue + 2339</span><br><span class="line">14  UIKit                         0x18e6dd1b8 __handleEventQueueInternal + 4743</span><br><span class="line">15  UIKit                         0x18e6d6258 __handleHIDEventFetcherDrain + 151</span><br><span class="line">16  CoreFoundation                0x1840fb404 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 23</span><br><span class="line">17  CoreFoundation                0x1840fac2c __CFRunLoopDoSources0 + 275</span><br><span class="line">18  CoreFoundation                0x1840f879c __CFRunLoopRun + 1203</span><br><span class="line">19  CoreFoundation                0x184018da8 CFRunLoopRunSpecific + 551</span><br><span class="line">20  GraphicsServices              0x185ffb020 GSEventRunModal + 99</span><br><span class="line">21  UIKit                         0x18dff978c UIApplicationMain + 235</span><br><span class="line">22  testImageSourceCode           0x100d75ca8 main + 154792 (__hidden#956_:14)</span><br><span class="line">23  libdyld.dylib                 0x183aa9fc0 start + 3</span><br></pre></td></tr></table></figure><p>看到上面的奔溃信息我们是一脸懵逼的，完全看不出是因为哪里的代码导致了错误，这个时候我们就要进行符号化，通过dSYM文件通过奔溃信息的地址找到源码中奔溃的地方。这个我们放到第三点来讲，下面我们先将第二个方案。</p><h2 id="收集Crash信息"><a href="#收集Crash信息" class="headerlink" title="收集Crash信息"></a>收集Crash信息</h2><p>在iOS中，系统给我们提供了<code>NSException</code>这个类来帮助我们收集异常信息。</p><blockquote><p>NSException is used to implement exception handling and contains information about an exception — Apple Documentation.</p></blockquote><p>我们可以看一下这个类里面都包含什么属性和方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface NSException : NSObject &lt;NSCopying, NSCoding&gt; &#123;</span><br><span class="line">    @private</span><br><span class="line">    NSString*name;</span><br><span class="line">    NSString*reason;</span><br><span class="line">    NSDictionary*userInfo;</span><br><span class="line">    idreserved;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSException *)exceptionWithName:(NSExceptionName)name reason:(nullable NSString *)reason userInfo:(nullable NSDictionary *)userInfo;</span><br><span class="line">- (instancetype)initWithName:(NSExceptionName)aName reason:(nullable NSString *)aReason userInfo:(nullable NSDictionary *)aUserInfo NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">@property (readonly, copy) NSExceptionName name;</span><br><span class="line">@property (nullable, readonly, copy) NSString *reason;</span><br><span class="line">@property (nullable, readonly, copy) NSDictionary *userInfo;</span><br><span class="line"></span><br><span class="line">@property (readonly, copy) NSArray&lt;NSNumber *&gt; *callStackReturnAddresses API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line">@property (readonly, copy) NSArray&lt;NSString *&gt; *callStackSymbols API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));</span><br><span class="line"></span><br><span class="line">- (void)raise;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>我们来看看几个比较重要的属性和方法：<br>例如我们碰到一个<code>name: @&quot;NSRangeException&quot; - reason: @&quot;*** -[__NSArrayI objectAtIndex:]: index 3 beyond bounds [0 .. 1]&quot;</code>这样的错误</p><blockquote><ol><li>name : exception的名字，在上面中就是NSRangeException</li><li>reason : exception的原因，这是我们修复的最主要的提示。也就是上面的[__NSArrayI objectAtIndex:]: index 3 beyond bounds [0 .. 1]。</li><li>userInfo : 其他信息，一般用于自定义的时候传递一些其他的信息。</li><li>callStackSymbols : 这个产生Exception的调用栈，从下到上。</li><li>raise方法，这个方法就是让系统产生Exception，例如我们的APP如果检测到正在被其他不怀好意的人调试的时候，可以创建一个NSException的方法，然后调用raise直接闪退，不过他也有可能hook了这个方法，这里就不多说了。</li></ol></blockquote><p>既然我们知道了有这么一个类，那我们如何来捕捉系统异常呢，Crash分为两种，一种是由EXC_BAD_ACCESS引起的，原因是访问了不属于本进程的内存地址，有可能是访问已被释放的内存；另一种是未被捕获的Objective-C异常（NSException），导致程序向自身发送了SIGABRT信号而崩溃。其实对于未捕获的Objective-C异常，我们是有办法将它记录下来的。</p><p>我们先说第一种，第一种就是我们上面所说的Exception，系统提供了一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT void NSSetUncaughtExceptionHandler(NSUncaughtExceptionHandler * _Nullable);</span><br></pre></td></tr></table></figure><p>方法来捕获异常，这个方法一般会在程序启动的时候就调用一次，这样才能保证捕获所有的异常。<br>在APPDelegate的didFinishLaunch方法中 调用  <code>NSSetUncaughtExceptionHandler(&amp;CrashExceptionHandler);</code><br>然后增加一个方法的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void CrashExceptionHandler(NSException *exception)&#123;</span><br><span class="line">    NSArray *callStack = [exception callStackSymbols];</span><br><span class="line">    NSString *reson = [exception reason];</span><br><span class="line">    NSString *name = [exception name];</span><br><span class="line">   //TODO: 保存奔溃信息到本地，下次启动的时候上传到服务器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看看第二种异常，这种异常通过上面的方法无法捕捉，但是系统会发送一个信号，我们可以通过注册对应的Signal信息来监听是否捕捉到系统发出的异常信号。</p><p>同样是在APPDelaget中加入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGABRT, SignalExceptionHandler);</span><br><span class="line">signal(SIGILL, SignalExceptionHandler);</span><br><span class="line">signal(SIGSEGV, SignalExceptionHandler);</span><br><span class="line">signal(SIGFPE, SignalExceptionHandler);</span><br><span class="line">signal(SIGBUS, SignalExceptionHandler);</span><br><span class="line">signal(SIGPIPE, SignalExceptionHandler);</span><br></pre></td></tr></table></figure><p>然后实现 <code>SignalExceptionHandler</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void SignalExceptionHandler(int signal)&#123;</span><br><span class="line">    NSArray *callStack = [LMExceptionHandler backtrace];</span><br><span class="line">    NSLog(@&quot;信号捕获崩溃，堆栈信息：%@&quot;,callStack);</span><br><span class="line">    NSString *name = LMSignalException;</span><br><span class="line">    NSString *reason = [NSString stringWithFormat:@&quot;signal %d was raised&quot;,signal];</span><br><span class="line">    //TODO: 保存信息上传到本地</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSArray *)backtrace</span><br><span class="line">&#123;</span><br><span class="line">    void* callstack[128];</span><br><span class="line">    int frames = backtrace(callstack, 128);</span><br><span class="line">    char **strs = backtrace_symbols(callstack, frames);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];</span><br><span class="line">    for (int i = 0; i &lt; frames; i++) &#123;</span><br><span class="line">        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    free(strs);</span><br><span class="line">    </span><br><span class="line">    return backtrace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上的方法我们已经可以捕获到系统的crash信息，从而根据信息修复相关的bug。</p><h2 id="通过Xcode查看Crash信息"><a href="#通过Xcode查看Crash信息" class="headerlink" title="通过Xcode查看Crash信息"></a>通过Xcode查看Crash信息</h2><p>如果奔溃发生在我们测试的设备上面，那么奔溃信息是保存到我们手机本地的，这个时候我们可以通过xcode来查看。</p><p>手机连接电脑，然后打开Xcode，点击Window-&gt;Devices And Simulators-&gt;左侧选择对应的设备，然后右侧点击View Device Logs，然后就可以看到以下的奔溃信息，你可以在搜索出对应的APP也可以根据时间来排序找到对应的那一条奔溃信息。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15349278888373.jpg" alt=""></p><p>如上图所示我们其实是看不出具体的错误信息以及堆栈信息的，根据这些我们很难再代码中找到导致奔溃的代码在哪里。接下来我们就要开始通过dSYM文件找到对应的堆栈。</p><h2 id="dSYM"><a href="#dSYM" class="headerlink" title="dSYM"></a>dSYM</h2><p>进行崩溃分析，首先要弄懂一个概念，就是符号集。</p><blockquote><p>符号集是我们对ipa文件进行打包之后，和.app文件同级的后缀名为.dSYM的文件，这个文件必须使用Xcode进行打包才有。<br>每一个.dSYM文件都有一个UUID，和.app文件中的UUID对应，代表着是一个应用。而.dSYM文件中每一条崩溃信息也有一个单独的UUID，用来和程序的UUID进行校对。<br>我们如果不使用.dSYM文件获取到的崩溃信息都是不准确的。<br>符号集中存储着文件名、方法名、行号的信息，是和可执行文件的16进制函数地址对应的，通过分析崩溃的.Crash文件可以准确知道具体的崩溃信息。<br>我们每次Archive一个包之后，都会随之生成一个dSYM文件。每次发布一个版本，我们都需要备份这个文件，以方便以后的调试。进行崩溃信息符号化的时候，必须使用当前应用打包的电脑所生成的dSYM文件，其他电脑生成的文件可能会导致分析不准确的问题。</p></blockquote><h2 id="符号化crash信息"><a href="#符号化crash信息" class="headerlink" title="符号化crash信息"></a>符号化crash信息</h2><p>当程序崩溃的时候，我们可以获得到崩溃的错误堆栈，但是这个错误堆栈都是0x开头的16进制地址，需要我们使用Xcode自带的atos工具或者<a href="https://github.com/answer-huang/dSYMTools" target="_blank" rel="noopener">dSYMTools</a>来将.Crash和.dSYM文件进行符号化，就可以得到详细崩溃的信息。</p><p>那我们如何得到dSYM文件呢</p><blockquote><p>先打开Xcode，Windows-&gt;Organize-&gt;找到对应的app包，然后右键-&gt;Show in finder,找到appName. xcarchive-&gt;显示包内容-&gt;把dSYMs拷贝出来(或者就在里面操作)。</p></blockquote><p>我们可以新建一个CrashFolder的文件夹，然后将上面的dSYMs文件拷贝到该文件夹中，然后我们还需要找到上面的Crash信息，然后右键导出该Crash信息，同样拷贝到CrashFolder文件夹中，接下来我们就可以利用atos来将Crash文件中的地址还原为代码。</p><p>atos的基本用法为：</p><p><code>$ atos -arch &lt;Binary Architecture&gt; -o &lt;Path to dSYM file&gt;/Contents/Resources/DWARF/&lt;binary image name&gt; -l &lt;load address&gt; &lt;address to symbolicate&gt;</code></p><p>在我本地中，我执行的是：<code>atos -arch arm64 -o testImageSourceCode.app.dSYM/Contents/Resources/DWARF/testImageSourceCode -l 0x100d50000 0x100d55ee4</code></p><p>在上述命令中，需要解释的可能就是-l后面的两个参数，第一个参数是程序的基地址，也就是在crash文件中，在 <code>Binary Images:</code>下面的第一行中的第一个以0X开头的地址，然后第二个参数就是Crash文件中错误信息的地址，执行完上述命令之后输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[LMTool test] (in testImageSourceCode) (LMTool.m:15)</span><br></pre></td></tr></table></figure><p>字符串，该字符串就是对应代码中的方法以及对应的文件里面的行数。</p><p>另外一个方法就是使用一个第三方工具<a href="https://github.com/answer-huang/dSYMTools" target="_blank" rel="noopener">dSYMTools</a>这里的用法和我们上述的差不多，只不过那里是可视化工具。</p><p>完整的<a href="https://github.com/codemonkeybulucck/CrashCatchDemo" target="_blank" rel="noopener">demo</a>已经上传到Github。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发中，最严重的bug估计就是应用奔溃，如果应用奔溃了，除了做好挨骂的准备，还需要冷静的下来去处理这个事情，接下来我们来看看需要做什么事情。&lt;/p&gt;
&lt;h2 id=&quot;获取crash信息&quot;&gt;&lt;a href=&quot;#获取crash信息&quot; class=&quot;headerlink&quot; title=&quot;获取crash信息&quot;&gt;&lt;/a&gt;获取crash信息&lt;/h2&gt;&lt;p&gt;我们首先第一个事情就是要知道应用的奔溃信息是什么，这里有几种方式去获取奔溃信息。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用Bugly，友盟等第三方SDK登入后台查看奔溃信息&lt;/li&gt;
&lt;li&gt;代码自动上传奔溃信息到服务器，然后通过恢复dSYM文件来查看奔溃信息&lt;/li&gt;
&lt;li&gt;通过使用当前发生应用奔溃的设备导出相关的奔溃信息&lt;/li&gt;
&lt;li&gt;如果是线上的应用，还可以通过itunesConnect来查看（非即时）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>NSRunLoop与iOS中的倒计时（GCD,CADisplaylink,NSTimer）</title>
    <link href="http://lemon2well.top/2018/08/20/iOS%20%E5%BC%80%E5%8F%91/NSRunLoop%E4%B8%8EiOS%E4%B8%AD%E7%9A%84%E5%80%92%E8%AE%A1%E6%97%B6%EF%BC%88GCD-CADisplaylink-NSTimer%EF%BC%89/"/>
    <id>http://lemon2well.top/2018/08/20/iOS 开发/NSRunLoop与iOS中的倒计时（GCD-CADisplaylink-NSTimer）/</id>
    <published>2018-08-20T03:17:45.000Z</published>
    <updated>2018-08-20T03:18:42.822Z</updated>
    
    <content type="html"><![CDATA[<p>相信在iOS开发中大家都用过倒计时的功能，而NSTimer也是大家用得最多用来实现该功能的类，但是可能有人不太清楚NSTimer存在计时不准并且可能会导致引用循环资源无法释放的情况，接下来我会介绍一下使用GCD以及CADisplaylink来实现倒计时以及他们三者的利弊。</p><h2 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h2><p>在开始介绍下面三种方法之前，我想我们有必要先来介绍一下RunLoop，因为CADisplaylink和NSTimer都是需要通过运行在RunLoop里面才保证了每次到特定的时间点就会执行对应的事件</p><a id="more"></a><h2 id="RunLoop是什么"><a href="#RunLoop是什么" class="headerlink" title="RunLoop是什么"></a>RunLoop是什么</h2><p>一般来说线程只能执行一次任务，执行完任务之后就会退出，可是如果需要处理多个任务呢，那就需要RunLoop来保证线程能随时处理事件并且不会退出。</p><p>RunLoop实际上像是一个对象，该对象提供了一个入口函数，该入口函数会实现像不断的循环获取任务执行任务的功能，当线程执行了这个入口函数之后，就会一直处于函数内部：接受任务-&gt;等待-&gt;处理这样的循环中，知道接受到quit消息，就会推出该入口函数，然后线程销毁。</p><h2 id="RunLoop和线程之间的关系"><a href="#RunLoop和线程之间的关系" class="headerlink" title="RunLoop和线程之间的关系"></a>RunLoop和线程之间的关系</h2><p>RunLoop和线程是一一对应的，它们通过key-value的形式保存在一个全局的字典里面（key是p_thread,value是CFRunLoopRef），iOS中不允许直接创建RunLoop，可以通过两个方法获取RunLoop ，CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个方法内部会调用<code>CFRunLoopRef _CFRunLoopGet(pthread_t thread)</code>方法，调用该方法时，会优先判断该字典是不是为空，如果是的话就创建一个以pthread_main_thread_np()为key的runloop并且放到字典里面。然后在字典中寻找thread为key的runloop，如果不存在则创建一个新的RunLoop并且注册一个回调，当线程销毁时，也销毁RunLoop。</p><h2 id="RunLoopMode"><a href="#RunLoopMode" class="headerlink" title="RunLoopMode"></a>RunLoopMode</h2><p>苹果提供了两个公开的RunLoopMode，NSDefaultRunLoop以及UITrackingRunLoopMode，第一个mode程序默认的mode，当程序中有ScrollView滚动的时候，RunLoop就会将当前的mode切换为UITrackingRunLoopMode。</p><blockquote><p>相信很多人都有过NSTimer在默认情况下可用，当APP有ScrollView在滚动的时候就不可用的回调，那是因为NSTimer加到runloop里面的时候默认是NSDefaultRunLoop，当页面滑动的时候RunLoop切换到了UITrackingRunLoopMode，所以timer就不起作用了，这个时候需要使用<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code>将timer标记为NSRunLoopCommonModes，NSRunLoopCommonModes默认是包含了NSDefaultRunLoop和UITrackingRunLoopMode两个model。</p></blockquote><h2 id="RunLoop的结构"><a href="#RunLoop的结构" class="headerlink" title="RunLoop的结构"></a>RunLoop的结构</h2><p>我们首先来看一下RunLoop的都包含什么东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_CFRunLoop:</p><ul><li><p>_commonModes： 一个标记为common的集合，通过<code>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</code>可以将一个mode加到commonModes里面，当RunLoop的内容变化的时候，RunLoop都会将Timer/Observer/Sources同步到标记为“common”的Mode里面</p></li><li><p>_commonModeItems： 被加到CommonModes里面的所有的Item的集合，一个Item包含_source0,_source1,_observers，_timers。</p></li><li><p>_currentMode： 当前RunLoop的mode，可以通过 <code>CFRunLoopRunInMode(CFStringRef modeName, ...);</code>来切换mode</p></li><li><p>_modes：RunLoop包含的mode</p></li></ul><p>_CFRunLoopMode:</p><ul><li><p>source0(CFRunLoopSourceRef)： mode的事件源，source0只包含一个回调（函数指针），它并不会自动触发，需要先调用 <code>CFRunLoopSourceSinal(source)</code>将source标为待处理，然后调用<code>CFRunLoopSourceWakeUp(source)</code>来唤醒RunLoop才会调用这个方法。</p></li><li><p>_sources1(CFRunLoopSourceRef)： mode的另外一个事件源，source1包含了回调以及一个mach-port，被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程</p></li><li><p>_timers: 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）</p></li><li><p>_observers: 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</p></li></ul><p>更多的关于RunLoop的内容可以看<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p><h2 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h2><p>我们通常会使用以下的代码来创建一个Timer并且将Timer加到RunLoop里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sellf.timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(doSomeThing) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p>以上的代码会有两个问题：</p><ol><li>内存泄漏的问题，首先RunLoop会强引用timer，而timer会强引用self,所以timer不释放的时候，self也无法释放。通常我们会用以下的代码来释放Timer，但是需要找一个合适的时机去释放它，加入我们像以下代码那样在viewWillDisapper那样释放它，当回到主屏幕的时候那timer又要被销毁了，然后重新进入重新创建一个timer，这样就会非常麻烦，需要多个地方维护timer的状态。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillDisappear:(BOOL)animated&#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    self.timer  = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显我们这里要解决的就是timer的释放时机的问题，我们当然是希望持有timer的视图控制器执行dealloc释放的时候释放它，但是这时候千万别企图在dealloc方法里面做这个事情，原因自己想。</p><p>我们的思路就是通过创建一个MagicClass来弱应用这个target，然后timer的target强引用这个MagicClass，执行MagicClass的一个替身Action，在这个Action里面我们可以判断target是不是被销毁了（因为这个时候没有Timer强引用它，所以不会有有内存泄漏的问题），然后没有被销毁则执行真正的Action，如果Target已经被销毁了则调用invalidate销毁timer。</p><p>here is the code</p><p>NSTimer+LMExtension.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSTimer (LMExtension)</span><br><span class="line">+ (instancetype)lmScheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)target selector:(SEL)selector userInfo:(id)userInfo;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>NSTimer+LMExtension.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSTimer+LMExtension.h&quot;</span><br><span class="line"></span><br><span class="line">@interface LMMagicTarget : NSObject</span><br><span class="line">@property (nonatomic, weak) id target;</span><br><span class="line">@property (nonatomic, assign) SEL selector;</span><br><span class="line">@property (nonatomic, weak) NSTimer *timer;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation LMMagicTarget</span><br><span class="line">- (void)LMTimerStarAction:(NSTimer *)timer</span><br><span class="line">&#123;</span><br><span class="line">    if (self.target) &#123;</span><br><span class="line">        [self.target performSelector:self.selector withObject:timer afterDelay:0.0];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.timer invalidate];</span><br><span class="line">        self.timer = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation NSTimer (LMExtension)</span><br><span class="line">+ (instancetype)lmScheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)target selector:(SEL)selector userInfo:(id)userInfo&#123;</span><br><span class="line">    LMMagicTarget *magicTarget = [[LMMagicTarget alloc]init];</span><br><span class="line">    magicTarget.target = target;</span><br><span class="line">    magicTarget.selector = selector;</span><br><span class="line">    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:interval target:magicTarget selector:@selector(LMTimerStarAction:) userInfo:nil repeats:YES];</span><br><span class="line">    magicTarget.timer = timer;</span><br><span class="line">    return  timer;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ol start="2"><li>第二个问题，精度问题。NSTimer其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的，一个timer注册好后，RunLoop会在其重复的时间点注册事件，但是如果这个时候RunLoop正在处理一个其他任务的时候，错过了该事件点，则该次不会执行timer的事件源，会跳过当前时间点，直到下一个时间点才执行该timer的事件源。所以timer会有一个Tolerance的属性，这属性就是宽容度，该属性标记当时间点到了后，容许有多少的误差。</li></ol><h2 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h2><p>CADisplayLink是一个以屏幕刷新频率同步的计时器。以下是创建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建方法</span><br><span class="line">self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink:)];    </span><br><span class="line">[self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">停止方法</span><br><span class="line">[self.displayLink invalidate];  </span><br><span class="line">self.displayLink = nil;</span><br></pre></td></tr></table></figure><p>CADisplayLink的计算时间并不依靠RunLoop，当一个屏幕刷新完成时候则会通知RunLoop给对应的target执行action。但是CADisplayLink依然会有精度的问题，当两次界面刷新之间执行了一次长任务的时候，那就会有一帧被跳过去，也就是所谓的掉帧，那相应的此次也不会调用target的action。</p><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>GCD提供了一个计时的方法，GCD定时器的底层是由XNU内核中的select方法实现的。具体的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW , 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</span><br><span class="line">    dispatch_source_set_event_handler(self.timer, ^&#123;</span><br><span class="line">        NSLog(@&quot;GCD&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    //开启定时器</span><br><span class="line">    dispatch_resume(self.timer);</span><br><span class="line">    </span><br><span class="line">    //销毁定时器</span><br><span class="line">    dispatch_source_cancel(self.timer);</span><br><span class="line">    self.timer = nil;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果是对时间的要求不精确的计算，可以使用NSTimer，如果是对时间比较精确的，可以使用GCD提供的倒计时方法。如果是实现动画，需要高频率的绘制，可以使用CADisplayLink。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信在iOS开发中大家都用过倒计时的功能，而NSTimer也是大家用得最多用来实现该功能的类，但是可能有人不太清楚NSTimer存在计时不准并且可能会导致引用循环资源无法释放的情况，接下来我会介绍一下使用GCD以及CADisplaylink来实现倒计时以及他们三者的利弊。&lt;/p&gt;
&lt;h2 id=&quot;RunLoop&quot;&gt;&lt;a href=&quot;#RunLoop&quot; class=&quot;headerlink&quot; title=&quot;RunLoop&quot;&gt;&lt;/a&gt;RunLoop&lt;/h2&gt;&lt;p&gt;在开始介绍下面三种方法之前，我想我们有必要先来介绍一下RunLoop，因为CADisplaylink和NSTimer都是需要通过运行在RunLoop里面才保证了每次到特定的时间点就会执行对应的事件&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>图文混排的四种方案</title>
    <link href="http://lemon2well.top/2018/08/15/iOS%20%E5%BC%80%E5%8F%91/%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
    <id>http://lemon2well.top/2018/08/15/iOS 开发/图文混排的四种方案/</id>
    <published>2018-08-15T09:12:26.000Z</published>
    <updated>2018-08-15T09:21:15.954Z</updated>
    
    <content type="html"><![CDATA[<p>图文混排有多种方式可以实现，下面我会用四种不同的方式来实现以下界面的效果，并且说明他们的优缺点。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/screenshot.png" alt="screenshot"></p><h2 id="NSAttributedString"><a href="#NSAttributedString" class="headerlink" title="NSAttributedString"></a>NSAttributedString</h2><blockquote><p>NSAttributedString提供了自由并且多样式的富文本设置，图文混排的实现是通过插入NSTestAttachment来实现。</p></blockquote><a id="more"></a><p>talk is cheap ，here is the code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//调用</span><br><span class="line">NSString *originStr = @&quot; Hi ALL,这是我的博客：lemon2well.top，欢迎来到我的博客，环欢迎评论留言一起交流。&quot;;</span><br><span class="line">    NSString *targetStr = @&quot;lemon2well.top&quot;;</span><br><span class="line">    NSString *imageName = @&quot;trumpet&quot;;</span><br><span class="line">    self.label.attributedText = [self attribuStringWithString:originStr targetString:targetStr image:imageName];</span><br><span class="line"></span><br><span class="line">//方法</span><br><span class="line">- (NSAttributedString*)attribuStringWithString:(NSString*)string targetString:(NSString *)target image:(NSString*)imageName&#123;</span><br><span class="line">    NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc]initWithString:string attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">    </span><br><span class="line">    NSRange linkRange = [string rangeOfString:target];</span><br><span class="line">    if (linkRange.length != 0) &#123;</span><br><span class="line">        //添加可点击链接</span><br><span class="line">        [attributedStr addAttribute:NSLinkAttributeName value:[NSURL URLWithString:@&quot;lemon2well.top&quot;] range:linkRange];</span><br><span class="line">        [attributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:linkRange];</span><br><span class="line">        //添加下划线</span><br><span class="line">        [attributedStr addAttribute:NSUnderlineStyleAttributeName value:@1 range:linkRange];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //添加图片</span><br><span class="line">    NSTextAttachment *attachment = [[NSTextAttachment alloc]init];</span><br><span class="line">    attachment.image = [UIImage imageNamed:imageName];</span><br><span class="line">    attachment.bounds = CGRectMake(0, 0, 20 ,20);</span><br><span class="line">    NSAttributedString *imageStr = [NSAttributedString attributedStringWithAttachment:attachment];</span><br><span class="line">    //插入图片</span><br><span class="line">    [attributedStr insertAttributedString:imageStr atIndex:0];</span><br><span class="line">    </span><br><span class="line">    // 段落样式</span><br><span class="line">    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init];</span><br><span class="line">    // 行间距</span><br><span class="line">    [style setLineSpacing:3];</span><br><span class="line">    // 段落间距</span><br><span class="line">    [style setParagraphSpacing:10];</span><br><span class="line">    // 首行缩进</span><br><span class="line">    [style setFirstLineHeadIndent:25];</span><br><span class="line">    [attributedStr addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, string.length-1)];</span><br><span class="line">    </span><br><span class="line">    return attributedStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是NSAttributedString的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// NSFontAttributeName                设置字体属性，默认值：字体：Helvetica(Neue) 字号：12</span><br><span class="line">// NSForegroundColorAttributeNam      设置字体颜色，取值为 UIColor对象，默认值为黑色</span><br><span class="line">// NSBackgroundColorAttributeName     设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色</span><br><span class="line">// NSLigatureAttributeName            设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符</span><br><span class="line">// NSKernAttributeName                设定字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄</span><br><span class="line">// NSStrikethroughStyleAttributeName  设置删除线，取值为 NSNumber 对象（整数）</span><br><span class="line">// NSStrikethroughColorAttributeName  设置删除线颜色，取值为 UIColor 对象，默认值为黑色</span><br><span class="line">// NSUnderlineStyleAttributeName      设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似</span><br><span class="line">// NSUnderlineColorAttributeName      设置下划线颜色，取值为 UIColor 对象，默认值为黑色</span><br><span class="line">// NSStrokeWidthAttributeName         设置笔画宽度，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果</span><br><span class="line">// NSStrokeColorAttributeName         填充部分颜色，不是字体颜色，取值为 UIColor 对象</span><br><span class="line">// NSShadowAttributeName              设置阴影属性，取值为 NSShadow 对象</span><br><span class="line">// NSTextEffectAttributeName          设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用：</span><br><span class="line">// NSBaselineOffsetAttributeName      设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏</span><br><span class="line">// NSObliquenessAttributeName         设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾</span><br><span class="line">// NSExpansionAttributeName           设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本</span><br><span class="line">// NSWritingDirectionAttributeName    设置文字书写方向，从左向右书写或者从右向左书写</span><br><span class="line">// NSVerticalGlyphFormAttributeName   设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本</span><br><span class="line">// NSLinkAttributeName                设置链接属性，点击后调用浏览器打开指定URL地址</span><br><span class="line">// NSAttachmentAttributeName          设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排</span><br><span class="line">// NSParagraphStyleAttributeName      设置文本段落排版格式，取值为 NSParagraphStyle 对象</span><br></pre></td></tr></table></figure><p>NSParagraphStyle的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];  </span><br><span class="line">paragraphStyle.lineSpacing = 10;// 字体的行间距  </span><br><span class="line">paragraphStyle.firstLineHeadIndent = 20.0f;//首行缩进  </span><br><span class="line">paragraphStyle.alignment = NSTextAlignmentJustified;//（两端对齐的）文本对齐方式：（左，中，右，两端对齐，自然）  </span><br><span class="line">paragraphStyle.lineBreakMode = NSLineBreakByTruncatingTail;//结尾部分的内容以……方式省略 ( &quot;...wxyz&quot; ,&quot;abcd...&quot; ,&quot;ab...yz&quot;)  </span><br><span class="line">paragraphStyle.headIndent = 20;//整体缩进(首行除外)  </span><br><span class="line">paragraphStyle.tailIndent = 20;//  </span><br><span class="line">paragraphStyle.minimumLineHeight = 10;//最低行高  </span><br><span class="line">paragraphStyle.maximumLineHeight = 20;//最大行高  </span><br><span class="line">paragraphStyle.paragraphSpacing = 15;//段与段之间的间距  </span><br><span class="line">paragraphStyle.paragraphSpacingBefore = 22.0f;//段首行空白空间/* Distance between the bottom of the previous paragraph (or the end of its paragraphSpacing, if any) and the top of this paragraph. */  </span><br><span class="line">paragraphStyle.baseWritingDirection = NSWritingDirectionLeftToRight;//从左到右的书写方向（一共➡️三种）  </span><br><span class="line">paragraphStyle.lineHeightMultiple = 15;/* Natural line height is multiplied by this factor (if positive) before being constrained by minimum and maximum line height. */  </span><br><span class="line">paragraphStyle.hyphenationFactor = 1;//连字属性 在iOS，唯一支持的值分别为0和1</span><br></pre></td></tr></table></figure><h2 id="TextView-UIImageview"><a href="#TextView-UIImageview" class="headerlink" title="TextView + UIImageview"></a>TextView + UIImageview</h2><blockquote><p> 以上的效果同样可以使用UITextView + UIImageView来实现，该方法主要利用了textview的textContainer.exclusionPaths属性</p></blockquote><p>// Default value : empty array  An array of UIBezierPath representing the exclusion paths inside the receiver’s bounding rect.<br>@property (copy, NS_NONATOMIC_IOSONLY) NSArray<uibezierpath *=""> *exclusionPaths NS_AVAILABLE(10_11, 7_0);</uibezierpath></p><p>按照文档的说明我们可以提供一个元素为UIBezierPath的数组，这样文字的描绘就会避开这些路径。从而实现图文混排的效果。不过这种方式最适合用于文字环绕的效果，所有的文字把图片包围住。</p><p>here is the code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 调用</span><br><span class="line"> UITextView *textView = [[UITextView alloc]init];</span><br><span class="line">    textView.frame = CGRectMake(20, 200, 335, 150);</span><br><span class="line">    textView.attributedText = [self textViewAttributestring];</span><br><span class="line">    [textView sizeToFit];</span><br><span class="line">    [self.view addSubview:textView];</span><br><span class="line">    self.textView = textView;</span><br><span class="line">    </span><br><span class="line">    UIImageView *imageView = [[UIImageView alloc]init];</span><br><span class="line">    imageView.frame = CGRectMake(45, 210, 20, 20);</span><br><span class="line">    imageView.image = [UIImage imageNamed:@&quot;trumpet&quot;];</span><br><span class="line">    [self.view addSubview:imageView];</span><br><span class="line">    self.imageView = imageView;</span><br><span class="line">    textView.textContainer.exclusionPaths = @[[self translatedBezierPath]];</span><br><span class="line">    </span><br><span class="line">//方法：</span><br><span class="line">- (UIBezierPath *)translatedBezierPath</span><br><span class="line">&#123;</span><br><span class="line">    //计算出imageView相对于textView的相对坐标</span><br><span class="line">    CGRect imageRect = [self.textView</span><br><span class="line">                        convertRect:self.imageView.frame fromView:self.view];</span><br><span class="line">    UIBezierPath *bezierPath = [UIBezierPath bezierPathWithRect:CGRectMake(imageRect.origin.x, imageRect.origin.y-10, imageRect.size.width, imageRect.size.height)];</span><br><span class="line">    return bezierPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSAttributedString*)textViewAttributestring&#123;</span><br><span class="line">    NSString *originStr = @&quot; Hi ALL,这是我的博客：lemon2well.top，欢迎来到我的博客，环欢迎评论留言一起交流。&quot;;</span><br><span class="line">    NSString *targetStr = @&quot;lemon2well.top&quot;;</span><br><span class="line">    </span><br><span class="line">    NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc]initWithString:originStr attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">    </span><br><span class="line">    NSRange linkRange = [originStr rangeOfString:targetStr];</span><br><span class="line">    if (linkRange.length != 0) &#123;</span><br><span class="line">        //添加可点击链接</span><br><span class="line">        [attributedStr addAttribute:NSLinkAttributeName value:[NSURL URLWithString:targetStr] range:linkRange];</span><br><span class="line">        [attributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:linkRange];</span><br><span class="line">        //添加下划线</span><br><span class="line">        [attributedStr addAttribute:NSUnderlineStyleAttributeName value:@1 range:linkRange];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 段落样式</span><br><span class="line">    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init];</span><br><span class="line">    // 行间距</span><br><span class="line">    [style setLineSpacing:3];</span><br><span class="line">    // 段落间距</span><br><span class="line">    [style setParagraphSpacing:10];</span><br><span class="line">    // 首行缩进</span><br><span class="line">    [style setFirstLineHeadIndent:25];</span><br><span class="line">    [attributedStr addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, originStr.length-1)];</span><br><span class="line">    </span><br><span class="line">    return attributedStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CoreText"><a href="#CoreText" class="headerlink" title="CoreText"></a>CoreText</h2><p>coreText给我的感觉就是太难用了，但是可创造性又很高，因为CoreText是属于比较底层的框架，所以基本上都是使用的C的方法，CoreText可以实现很复杂的图文混排而且渲染速度更快。</p><p>CoreText来实现图文混排实际上分为以下的几步:</p><blockquote><p>获得上下文，翻转坐标系 -&gt; 创建NSAttributeString -&gt; 创建空白占位图片，创建代理 -&gt; 实现代理 -&gt; 创建CTFrameRef,CTFrameDraw绘制 -&gt; 计算图片坐标，CGContextDrawImage绘制 -&gt; 释放资源</p></blockquote><p><img src="http://pcd17v2u0.bkt.clouddn.com/15343172514431.jpg" alt=""></p><blockquote></blockquote><p>CFAttributedStringRef ：属性字符串，用于存储需要绘制的文字字符和字符属性<br>CTFramesetterRef：通过CFAttributedStringRef进行初始化，作为CTFrame对象的生产工厂，负责根据path创建对应的CTFrame<br>CTFrame：用于绘制文字的类，可以通过CTFrameDraw函数，直接将文字绘制到context上<br>CTLine：在CTFrame内部是由多个CTLine来组成的，每个CTLine代表一行<br>CTRun：每个CTLine又是由多个CTRun组成的，每个CTRun代表一组显示风格一致的文本<br>实际上CoreText是不直接支持绘制图片的，但是我们可以先在需要显示图片的地方用一个特殊的空白占位符代替，同时设置该字体的CTRunDelegate信息为要显示的图片的宽度和高度，这样绘制文字的时候就会先把图片的位置留出来，再在drawRect方法里面用CGContextDrawImage绘制图片。</p><p>Here is the code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">-(void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);</span><br><span class="line">    CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot; Hi ALL,这是我的博客：lemon2well.top，欢迎来到我的博客，环欢迎评论留言一起交流。&quot; attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">    NSString *targetStr = @&quot;lemon2well.top&quot;;</span><br><span class="line">    </span><br><span class="line">    NSRange linkRange = [attributeStr.string rangeOfString:targetStr];</span><br><span class="line">    if (linkRange.length != 0) &#123;</span><br><span class="line">        //添加可点击链接</span><br><span class="line">        [attributeStr addAttribute:NSLinkAttributeName value:[NSURL URLWithString:targetStr] range:linkRange];</span><br><span class="line">        [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:linkRange];</span><br><span class="line">        //添加下划线</span><br><span class="line">        [attributeStr addAttribute:NSUnderlineStyleAttributeName value:@1 range:linkRange];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 段落样式</span><br><span class="line">    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init];</span><br><span class="line">    // 行间距</span><br><span class="line">    [style setLineSpacing:3];</span><br><span class="line">    // 段落间距</span><br><span class="line">    [style setParagraphSpacing:10];</span><br><span class="line">    // 首行缩进</span><br><span class="line">    [style setFirstLineHeadIndent:25];</span><br><span class="line">    [attributeStr addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, attributeStr.length-1)];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    CTRunDelegateCallbacks callBacks;</span><br><span class="line">    memset(&amp;callBacks,0,sizeof(CTRunDelegateCallbacks));</span><br><span class="line">    callBacks.version = kCTRunDelegateVersion1;</span><br><span class="line">    callBacks.getAscent = ascentCallBacks;</span><br><span class="line">    callBacks.getDescent = descentCallBacks;</span><br><span class="line">    callBacks.getWidth = widthCallBacks;</span><br><span class="line">    NSDictionary * dicPic = @&#123;@&quot;height&quot;:@16,@&quot;width&quot;:@16&#125;;</span><br><span class="line">    CTRunDelegateRef delegate = CTRunDelegateCreate(&amp; callBacks, (__bridge void *)dicPic);</span><br><span class="line">    unichar placeHolder = 0xFFFC;</span><br><span class="line">    NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];</span><br><span class="line">    NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];</span><br><span class="line">    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);</span><br><span class="line">    CFRelease(delegate);</span><br><span class="line">    [attributeStr insertAttributedString:placeHolderAttrStr atIndex:0];</span><br><span class="line">    CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);</span><br><span class="line">    CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">    CGPathAddRect(path, NULL, self.bounds);</span><br><span class="line">    NSInteger length = attributeStr.length;</span><br><span class="line">    CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, length), path, NULL);</span><br><span class="line">    CTFrameDraw(frame, context);</span><br><span class="line">    </span><br><span class="line">    UIImage * image = [UIImage imageNamed:@&quot;trumpet&quot;];</span><br><span class="line">    CGRect imgFrm = [self calculateImageRectWithFrame:frame];</span><br><span class="line">    CGContextDrawImage(context,imgFrm, image.CGImage);</span><br><span class="line">    CFRelease(frame);</span><br><span class="line">    CFRelease(path);</span><br><span class="line">    CFRelease(frameSetter);</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat ascentCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;height&quot;] floatValue];</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat descentCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat widthCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;width&quot;] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(CGRect)calculateImageRectWithFrame:(CTFrameRef)frame</span><br><span class="line">&#123;</span><br><span class="line">    NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);</span><br><span class="line">    NSInteger count = [arrLines count];</span><br><span class="line">    CGPoint points[count];</span><br><span class="line">    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);</span><br><span class="line">    for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">        CTLineRef line = (__bridge CTLineRef)arrLines[i];</span><br><span class="line">        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);</span><br><span class="line">        for (int j = 0; j &lt; arrGlyphRun.count; j ++) &#123;</span><br><span class="line">            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];</span><br><span class="line">            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];</span><br><span class="line">            if (delegate == nil) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            NSDictionary * dic = CTRunDelegateGetRefCon(delegate);</span><br><span class="line">            if (![dic isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            CGPoint point = points[i];</span><br><span class="line">            CGFloat ascent;</span><br><span class="line">            CGFloat descent;</span><br><span class="line">            CGRect boundsRun;</span><br><span class="line">            boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</span><br><span class="line">            boundsRun.size.height = ascent + descent;</span><br><span class="line">            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</span><br><span class="line">            boundsRun.origin.x = point.x + xOffset;</span><br><span class="line">            boundsRun.origin.y = point.y - descent;</span><br><span class="line">            CGPathRef path = CTFrameGetPath(frame);</span><br><span class="line">            CGRect colRect = CGPathGetBoundingBox(path);</span><br><span class="line">            CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);</span><br><span class="line">            return imageBounds;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return CGRectZero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="YYText"><a href="#YYText" class="headerlink" title="YYText"></a>YYText</h2><p><a href="https://github.com/ibireme/YYText" target="_blank" rel="noopener">YYText</a><br>YYText是大神郭曜源开发的一个强大的展示和编辑富文本的第三方工具，里面提供了丰富的与富文本开发相关的方法，具体的可以到github里面看。YYText是基于CoreText向上封装了一层，所以对开发者更加友好，如果在项目中运用到大量的富文本的地方建议可以用YYText。</p><p>here is the code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">YYLabel *label = [[YYLabel alloc]init];</span><br><span class="line">  label.numberOfLines = 0 ;</span><br><span class="line">  label.frame = CGRectMake(0, 200, 375, 200);</span><br><span class="line">  [self.view addSubview:label];</span><br><span class="line">  </span><br><span class="line">  NSString *headStr = @&quot;Hi ALL,这是我的博客：&quot;;</span><br><span class="line">  NSString *linkStr = @&quot;lemon2well.top&quot;;</span><br><span class="line">  NSString *lastStr = @&quot;，欢迎来到我的博客，环欢迎评论留言一起交流。&quot;;</span><br><span class="line">  UIImage *image = [UIImage imageNamed:@&quot;trumpet&quot;];</span><br><span class="line">  </span><br><span class="line">  NSMutableAttributedString *attrText = [NSMutableAttributedString new];</span><br><span class="line">  </span><br><span class="line">  NSAttributedString *headAttr = [[NSAttributedString alloc] initWithString:headStr attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">  </span><br><span class="line">  NSAttributedString *lastAttr = [[NSAttributedString alloc] initWithString:lastStr attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">  </span><br><span class="line">  NSMutableAttributedString *linkAttr = [[NSMutableAttributedString alloc] initWithString:linkStr];</span><br><span class="line">  linkAttr.yy_font = [UIFont systemFontOfSize:20];</span><br><span class="line">  linkAttr.yy_underlineStyle = NSUnderlineStyleSingle;</span><br><span class="line">  [linkAttr yy_setTextHighlightRange:NSMakeRange(0, linkStr.length) color:[UIColor blueColor] backgroundColor:nil tapAction:^(UIView * _Nonnull containerView, NSAttributedString * _Nonnull text, NSRange range, CGRect rect) &#123;</span><br><span class="line">      NSLog(@&quot;link = %@&quot;,text);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  NSMutableAttributedString *imageAttr = [NSMutableAttributedString yy_attachmentStringWithContent:image contentMode:UIViewContentModeCenter attachmentSize:CGSizeMake(32, 32) alignToFont:[UIFont systemFontOfSize:20] alignment:YYTextVerticalAlignmentCenter];</span><br><span class="line">  </span><br><span class="line">  [attrText appendAttributedString:imageAttr];</span><br><span class="line">  [attrText appendAttributedString:headAttr];</span><br><span class="line">  [attrText appendAttributedString:linkAttr];</span><br><span class="line">  [attrText appendAttributedString:lastAttr];</span><br><span class="line"></span><br><span class="line">  label.attributedText = attrText;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>总的来说，以上说的四种都各有优劣，但是他们都用了NSAttributedString来实现富文本。</p><p>如果在项目中用到富文本的地方不多，出于APP体积考虑没必要引入一个第三方，  可以考虑使用第一和第二种方案，如果是图文环绕这种，可以使用UITextView+UIImageview的方案，如果是小的表情图文混排可以使用NSAttributedString+label即可。</p><p>如果在项目中多处用到富文本的展示和编辑，建议使用YYText，因为它对于开发者更加友好，并且也是基于CoreText来渲染，不过有一点就是目前YYText已经有一年没维护了，之前他生病了，现在正在家里修养，希望他快点好起来，祝好。</p><h2 id="突然有感"><a href="#突然有感" class="headerlink" title="突然有感"></a>突然有感</h2><p>本来这篇文章到这里就应该完了，不过刚刚去看了一下YYKit的作者的<a href="https://blog.ibireme.com/author/ibireme/" target="_blank" rel="noopener">博客</a>，突然有点伤感，没想到他生病这么严重，看他的文字感觉他是一个对待生活也很细腻的人，这也说得通为什么他可以用业余的时间写出了YYKIT这么强大的工具，因为他对待技术也是很细腻。</p><p>真的很佩服这样的人，你可以感受到他的真诚，我虽然没和他聊过天，没见过他真人，不过他一定会是一个让别人感受到交流沟通起来让你没有防御的一个人。现在这个社会因为各种各样变态的人以及事，总会让人无论何时何地总会身上架着一层防御装，更可怕的是还有那种表面善内里恶的人，多可怕，如果是危害别人的人我一点都不心疼。</p><p>最后希望大家一定要注意自己的身体，祝大家都好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图文混排有多种方式可以实现，下面我会用四种不同的方式来实现以下界面的效果，并且说明他们的优缺点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcd17v2u0.bkt.clouddn.com/screenshot.png&quot; alt=&quot;screenshot&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;NSAttributedString&quot;&gt;&lt;a href=&quot;#NSAttributedString&quot; class=&quot;headerlink&quot; title=&quot;NSAttributedString&quot;&gt;&lt;/a&gt;NSAttributedString&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;NSAttributedString提供了自由并且多样式的富文本设置，图文混排的实现是通过插入NSTestAttachment来实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>开发细节之 hash 与 isEqual 方法</title>
    <link href="http://lemon2well.top/2018/08/14/iOS%20%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%BB%86%E8%8A%82%E4%B9%8B-hash-%E4%B8%8E-isEqual-%E6%96%B9%E6%B3%95/"/>
    <id>http://lemon2well.top/2018/08/14/iOS 开发/开发细节之-hash-与-isEqual-方法/</id>
    <published>2018-08-14T03:11:53.000Z</published>
    <updated>2018-08-14T03:12:23.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="isEuqal-与-的区别"><a href="#isEuqal-与-的区别" class="headerlink" title="isEuqal 与 == 的区别"></a>isEuqal 与 == 的区别</h2><p>相信大家都知道在OC中有两种比较是否相等的方法，第一种是直接用<code>==</code>符号比较，第二种是使用isEqual来比较，它们的区别如下：</p><ol><li><code>==</code> 如果是用于基本数据类型的比较，那么直接比较数值，isEqual只能用于OC对象比较</li><li><code>==</code> 如果是用于OC对象比较，那么是判断他们是不是同一个对象，也就是指针所指向的地址是否一致。而isEqual则是比较两个对象是否相同。</li></ol><a id="more"></a><p>接下来用一个颜色的示例来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIColor *color1 = [UIColor colorWithRed:120/255.0 green:120/255.0 blue:120/255.0 alpha:1];</span><br><span class="line">UIColor *color2 = [UIColor colorWithRed:120/255.0 green:120/255.0 blue:120/255.0 alpha:1];</span><br><span class="line">NSLog(@&quot;color1.address = %p\ncolor2.address = %p&quot;,color1,color2);</span><br><span class="line">NSLog(@&quot;color1 == color2 ? %@ &quot;,color1 == color2 ? @&quot;是&quot; : @&quot;否&quot;);</span><br><span class="line">NSLog(@&quot;color1 isEqual color2 ? %@ &quot;,[color1 isEqual:color2] ? @&quot;是&quot; : @&quot;否&quot;);</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color1.address = 0x60400046af40</span><br><span class="line">color2.address = 0x60400046b280</span><br><span class="line">color1 == color2 ? 否</span><br><span class="line">color1 isEqual color2 ? 是</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以看出，color1和color2是两个不同的对象，所以使用<code>==</code>来比较的时候他们不相等。但是color1和color2颜色的值都是一样的，所以使用isEuqal来比较的时候他们是相等的。</p><h2 id="isEuqal-用于自定义对象的比较"><a href="#isEuqal-用于自定义对象的比较" class="headerlink" title="isEuqal 用于自定义对象的比较"></a>isEuqal 用于自定义对象的比较</h2><p>刚刚我们是使用系统的UIColor的对象来比较，如果是我们是自定义的对象，如果需要判断两个对象是否相等的时候，使用isEqual方法来比较是否还起作用呢？</p><p>看看以下代码，我们有一个<code>LMPerson</code>类，里面有两个属性，一个name，一个age，我们创建两个不同的对象，然后给他们赋予同样的name和age，看看使用isEuqal来比较是否相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LMPerson *person1 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line">  LMPerson *person2 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line">  NSLog(@&quot;person1.address = %p\nperson2.address = %p&quot;,person1,person2);</span><br><span class="line">  NSLog(@&quot;person1 == person2 ? %@ &quot;,person1==person2?@&quot;是&quot;:@&quot;否&quot;);</span><br><span class="line">  NSLog(@&quot;person1 isEqual person2 ? %@ &quot;,[person1 isEqual:person2]?@&quot;是&quot;:@&quot;否&quot;);</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.address = 0x60400022b500</span><br><span class="line">person2.address = 0x60400022b200</span><br><span class="line">person1 == person2 ? 否</span><br><span class="line">person1 isEqual person2 ? 否</span><br></pre></td></tr></table></figure><p>通过上面的结果可以看出，当isEqual是用于我们自定义对象的比较的时候，即使我们赋予两个对象属性相同的值，但是返回的却是NO。这是为什么呢？</p><p><strong>这是因为UIColor，NSArray,NSdictonary 系统已经帮我们实现了对应的isEqual或者isEqualTo的方法，所以我们如果要用于自定义对象比较，那么也需要实现对应的isEqual方法，接下来我们给LMPerson添加以下实现方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object&#123;</span><br><span class="line">    if (self == object) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (![object isKindOfClass:LMPerson.class]) &#123;</span><br><span class="line">        return  NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LMPerson *person2 = (LMPerson*)object;</span><br><span class="line">    BOOL isSameName = (!self.name &amp;&amp; !person2.name) || [self.name isEqualToString:person2.name];</span><br><span class="line">    BOOL isSameAge = self.age == person2.age ;</span><br><span class="line">    return isSameName &amp;&amp; isSameAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.address = 0x60000022bac0</span><br><span class="line">person2.address = 0x60000022c460</span><br><span class="line">person1 == person2 ? 否</span><br><span class="line">person1 isEqual person2 ? 是</span><br></pre></td></tr></table></figure><p><strong>综上，如果我们要比较两个自定义对象是否相等的时候我们需要重写isEqual方法，给该方法提供一个实现。</strong></p><h2 id="什么是hash方法"><a href="#什么是hash方法" class="headerlink" title="什么是hash方法"></a>什么是hash方法</h2><p>这个要从hashTable说起，因为hashTabe是无序的集合，并且查找的时间复杂度是O(1)，数组是O(array_lenth)，为什么hashTable可以做到O(1)呢，因为当一个元素加到hashTable里面的时候，会有一个默认的hash值，用于标记元素在table中的位置，后面如果需要查找该元素，通过hash值可以直接找到该元素。</p><p>那么问题来了，这个hash值是怎样得来的呢？</p><p>这个hash值其实就是通过<code>- (NSUInteger)hash</code>方法提供的，并且系统默认的实现就是返回该对象的地址。下面我们来验证这个说法：</p><p>我们增加以下方法，并且打印出hash的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//LMPerson.m</span><br><span class="line">- (NSUInteger)getSuperHash&#123;</span><br><span class="line">    NSUInteger superHash = [super hash];</span><br><span class="line">    return superHash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ViewController</span><br><span class="line">  LMPerson *person1 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line">    LMPerson *person2 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line">    NSLog(@&quot;person1.address = %ld\nperson2.address = %ld&quot;,(NSUInteger)person1,(NSUInteger)person2);</span><br><span class="line">    NSLog(@&quot;person1.hash = %ld\nperson2.hash = %ld&quot;,[person1 getSuperHash],[person2 getSuperHash]);</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.address = 105553118496736</span><br><span class="line">person2.address = 105553116524864</span><br><span class="line">person1.hash = 105553118496736</span><br><span class="line">person2.hash = 105553116524864</span><br></pre></td></tr></table></figure><p>通过结果我们可以知道，其实系统默认的hash方法就是返回对象地址的十进制。</p><h2 id="什么时候会调用hash-方法"><a href="#什么时候会调用hash-方法" class="headerlink" title="什么时候会调用hash 方法"></a>什么时候会调用hash 方法</h2><p>这里我们直接说结论，如果一个集合中不能出现重复的元素那么就会调用hash方法来判断两个元素是否相等。什么意思呢？</p><p>NSMutableArray和NSArray是允许添加重复元素的，所以将一个元素放到该容器中的时候是不会调用hash方法，像NSSet，NSMutableSet元素不能重复，在添加和删除的时候会调用hash方法。当一个元素作为NSDictonary的key的时候，因为key也不能重复，所以也会调用hash方法。大家可以通过将上述创建的两个person对象分别放到不同的集合中进行验证。</p><p>值得注意的是，就算hash方法相等也不能判断两个元素就一定是相等，还会调用isEqual来进行判断。也就是说，会优先判断hash是否相等，如果hash不相等那么这两个元素一定不相等，如果hash相等，那么就调用isEqual判断两个元素是否相等，如果返回NO，那么两个元素也不相等， 如果返回YES那么两个元素相等。</p><p>也就是说当我们把自定义对象加到NSSet中的或者作为NSDictonary的key的时候 会同时调用hash方法和isEqual方法来判断两个元素是否相等，因此我们需要重写isEqual方法和hash方法。</p><h2 id="hash-的正确使用姿势"><a href="#hash-的正确使用姿势" class="headerlink" title="hash 的正确使用姿势"></a>hash 的正确使用姿势</h2><p>我们在上面已经验证过如果我们使用系统默认的hash方法来比较两个自定义对象是否相等是不正确的了，那么正确的使用姿势是什么呢？</p><p>在<a href="https://nshipster.com/equality/" target="_blank" rel="noopener">Equality</a>这篇文章中，matt大神给了方法，也就是对属性的hash进行异或运算。在<code>LMPerson.m</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash&#123;</span><br><span class="line">    return ([self.name hash] ^ [[NSNumber numberWithInteger:self.age] hash]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们编写以下代码来测试一下相同的元素是否还能加到hashTable里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LMPerson *person1 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line"> LMPerson *person2 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line"> LMPerson *person3 = [LMPerson personWithName:@&quot;lemon&quot; age:19];</span><br><span class="line"> NSSet *set = [NSSet setWithObjects:person1,person2, person3,nil];</span><br><span class="line"> NSLog(@&quot;set.count = %ld&quot;,[set count]);</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-08-14 11:08:13.250550+0800 testImageSourceCode[47478:7219161] set.count = 2</span><br></pre></td></tr></table></figure><p>可以看到我们往hashTable里面添加了三个元素，但是第一和第二个元素是相同的，所以最后加到集合里面的只有两个元素，证明hash方法起作用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;isEuqal-与-的区别&quot;&gt;&lt;a href=&quot;#isEuqal-与-的区别&quot; class=&quot;headerlink&quot; title=&quot;isEuqal 与 == 的区别&quot;&gt;&lt;/a&gt;isEuqal 与 == 的区别&lt;/h2&gt;&lt;p&gt;相信大家都知道在OC中有两种比较是否相等的方法，第一种是直接用&lt;code&gt;==&lt;/code&gt;符号比较，第二种是使用isEqual来比较，它们的区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 如果是用于基本数据类型的比较，那么直接比较数值，isEqual只能用于OC对象比较&lt;/li&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 如果是用于OC对象比较，那么是判断他们是不是同一个对象，也就是指针所指向的地址是否一致。而isEqual则是比较两个对象是否相同。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="isEuqal" scheme="http://lemon2well.top/tags/isEuqal/"/>
    
      <category term="hash" scheme="http://lemon2well.top/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>细说HTTP与HTTPS</title>
    <link href="http://lemon2well.top/2018/08/10/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/%E7%BB%86%E8%AF%B4HTTP%E4%B8%8EHTTPS/"/>
    <id>http://lemon2well.top/2018/08/10/其他技术/细说HTTP与HTTPS/</id>
    <published>2018-08-10T09:57:36.000Z</published>
    <updated>2018-08-10T09:59:57.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网上已经有很多关于HTTP与HTTPS的文章，为什么我还要写这篇文章呢，源于昨天有个iOS开发同学昨天在群里面提了一个问题，如果一个人下载了一个APP，该APP与服务器是HTTPS连接，他不会信任任何来源于不明身份的证书，然后连上了我的WIFI，我有没有办法去破解里面的通信内容?</p><p>接下来我们就带着这个疑问去寻找答案，并且给出我的答案。</p><h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h2><blockquote><p>HTTP(HyperText Transfer Protocol)超文本传输协议，HTTP是七层网络模型中作用在应用层的协议。</p></blockquote><a id="more"></a><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><ol><li>窃听风险（eavesdropping）：第三方可以获知通信内容。</li><li>篡改风险（tampering）：第三方可以修改通信内容。</li><li>冒充风险（pretending）：第三方可以冒充他人身份参与通信。</li></ol><p>因为HTTP是明文传输内容的，所以只要攻击者通过劫持你的WIFI或者你连上了不安全的WIFI那么你所有的传输内容他都可以拿到，接下来就可以篡改里面的数据。基于以上的缺点就有了HTTPS，待会我们再来说这个事儿。</p><h3 id="HTTP的工作流程："><a href="#HTTP的工作流程：" class="headerlink" title="HTTP的工作流程："></a>HTTP的工作流程：</h3><p>相信大家都听说过TCP三次握手，HTTP就是通过TCP三次握手建立连接，值得一提的是HTTP/1.0版本是默认没有复用TCP连接的，每次发送数据都要建立一个连接(需要使用keep-alive来建立长连接)，这样导致了耗时以及占用资源非常严重，后来发布了HTTP/1.1，同一个TCP通道可以复用发送多个请求，但是在该通道里面所有的请求都是按照顺序来发送的发送的，容易导致阻塞。HTTP/2在1.1的基础上改进了，不止复用同一个TCP通道并且可以并发的处理多个请求。</p><p>TCP三次握手，依照惯例，先发一个图片，看图说话</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15338881870637.png" alt=""></p><p>下面来解释一下上面三次握手的作用：</p><p>第一次握手：客户端发送将SYN标志位设置为1，并且随机产生一个序列号值seq=J，发送给数据包给服务端后，自身状态变为SYN_SENT</p><p>第二次握手：服务端接收到数据包之后，将发送标志位SYN设置为1，ACK应答需要为J+1表，并且再发送一个随机序列号值seq=K然后发送到客户端</p><p>第三次握手：客户端检查ACK是否为J+1，如果是的话发送一个ACK包，ACK=k+!，服务端收到之后确定ack是否等于K+1，是的话连接建立</p><p>我们先来解释一下为什么需要三次握手：<br>第一次握手确认客户端是具有发送消息能力的，发送消息之后客户端出于SYN_SENT状态，第二次握手服务器确定了自己有接收消息的能力，但是还不知道有没有发送消息的能力，此时服务器出于SYN_RECV的状态，也就是半连接的状态，第三次握手确定了服务器有发送消息的能力，因为客户端收到了他的消息并且回应了。此时客户端和服务端都处于establish状态，连接已经建立，可以开始收发消息。</p><p>基于HTTP的确定，后面衍生出来了HTTPS，那接下来我们来讲讲HTTPS以及他们的区别</p><h2 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h2><blockquote><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）顾名思义就是在HTTP的基础上加了SSL/TLS，以此来保证数据传输的安全性。</p></blockquote><h3 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h3><p>HTTPS 协议旨在解决以上三个风险，因此它可以：</p><ol><li>保证所有信息加密传输，无法被第三方窃取。</li><li>为信息添加校验机制，如果被第三方恶意破坏，可以检测出来。</li><li>配备身份证书，防止第三方伪装参与通信。</li></ol><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><blockquote><p>SSL(Secure Sockets Layer)/TLS(transport Layer Security)安全套接层是保证HTTPS安全的协议，这个协议主要的思想是通过公钥加解密来实现数据传输安全。</p></blockquote><p>那么我们就面临着两个问题.<br>1.如何保证公钥不被篡改 </p><blockquote><p>我们通过权威机构申请证书，将自己的公钥包装到证书里面，只要证书是可信的，那么公钥就是可信的。</p></blockquote><p>2.每次都生成公钥，消耗的时间太长，如何减少消耗。</p><blockquote><p>使用对称加密来替换非对称加密，每一次对话，客户端和和服务端都生成一个对话秘钥，而这个对称秘钥使用服务端的公私钥来进行加解密，这样就减少了加密运算的消耗时间。</p></blockquote><p>SSL/TLS 握手的流程：</p><ol><li><p>首先客户端发起请求，这个时候客户端会向服务端提供一些信息，包括支持的加密的算法，支持协议的版本TLS,一个随机数（用于待会生成对称秘钥），支持的压缩算法</p></li><li><p>服务端收到请求之后，向客户端发出相应，该响应也包括一些信息，确认使用的加密算法，一个服务端生成的随机数（用于待会生成秘钥）,支持的协议的版本TLS，还有一个最重要的数字证书，该数字证书包含了服务器的域名，还有服务端的公钥，以及经过加密后的摘要，该摘要是通过一定的算法对域名以及公钥进行计算得来。然后使用CA的私钥对摘要进行加密，</p></li><li><p>客户端收到数据之后首先会验证该数字证书是不是权威机构申请的证书，或者证书中的域名与实际域名是否一致，证书是否已经过期，如果都不符合的话那么就会提示是否信任该未知来源证书警告。<br>这里会验证证书是否被篡改，因为本地系统会内置权威机构的公钥，所以可以使  用公钥对解密出证书里面的摘要，然后通过特定的算法对域名以及公钥进行计算得到一个本地摘要，再和服务端传过来的摘要进行对比是否一致，以此来判断证书是否被篡改。<br>如果校验了证书是没有问题，客户端会生成一个随机数，并且使用服务器的公钥进行加密，并且发送编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p></li><li><p>服务端获取客户端的数据，然后使用自己的私钥机密客户端发过来的随机数。至此，一共有三个随机数。</p></li><li><p>客户端和服务端通过之前协议好的加密算法，使用前面生成的三个随机数生成一个真正的对称秘钥，该对称秘钥用于加密传输数据。</p></li></ol><p>简单点来说以上步骤就是：</p><ol><li>客户端发送请求</li><li>服务端返回证书，该证书包含服务端的公钥</li><li>客户端验证证书，并且生成对称秘钥，并且使用服务端的公钥加密该对称秘钥</li><li>服务端用私钥解密客户端的对称秘钥</li><li>发送内容通过对称秘钥来加密</li></ol><p>总结一下 HTTPS 协议是如何避免前文所说的三大风险的：<br>先用非对称加密传输密码，然后用这个密码对称加密数据，使得第三方无法获得通信内容<br>发送方将数据的哈希结果写到数据中，接收方解密后对比数据的哈希结果，如果不一致则说明被修改。由于传输数据加密，第三方无法修改哈希结果。<br>由权威机构颁发证书，再加上证书校验机制，避免第三方伪装参与通信。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>在我们抛砖引玉说了这么多HTTP与HTTPS的区别之后，我们得到了答案。</p><blockquote><p>如果一个人下载了一个APP，该APP与服务器是HTTPS连接，他不会信任任何来源于不明身份的证书，然后连上了我的WIFI，我有没有办法去破解里面的通信内容</p></blockquote><p><strong>答案就是不行</strong></p><p>我们想到的可以破解里面的通信内容也许就是希望能做一个中间人拦截，在服务端向客户端发送证书的时候拦截该证书，并且伪造一个和服务端域名相同并且替换将里面的公钥替换成自己的公钥，并且用自己的私钥进行签名。客户端收到伪造的证书之后，如果客户端的系统中有我们的公钥，那么就可以验证通过该中间人的证书，然后获取得到公钥，然后用该公钥对对称秘钥加密发送给服务端，此时中间件又可以拦截，并且使用自己的私钥解密出对称秘钥，然后中间人通过服务端的公钥对该秘钥进行加密，然后发送给服务端，这样中间人就拿到了对称秘钥信息，所以也可以窃取到里面的通信内容。</p><p>但是……….</p><p>前面的题目说了一个前提，不会信任任何来源于不明身份的证书，也就是说在中间人拦截了服务端的证书并且将伪造的证书发送给客户端之后，客户端并不会通过验证该证书，然后连接就到此中断了。。。。</p><h2 id="附加：HTTPS与HTTPS的区别"><a href="#附加：HTTPS与HTTPS的区别" class="headerlink" title="附加：HTTPS与HTTPS的区别"></a>附加：HTTPS与HTTPS的区别</h2><ol><li>HTTP是明文传输，HTTPS是加密传输</li><li>HTTP只有TCP三次握手，HTTPS是TCP三次握手+SSL/TLS</li><li>HTTP是使用80端口，HTTPS是使用443端口</li><li>HTTPS比HTTPS更加耗时</li><li>HTTPS需要到CA购买证书，需要一定的费用</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1  <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></p><ol start="2"><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></li><li><a href="http://skx926.com/2017/12/05/https/" target="_blank" rel="noopener">深入理解HTTPS</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;网上已经有很多关于HTTP与HTTPS的文章，为什么我还要写这篇文章呢，源于昨天有个iOS开发同学昨天在群里面提了一个问题，如果一个人下载了一个APP，该APP与服务器是HTTPS连接，他不会信任任何来源于不明身份的证书，然后连上了我的WIFI，我有没有办法去破解里面的通信内容?&lt;/p&gt;
&lt;p&gt;接下来我们就带着这个疑问去寻找答案，并且给出我的答案。&lt;/p&gt;
&lt;h2 id=&quot;什么是HTTP&quot;&gt;&lt;a href=&quot;#什么是HTTP&quot; class=&quot;headerlink&quot; title=&quot;什么是HTTP&quot;&gt;&lt;/a&gt;什么是HTTP&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;HTTP(HyperText Transfer Protocol)超文本传输协议，HTTP是七层网络模型中作用在应用层的协议。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其他技术" scheme="http://lemon2well.top/categories/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="http" scheme="http://lemon2well.top/tags/http/"/>
    
      <category term="https" scheme="http://lemon2well.top/tags/https/"/>
    
      <category term="SSL/TLS" scheme="http://lemon2well.top/tags/SSL-TLS/"/>
    
  </entry>
  
  <entry>
    <title>回文数</title>
    <link href="http://lemon2well.top/2018/08/10/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://lemon2well.top/2018/08/10/常见算法/回文数/</id>
    <published>2018-08-10T02:34:40.000Z</published>
    <updated>2018-08-10T02:35:39.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。"><a href="#判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。" class="headerlink" title="判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。"></a>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</h1><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><a id="more"></a><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><blockquote><p>思路：<br>根据定义如果我们要找出一个数是否是回文数我们其实只需要将这个数分成平均分成两个部分，然后将后半部分翻转，只要翻转后的后半部分等于前半部分，就代表这个数是回文数。<br>我们拿1221来举例，假设我们拿到后半段是21然后将21翻转就是12了，和前半段比较相等就代表是回文数。<br>那么我们第一个问题，如何将21翻转，首先我们将1221%10 得到的就是第一个数1，然后用这第一个数 1<em> 10 得到翻转后的正确位置。第二个数我们依然是122%10，然后得到第二个数，用第一个数加上第二个数就得到了12.<br>第二个问题就是我们如何将这个数分成两部分。当原始数/10小于翻转数</em>10的时候就代表已经完成了一半的翻转。</p></blockquote><p><strong>不过依然有两点需要注意，第一点是如果这个原始的数是负数的话我们需要返回，如果这个数是以0结尾的数，那么只有0才满足回文数，其他数都不满足回文数，我们直接返回false。</strong><br><strong>第二点是如果这个数的位数是基数，例如12321，那么循环完成之后原始数编程12，翻转数是123，这个时候我们用123/10得到12再和原始数12比较，忽略中间那一位数</strong></p><p>以下是代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func solution(_ num:Int)-&gt;Bool&#123;</span><br><span class="line">      if num&lt;0 || (num % 10 == 0 &amp;&amp; num != 0)&#123;</span><br><span class="line">          return false</span><br><span class="line">      &#125;</span><br><span class="line">      var originNum = num</span><br><span class="line">      var reverserNum = 0</span><br><span class="line">      while originNum &gt; reverserNum &#123;</span><br><span class="line">          reverserNum = reverserNum * 10 + originNum % 10</span><br><span class="line">          originNum = originNum / 10</span><br><span class="line">      &#125;</span><br><span class="line">      return originNum == reverserNum || originNum == reverserNum / 10</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&quot;&gt;&lt;a href=&quot;#判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&quot; class=&quot;headerlink&quot; title=&quot;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&quot;&gt;&lt;/a&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/h1&gt;&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: -121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://lemon2well.top/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>持续集成之Jenkins构建项目并上传到蒲公英</title>
    <link href="http://lemon2well.top/2018/08/08/iOS%20%E5%BC%80%E5%8F%91/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
    <id>http://lemon2well.top/2018/08/08/iOS 开发/持续集成之Jenkins构建项目并上传到蒲公英/</id>
    <published>2018-08-08T15:18:25.000Z</published>
    <updated>2018-08-09T03:18:43.898Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在第一篇<a href="http://lemon2well.top/2018/08/07/iOS%20开发/持续集成之Jenkins搭建/">Jenkins的搭建</a>中我们已经把本地jenkins环境都搭建好了，接下来我们通过jenkins构建一个ipa并且上传到蒲公英。</p></blockquote><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p>1.首先选择左侧的新建任务，然后下面是构建该工程的基本信息</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336240434000.jpg" alt=""></p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336241947095.jpg" alt=""></p><a id="more"></a><h2 id="填写源码地址"><a href="#填写源码地址" class="headerlink" title="填写源码地址"></a>填写源码地址</h2><ol start="2"><li>下面填写github或者gitLab的源码的地址，并且需要配置对应的Credentials，这里相当是授权。等到构建的时候jenkins会从对应的git上面拉去代码开始构建。</li></ol><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336242653880.jpg" alt=""></p><p>填完源码的网址之后需要填写git的账号密码或者输入对应的私钥。点击Add然后会出现下面的界面</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336242294039.jpg" alt=""></p><blockquote><p>如果你的git已经配置了ssh那么可以选择SSH username and private key， 然后到你的/Users/用户名/.ssh/id_rsa 将这个私钥文件里面的所有内容复制到privatekey (enter directly)上面去。<br>否则可以按照上图那样，选择username with password，然后输入用户名和密码</p></blockquote><h2 id="设置触发器（非必要）"><a href="#设置触发器（非必要）" class="headerlink" title="设置触发器（非必要）"></a>设置触发器（非必要）</h2><ol start="3"><li>构建触发器是与测试相关的操作，这里可以根据需求选择构建的触发时刻，例如选择第二个就是当代码仓库有push事件的时候，就会触发构建操作，然后构建一个版本并且通知测试去操作。因为我们是手动构建，所以这里先不管这个。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336265635081.jpg" alt=""></li></ol><h2 id="设置签名和证书"><a href="#设置签名和证书" class="headerlink" title="设置签名和证书"></a>设置签名和证书</h2><ol start="4"><li>接下我们需要设置签名文件和证书。<br>首先保存我们原先的设置，然后回到首页，选择系统管理-&gt;Keychains and Provisioning Profiles Management 点击选取文件，然后选择login.keychain文件和 provisioning file 上传。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336269763882.jpg" alt=""></li></ol><p>填写本机密码，输入描述，然后选择Add Code Signing Identity 输入签名文件的名称，这里的名称可以到钥匙串找到对应的证书然后选择显示简介然后复制头部的文字。</p><blockquote><p>这个Keychain在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下</p></blockquote><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336275407363.jpg" alt=""></p><p>上面的配置完成之后，回到任务的配置里面，选择对应的keyChain和provisioning file</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336251729871.jpg" alt=""></p><h2 id="构建命令"><a href="#构建命令" class="headerlink" title="构建命令"></a>构建命令</h2><ol start="5"><li>上面已经将所有的设置都配置好了，接下来需要选择构建的方式，你可以选择通过xcode来构建，但是这里我们选择shell 并且也推荐通过shell来构建。选择执行shell，然后输入下面的代码，里面有些地方需要改成你自己的，根据实际情况改就可以了，不过一定要注意一点，jenkins那个编辑框极其不好用，我因为不小心输入了一个空格字符然后一直报 command not found ，搞到我一直以为是jenkins配置环境的问题。如果中间有构建错误，点击构建那个红点然后可以查看具体的控制台信息，根据错误提示来修改就好了</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 工程名，记得改成你自己</span><br><span class="line">APP_NAME=&quot;TestUMCOpen&quot;</span><br><span class="line"># 证书</span><br><span class="line">CODE_SIGN_DISTRIBUTION=&quot;iPhone Distribution: XXXXXXXXXX&quot;</span><br><span class="line"># info.plist路径</span><br><span class="line">project_infoplist_path=&quot;./$&#123;APP_NAME&#125;/Info.plist&quot;</span><br><span class="line"></span><br><span class="line">#取版本号</span><br><span class="line">bundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line"></span><br><span class="line">#取build值</span><br><span class="line">bundleVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line">DATE=&quot;$(date +%Y%m%d)&quot;</span><br><span class="line">IPAFOLDER=&quot;$&#123;APP_NAME&#125;_V$&#123;bundleShortVersion&#125;_$&#123;DATE&#125;&quot;</span><br><span class="line"></span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">ARCHIVE_PATH=&quot;$&#123;HOME&#125;/Desktop/archive&quot;</span><br><span class="line">IPA_PATH=&quot;$ARCHIVE_PATH/$&#123;IPAFOLDER&#125;/$&#123;APP_NAME&#125;.ipa&quot;</span><br><span class="line">PLIST_PATH=&quot;$ARCHIVE_PATH/ADHocExportOptions.plist&quot;</span><br><span class="line">echo $&#123;IPA_PATH&#125;</span><br><span class="line">echo $&#123;PLIST_PATH&#125;</span><br><span class="line"></span><br><span class="line">#下面两行是没有Cocopods的用法</span><br><span class="line"># 清除上次构建</span><br><span class="line">xcodebuild clean -project &quot;$&#123;APP_NAME&#125;.xcodeproj&quot; -scheme $&#123;APP_NAME&#125;   -configuration &apos;Release&apos;</span><br><span class="line"># 构建xcarchive文件</span><br><span class="line">xcodebuild archive -project &quot;$&#123;APP_NAME&#125;.xcodeproj&quot; -scheme $&#123;APP_NAME&#125; -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot;</span><br><span class="line"></span><br><span class="line">#下面两行是有cocopods的用法</span><br><span class="line"># xcodebuild clean -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme $&#123;APP_NAME&#125;   -configuration &apos;Release&apos;</span><br><span class="line"></span><br><span class="line"># xcodebuild archive -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme $&#123;APP_NAME&#125; -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot;</span><br><span class="line"></span><br><span class="line"># 导出ipa</span><br><span class="line">xcodebuild -exportArchive -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot; -exportPath &quot;$ARCHIVE_PATH/$IPAFOLDER&quot; -exportOptionsPlist &quot;$PLIST_PATH&quot;</span><br><span class="line"></span><br><span class="line">#打开文件夹</span><br><span class="line">open $&#123;ARCHIVE_PATH&#125;</span><br></pre></td></tr></table></figure><p><strong>这里有个地方需要注意一下，在xcode9之后，需要提供一个信息才能打包，我们可以通过xcode打包出来ipa文件然后复制那个ExportOption.plist文件就好了以下是我的文件的内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;compileBitcode&lt;/key&gt;</span><br><span class="line">&lt;false/&gt;</span><br><span class="line">&lt;key&gt;method&lt;/key&gt;</span><br><span class="line">&lt;string&gt;enterprise&lt;/string&gt;</span><br><span class="line">&lt;key&gt;provisioningProfiles&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;your Bundle id&lt;/key&gt;</span><br><span class="line">&lt;string&gt;证书的名字&lt;/string&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;key&gt;signingCertificate&lt;/key&gt;</span><br><span class="line">&lt;string&gt;iPhone Distribution&lt;/string&gt;</span><br><span class="line">&lt;key&gt;signingStyle&lt;/key&gt;</span><br><span class="line">&lt;string&gt;manual&lt;/string&gt;</span><br><span class="line">&lt;key&gt;stripSwiftSymbols&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;teamID&lt;/key&gt;</span><br><span class="line">&lt;string&gt;7LD5QKB26C&lt;/string&gt;</span><br><span class="line">&lt;key&gt;thinning&lt;/key&gt;</span><br><span class="line">&lt;string&gt;none&lt;/string&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>如果成功之后会在我们指定的文件里面生成下面的文件，除了那个ADHocExportOption.plist是我创建的，前天的文件都是jenkins构建的。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336256611678.jpg" alt=""></p></li><li><p>上传ipa到蒲公英</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#上传到蒲公英</span><br><span class="line">uKey=&quot;aec42b3cc32*******837cc7084a819c&quot;</span><br><span class="line">#蒲公英上的API Key</span><br><span class="line">apiKey=&quot;ba4e62***************8067a87315&quot;</span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">echo $IPA_PATH</span><br><span class="line"> </span><br><span class="line">#执行上传至蒲公英的命令</span><br><span class="line">echo &quot;++++++++++++++upload+++++++++++++&quot;</span><br><span class="line">curl -F &quot;file=@$&#123;IPA_PATH&#125;&quot; -F &quot;uKey=$&#123;uKey&#125;&quot; -F &quot;_api_key=$&#123;apiKey&#125;&quot; http://www.pgyer.com/apiv1/app/upload</span><br></pre></td></tr></table></figure><h2 id="命令行构建"><a href="#命令行构建" class="headerlink" title="命令行构建"></a>命令行构建</h2><ol start="7"><li>至此我们已经完成手动构建项目了，接下来我们利用Jenkins命令行来完成一行命令构建版本<br>进入系统管理然后选择Jenkins命令行，下载最新的jenkins-cli.jar<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336535463602.jpg" alt=""></li></ol><p>下载完成之后，如果直接运行上述命令行会提示没有权限，这个时候我们需要配置一下SSH。点击右上角的用户名，然后点击设置，找到SSH，然后将本地的公钥复制粘贴到上面，保存。</p><p>下面是完整的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">add-job-to-view</span><br><span class="line">    Adds jobs to view.</span><br><span class="line">  build</span><br><span class="line">    Builds a job, and optionally waits until its completion.</span><br><span class="line">  cancel-quiet-down</span><br><span class="line">    Cancel the effect of the &quot;quiet-down&quot; command.</span><br><span class="line">  clear-queue</span><br><span class="line">    Clears the build queue.</span><br><span class="line">  connect-node</span><br><span class="line">    Reconnect to a node(s)</span><br><span class="line">  console</span><br><span class="line">    Retrieves console output of a build.</span><br><span class="line">  copy-job</span><br><span class="line">    Copies a job.</span><br><span class="line">  create-credentials-by-xml</span><br><span class="line">    Create Credential by XML</span><br><span class="line">  create-credentials-domain-by-xml</span><br><span class="line">    Create Credentials Domain by XML</span><br><span class="line">  create-job</span><br><span class="line">    Creates a new job by reading stdin as a configuration XML file.</span><br><span class="line">  create-node</span><br><span class="line">    Creates a new node by reading stdin as a XML configuration.</span><br><span class="line">  create-view</span><br><span class="line">    Creates a new view by reading stdin as a XML configuration.</span><br><span class="line">  delete-builds</span><br><span class="line">    Deletes build record(s).</span><br><span class="line">  delete-credentials</span><br><span class="line">    Delete a Credential</span><br><span class="line">  delete-credentials-domain</span><br><span class="line">    Delete a Credentials Domain</span><br><span class="line">  delete-job</span><br><span class="line">    Deletes job(s).</span><br><span class="line">  delete-node</span><br><span class="line">    Deletes node(s)</span><br><span class="line">  delete-view</span><br><span class="line">    Deletes view(s).</span><br><span class="line">  disable-job</span><br><span class="line">    禁用任务</span><br><span class="line">  disconnect-node</span><br><span class="line">    Disconnects from a node.</span><br><span class="line">  enable-job</span><br><span class="line">    启用任务</span><br><span class="line">  get-credentials-as-xml</span><br><span class="line">    Get a Credentials as XML (secrets redacted)</span><br><span class="line">  get-credentials-domain-as-xml</span><br><span class="line">    Get a Credentials Domain as XML</span><br><span class="line">  get-job</span><br><span class="line">    Dumps the job definition XML to stdout.</span><br><span class="line">  get-node</span><br><span class="line">    Dumps the node definition XML to stdout.</span><br><span class="line">  get-view</span><br><span class="line">    Dumps the view definition XML to stdout.</span><br><span class="line">  groovy</span><br><span class="line">    Executes the specified Groovy script.</span><br><span class="line">  groovysh</span><br><span class="line">    Runs an interactive groovy shell.</span><br><span class="line">  help</span><br><span class="line">    Lists all the available commands or a detailed description of single command.</span><br><span class="line">  import-credentials-as-xml</span><br><span class="line">    Import credentials as XML. The output of &quot;list-credentials-as-xml&quot; can be used as input here as is, the only needed change is to set the actual Secrets which are redacted in the output.</span><br><span class="line">  install-plugin</span><br><span class="line">    Installs a plugin either from a file, an URL, or from update center.</span><br><span class="line">  install-tool</span><br><span class="line">    Performs automatic tool installation, and print its location to stdout. Can be only called from inside a build. [deprecated]</span><br><span class="line">  keep-build</span><br><span class="line">    永久保留这次构建。</span><br><span class="line">  list-changes</span><br><span class="line">    Dumps the changelog for the specified build(s).</span><br><span class="line">  list-credentials</span><br><span class="line">    Lists the Credentials in a specific Store</span><br><span class="line">  list-credentials-as-xml</span><br><span class="line">    Export credentials as XML. The output of this command can be used as input for &quot;import-credentials-as-xml&quot; as is, the only needed change is to set the actual Secrets which are redacted in the output.</span><br><span class="line">  list-credentials-context-resolvers</span><br><span class="line">    List Credentials Context Resolvers</span><br><span class="line">  list-credentials-providers</span><br><span class="line">    List Credentials Providers</span><br><span class="line">  list-jobs</span><br><span class="line">    Lists all jobs in a specific view or item group.</span><br><span class="line">  list-plugins</span><br><span class="line">    Outputs a list of installed plugins.</span><br><span class="line">  login</span><br><span class="line">    Saves the current credentials to allow future commands to run without explicit credential information. [deprecated]</span><br><span class="line">  logout</span><br><span class="line">    Deletes the credentials stored with the login command. [deprecated]</span><br><span class="line">  mail</span><br><span class="line">    Reads stdin and sends that out as an e-mail.</span><br><span class="line">  offline-node</span><br><span class="line">    Stop using a node for performing builds temporarily, until the next &quot;online-node&quot; command.</span><br><span class="line">  online-node</span><br><span class="line">    Resume using a node for performing builds, to cancel out the earlier &quot;offline-node&quot; command.</span><br><span class="line">  quiet-down</span><br><span class="line">    Quiet down Jenkins, in preparation for a restart. Don’t start any builds.</span><br><span class="line">  reload-configuration</span><br><span class="line">    Discard all the loaded data in memory and reload everything from file system. Useful when you modified config files directly on disk.</span><br><span class="line">  reload-job</span><br><span class="line">    Reload job(s)</span><br><span class="line">  remove-job-from-view</span><br><span class="line">    Removes jobs from view.</span><br><span class="line">  restart</span><br><span class="line">    重新启动Jenkins</span><br><span class="line">  safe-restart</span><br><span class="line">    安全地重新启动Jenkins</span><br><span class="line">  safe-shutdown</span><br><span class="line">    Puts Jenkins into the quiet mode, wait for existing builds to be completed, and then shut down Jenkins.</span><br><span class="line">  session-id</span><br><span class="line">    Outputs the session ID, which changes every time Jenkins restarts.</span><br><span class="line">  set-build-description</span><br><span class="line">    Sets the description of a build.</span><br><span class="line">  set-build-display-name</span><br><span class="line">    Sets the displayName of a build.</span><br><span class="line">  set-build-parameter</span><br><span class="line">    Update/set the build parameter of the current build in progress. [deprecated]</span><br><span class="line">  set-build-result</span><br><span class="line">    Sets the result of the current build. Works only if invoked from within a build. [deprecated]</span><br><span class="line">  set-external-build-result</span><br><span class="line">    Set external monitor job result.</span><br><span class="line">  shutdown</span><br><span class="line">    立刻关闭Jenkins</span><br><span class="line">  update-credentials-by-xml</span><br><span class="line">    Update Credentials by XML</span><br><span class="line">  update-credentials-domain-by-xml</span><br><span class="line">    Update Credentials Domain by XML</span><br><span class="line">  update-job</span><br><span class="line">    Updates the job definition XML from stdin. The opposite of the get-job command.</span><br><span class="line">  update-node</span><br><span class="line">    Updates the node definition XML from stdin. The opposite of the get-node command.</span><br><span class="line">  update-view</span><br><span class="line">    Updates the view definition XML from stdin. The opposite of the get-view command.</span><br><span class="line">  version</span><br><span class="line">    Outputs the current version.</span><br><span class="line">  wait-node-offline</span><br><span class="line">    Wait for a node to become offline.</span><br><span class="line">  wait-node-online</span><br><span class="line">    Wait for a node to become online.</span><br><span class="line">  who-am-i</span><br><span class="line">    Reports your credential and permissions.</span><br></pre></td></tr></table></figure><p>我们执行命令的格式是<br><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -ssh -user username command</code><br>command 就是我们需要执行的命令，build是构建命令，下面的事情就很简单了。</p><p><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -ssh -user username build UMC10.1.0Demo</code><br><strong>UMC10.1.0Demo是我们一开始创建任务的时候的名字，这个时候就会自动构建版本并且上传蒲公英</strong><br>可以将上述命令放到.command文件里面，并且增加可执行权限，这样双击这个文件的时候就会触发构建。注意里面cli.jar的路径。</p><p>上述命令指示构建一个指定版本的脚本，下面我们可以通过列举出所有的任务，然后选择其中一个任务来开始构建版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">ps -fe|grep &quot;jenkins&quot; |grep -v grep</span><br><span class="line">if [ $? -ne 0 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;******请先使用Jenkins -h来启动jenkins**********&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;********检测到Jenkins已经启动**********&quot;</span><br><span class="line">fi</span><br><span class="line">LOCALHOST=&quot;http://localhost:8080/&quot;</span><br><span class="line">CLIJAR=&quot;/Users/lemon/jenkins-cli.jar&quot;</span><br><span class="line"></span><br><span class="line">java -jar $&#123;CLIJAR&#125; -s $&#123;LOCALHOST&#125; -ssh -user admin list-jobs</span><br><span class="line"></span><br><span class="line">echo &quot;*******请输入你要构建的任务*******&quot;</span><br><span class="line">read BuildName</span><br><span class="line"></span><br><span class="line">java -jar $&#123;CLIJAR&#125; -s $&#123;LOCALHOST&#125; -ssh -user admin build $&#123;BuildName&#125;</span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">echo &quot;*******正在构建$&#123;BuildName&#125;，构建完成后会自动打开本地文件夹*******&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;*******构建$&#123;BuildName&#125;失败，请检查是否有对应的任务*******&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述：总的来说在我们jenkins已经安装好的情况下，我们需要做的就是构建任务，然后填写源码地址，设置构建策略，设置签名和证书，编写构建代码（包括上传蒲公英），编写shell。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在第一篇&lt;a href=&quot;http://lemon2well.top/2018/08/07/iOS%20开发/持续集成之Jenkins搭建/&quot;&gt;Jenkins的搭建&lt;/a&gt;中我们已经把本地jenkins环境都搭建好了，接下来我们通过jenkins构建一个ipa并且上传到蒲公英。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;创建任务&quot;&gt;&lt;a href=&quot;#创建任务&quot; class=&quot;headerlink&quot; title=&quot;创建任务&quot;&gt;&lt;/a&gt;创建任务&lt;/h2&gt;&lt;p&gt;1.首先选择左侧的新建任务，然后下面是构建该工程的基本信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcd17v2u0.bkt.clouddn.com/15336240434000.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcd17v2u0.bkt.clouddn.com/15336241947095.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="jenkins" scheme="http://lemon2well.top/tags/jenkins/"/>
    
      <category term="蒲公英" scheme="http://lemon2well.top/tags/%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
    
  </entry>
  
  <entry>
    <title>持续集成之Jenkins搭建</title>
    <link href="http://lemon2well.top/2018/08/07/iOS%20%E5%BC%80%E5%8F%91/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%90%AD%E5%BB%BA/"/>
    <id>http://lemon2well.top/2018/08/07/iOS 开发/持续集成之Jenkins搭建/</id>
    <published>2018-08-07T08:26:29.000Z</published>
    <updated>2018-08-08T08:27:10.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于一个APP来说，我相信我们开发最担心的就是出bug，只要是线上APP出bug，心里就慌得很，这是一件很严重的事情，还有可能让用户一气之下把你的APP删掉，从此再也不会出现在他的手机里面。</p><p>但是如果我们严格把控APP的质量，我们做到每天都构建一个版本并且测试，我们将这个APP上传到一个特定的测试系统，当有代码更新的时候或者每天设置一个时间去不断的跑测试，这样我们在开发阶段就发现很多问题。</p><blockquote><p>上面我们说的就是CI(Continuous Integration)持续集成+TDD(Test Driven Development)测试驱动开发。</p></blockquote><a id="more"></a><h2 id="持续集成带来的好处"><a href="#持续集成带来的好处" class="headerlink" title="持续集成带来的好处"></a>持续集成带来的好处</h2><p>持续集成带来的好处是显而易见的</p><ol><li><p>减少风险。通过每天构建版本，在开发阶段就可以发现项目的缺陷，排除一些因为项目设置的低级错误而导致的bug，用同样的脚本和过程构建和测试软件，排除因代码外的其他因素。</p></li><li><p>减少重复的过程，提高效率。当项目变大之后，频繁的打包会很影响开发的效率，但是有了持续集成我们不用关心打包的过程，将重复的build,archive,code sign交给提供构建服务的机器去做，将时间放在更有意义的事情上面。</p></li><li><p>随时可部署。持续集成有一个好处就是我们每天都会做构建版本，可以交付部署上线，当我们无休止的讨论需求软件质量或者开发进度的时候，对于客户来说，不如一个可安装的软件包来得实际</p></li></ol><h3 id="持续集成之Jenkins"><a href="#持续集成之Jenkins" class="headerlink" title="持续集成之Jenkins"></a>持续集成之Jenkins</h3><p>CI包括三个基本的元素，第一个是可自动构建版本的服务，第二个是代码仓库，第三个是搭建了服务的机器。</p><blockquote><p>可自动构建版本的服务目前有Jenkins和fastlane。<br>代码仓库也就是我们平时使用的github,gitlab等等<br>在iOS中机器必须是搭建OSX系统的机器，因为构建需要用到xcodeBuild命令，该命令由xcode提供，而xcode只能安装在OSX系统下面。</p></blockquote><p>下面我们要说的就是可自动构建版本的服务，<a href="https://jenkins.io" target="_blank" rel="noopener">Jenkins</a>。</p><p>Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性，构建完成之后通过脚本直接上传到分发平台或者测试平台。</p><h2 id="Jenkins搭建"><a href="#Jenkins搭建" class="headerlink" title="Jenkins搭建"></a>Jenkins搭建</h2><p>jenkins有两种安装方式</p><p>一种是通过在<a href="https://jenkins.io/download" target="_blank" rel="noopener">官网</a>下载pkg安装包的方式安装，图形化的安装界面直接跟着提示安装就好了。</p><p>第二种是通过homebrew安装，不过在安装之前我们需要检测本地环境是否已经安装了java，可以使用<code>java -version</code>来查看当前的java版本，如果没有安装的java的话可以在<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">这里</a>安装java。<br>还要检测是否已经安装了homebrew,查看本机homebrew版本’brew -v’。</p><p>如果java和homebrew都已经安装好，就可以开始安装jenkins了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure><p>当出现Jenkins is fully up and running之后，表明jenkins已经安装好了，如果没有自动打开<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> ，可以到网页上面自行打开该外地址。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337123514685.png" alt=""></p><p>上面给了一个地址，提示你去那里找到初始化的密码。打开/User/Shared/Jenkins/Home/secrets/initialAdminPassword复制出密码。</p><p>接下来会提示你安装一些插件，安装默认的插件即可，不过就算这里安装失败了也没关系，后面进到主界面还可以继续安装。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337131168237.png" alt=""></p><p>安装完插件之后会提示你创建一个jenkins用户。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15337133154570.jpg" alt=""></p><p>输入这些信息之后点击save And Finish安装的过程就算完成了。接下来可以进入到jenkins主界面了。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337135245241.jpg" alt=""><br>我们主要关注一下面板左侧的选项，点击“系统管理”，然后找到“管理插件”<br>在“可选插件”中选中“GitLab Plugin”和“Gitlab Hook Plugin”这两项，然后安装。<br>安装Xcode插件<br>同安装GitLab插件的步骤一样，我们依次选择系统管理-&gt;管理插件，在“可选插件”中选中“Xcode integration”安装，安装完这个插件我们还需要安装一个“Keychains and Provisioning Profiles Management”插件。这个插件用于我们设置签名和证书。</p><p>安装“Keychains and Provisioning Profiles Management”之后，我们去到系统管理-&gt;Keychains and Provisioning Profiles Management设置签名和证书。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337147054369.jpg" alt=""></p><p>这里需要选择 login.keychain ，在 /Users/用户名/Library/keychains/login.keychain 目录里。如果不能通过选择的话，可以把login.keychain拷贝到桌面，然后在选择上传。<br>Code Signing Identity，可以添加多项。进入钥匙串，选择开发者证书或发布证书，拷贝完全，粘贴至Jenkins的Code Signing Identity项。</p><p>当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下</p><p>到这里Jenkins的搭建就算完成了，下一篇文章我们将会使用jenkins创建一个任务，然后构造版本并且上传蒲公英，最终的目的都是通过一个脚本来完成上述的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于一个APP来说，我相信我们开发最担心的就是出bug，只要是线上APP出bug，心里就慌得很，这是一件很严重的事情，还有可能让用户一气之下把你的APP删掉，从此再也不会出现在他的手机里面。&lt;/p&gt;
&lt;p&gt;但是如果我们严格把控APP的质量，我们做到每天都构建一个版本并且测试，我们将这个APP上传到一个特定的测试系统，当有代码更新的时候或者每天设置一个时间去不断的跑测试，这样我们在开发阶段就发现很多问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上面我们说的就是CI(Continuous Integration)持续集成+TDD(Test Driven Development)测试驱动开发。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="jenkins" scheme="http://lemon2well.top/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>用队列实现栈和用栈实现队列</title>
    <link href="http://lemon2well.top/2018/08/03/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://lemon2well.top/2018/08/03/常见算法/用队列实现栈和用栈实现队列/</id>
    <published>2018-08-03T02:44:23.000Z</published>
    <updated>2018-08-03T02:46:05.639Z</updated>
    
    <content type="html"><![CDATA[<p>用两个栈来实现队列，思路和用数组实现队列一样</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//用栈实现队列</span><br><span class="line">struct QueueByStack&#123;</span><br><span class="line">    </span><br><span class="line">    var Peek: Int? &#123;</span><br><span class="line">        mutating middleCaulate()</span><br><span class="line">        return rightStack?.peek</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    typealias Element = Int</span><br><span class="line">    </span><br><span class="line">    private var leftStack:IntergerStack?</span><br><span class="line">    private var rightStack:IntergerStack?</span><br><span class="line">    </span><br><span class="line">    init() &#123;</span><br><span class="line">    leftStack = IntergerStack()</span><br><span class="line">    rightStack = IntergerStack()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var isEmpty: Bool &#123;return leftStack!.isEmpty &amp;&amp; rightStack!.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return leftStack!.Size + rightStack!.Size&#125;</span><br><span class="line">    </span><br><span class="line">    mutating func middleCaulate()&#123;</span><br><span class="line">        if leftStack!.isEmpty &#123;</span><br><span class="line">            while !rightStack!.isEmpty&#123;</span><br><span class="line">                leftStack!.push((rightStack?.pop())!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func enQueue(_ newElement: Int) &#123;</span><br><span class="line">        rightStack?.push(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func deQueue() -&gt; Int? &#123;</span><br><span class="line">        middleCaulate()</span><br><span class="line">        return leftStack?.peek</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用两个队列来实现栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct StackByQueue &#123;</span><br><span class="line">    private var queueA : IntergerQueue?</span><br><span class="line">    private var queueB : IntergerQueue?</span><br><span class="line">    init() &#123;</span><br><span class="line">        queueA = IntergerQueue()</span><br><span class="line">        queueB = IntergerQueue()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var isEmpty: Bool&#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return queueA!.isEmpty &amp;&amp; queueB!.isEmpty</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var Size: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return queueA!.Size</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var peek: Int?&#123;</span><br><span class="line">        mutating get &#123;</span><br><span class="line">            transfer()</span><br><span class="line">            let obj = queueB?.Peek</span><br><span class="line">            swap()</span><br><span class="line">            return obj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func push(_ newElement:Int)&#123;</span><br><span class="line">        queueB?.enQueue(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func pop()-&gt;Int?&#123;</span><br><span class="line">        transfer()</span><br><span class="line">        let obj = queueB?.deQueue()</span><br><span class="line">        swap()</span><br><span class="line">        return obj</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func transfer() &#123;</span><br><span class="line">        if queueB?.Size != 1&#123;</span><br><span class="line">            queueA?.enQueue((queueB?.deQueue())!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func swap()&#123;</span><br><span class="line">        (queueA,queueB) = (queueB,queueA)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用两个栈来实现队列，思路和用数组实现队列一样&lt;/p&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://lemon2well.top/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>swift实现栈和队列</title>
    <link href="http://lemon2well.top/2018/08/02/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/swift%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://lemon2well.top/2018/08/02/常见算法/swift实现栈和队列/</id>
    <published>2018-08-02T15:58:37.000Z</published>
    <updated>2018-08-02T16:00:14.923Z</updated>
    
    <content type="html"><![CDATA[<p>在swift中并没有内设的栈和队列，接下来我们通过数组来实现栈和队列</p><p>栈的实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protocol Stack &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    //是否为空</span><br><span class="line">    var isEmpty: Bool&#123; get &#125;</span><br><span class="line">    //栈的大小</span><br><span class="line">    var Size: Int&#123; get &#125;</span><br><span class="line">    //栈顶元素</span><br><span class="line">    var peek: Element? &#123; get &#125;</span><br><span class="line">    //入栈</span><br><span class="line">    mutating func push(_ newElement:Element)</span><br><span class="line">    //出栈</span><br><span class="line">    mutating func pop()-&gt;Element?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct IntegerStack:Stack &#123;</span><br><span class="line">    typealias Element  = Int</span><br><span class="line">    private var stack = [Element]()</span><br><span class="line">    var isEmpty: Bool &#123;return stack.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return stack.count&#125;</span><br><span class="line">    var peek: Int? &#123;return stack.last&#125;</span><br><span class="line">    mutating func push(_ newElement: Int) &#123;</span><br><span class="line">        self.stack.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    func pop() -&gt; Int? &#123;</span><br><span class="line">        return stack.last</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>队列的实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protocol Queue &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    var isEmpty: Bool &#123;get&#125;</span><br><span class="line">    var Size: Int &#123;get&#125;</span><br><span class="line">    var Peek:Element? &#123;get&#125;</span><br><span class="line">    mutating func enQueue(_ newElement:Element)</span><br><span class="line">    mutating func deQueue()-&gt;Element?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct IntergerQueue:Queue &#123;</span><br><span class="line">    typealias Element = Int</span><br><span class="line">    private var left = [Element]()</span><br><span class="line">    private var right = [Element]()</span><br><span class="line">    var isEmpty: Bool &#123;return left.isEmpty &amp;&amp; right.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return left.count + right.count&#125;</span><br><span class="line">    var Peek: Element? &#123;return left.isEmpty ? right.first : left.last&#125;</span><br><span class="line">    mutating func enQueue(_ newElement: Int) &#123;</span><br><span class="line">       right.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func deQueue() -&gt; Element? &#123;</span><br><span class="line">        if left.isEmpty &#123;</span><br><span class="line">            left = right.reversed()</span><br><span class="line">            right.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        return left.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在swift中并没有内设的栈和队列，接下来我们通过数组来实现栈和队列&lt;/p&gt;
&lt;p&gt;栈的实现代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protocol Stack &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    associatedtype Element&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //是否为空&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var isEmpty: Bool&amp;#123; get &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //栈的大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var Size: Int&amp;#123; get &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //栈顶元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var peek: Element? &amp;#123; get &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //入栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mutating func push(_ newElement:Element)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //出栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mutating func pop()-&amp;gt;Element?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct IntegerStack:Stack &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    typealias Element  = Int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private var stack = [Element]()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var isEmpty: Bool &amp;#123;return stack.isEmpty&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var Size: Int &amp;#123;return stack.count&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var peek: Int? &amp;#123;return stack.last&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mutating func push(_ newElement: Int) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.stack.append(newElement)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func pop() -&amp;gt; Int? &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return stack.last&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="常见算法" scheme="http://lemon2well.top/categories/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="http://lemon2well.top/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://lemon2well.top/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>网络层设计方案以及去Model化实践</title>
    <link href="http://lemon2well.top/2018/08/02/iOS%20%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E4%BB%A5%E5%8F%8A%E5%8E%BBModel%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>http://lemon2well.top/2018/08/02/iOS 开发/网络层设计方案以及去Model化实践/</id>
    <published>2018-08-02T09:30:30.000Z</published>
    <updated>2018-08-02T09:32:52.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然在网上看到<a href="https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="noopener">casa的网络层设计方案</a>，在以前的iOS开发中，用的最多的就是集约型的网络请求+去Model的形式，然而在看完这篇文章之后我觉得好像发现了新大陆，原来还可以这么玩。</p><a id="more"></a><blockquote><ol><li>此网络层设计方案最大的好处就是解耦，每个API都有特定的APIManager管理，可以方便的缓存数据以及取消网络请求。</li><li>在集约型网络基础上封装了散约型的API，参数以及请求以及处理请求数据全部封装到该APIManager方法里面。</li><li>通过Delegate的方法回调，更好的方便调试以及释放对象。如果以block来调用的话首先不方便调试，其次会延长对象的生命周期，对象需要必须等到网络请求回来之后才能释放。</li><li>提供一个BaseAPIManager，然后通过IOP的方式约束子类必须要遵循APIRequestProtocol，通过实现该协议的方式来提供给API参数，这样父类就不用提供空载函数。 该父类还提供一个代理，该代理用于返回数据。</li><li>最后是去Model化的设计，APIRequestProtocol 提供了一个<code>-(id)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer;</code>协议方法，在该方法里面可以会传入一个遵守ReformProtocol协议的reformer，到时reformer就可以自定义处理数据的方法，返回特定的数据</li><li>ReformProtocol有一个<code>- (id)reformDataWith:(LMBaseAPIManager*)apiManager;</code>的协议方法，里面可以根据apiManager做判断，然后返回不同的数据，也就是说，一个reformer可以对应多个apiManager。</li></ol></blockquote><p>具体的原理和好处在case的文章里面已经说得很清楚了</p><h2 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h2><p><img src="http://pcd17v2u0.bkt.clouddn.com/15331959524160.jpg" alt=""></p><ul><li>LMNetwork是具体的网络出口类，里面提供了集约化的网络请求方法，通过block返回数据。</li><li><p>LMBaseAPIManager是网络请求基类，里面有一个遵循了APIRequestProtocol协议的request，这个协议提供了网络请求参数的的方法和处理网络请求结果的方法。发送网络请求的时候会通过这个request获取必要的参数，以及返回数据的时候通过这个类处理数据。</p><p>该类还提供了一个遵循了APIResponseProtocol的代理对象，当网络返回数据的时候会调用该协议方法，该协议方法返回一个遵循APIRequestProtocol的request，调用方需要调用<code>fetchDataWithReformer:</code>方法，并且传入一个reformer，然后在该方法的实现里面就可以将apiManager传给reformer，reformer可以根据不同apiManager做不同的数据返回了。</p><p>LMBaseAPIManager还提供了两个属性，一个responseData和error，网络请求结果和错误都会放到这里面，到时将apiManager传到reformer的时候，通过这两个属性可以取出数据。</p><p>LMBaseAPIManager还可以提供一个isCache的方法，可以自己设置缓存策略。</p><p>总的来说，LMBaseAPIManager需要派生一个子类，然后子类需要实现apiRequestProtocol方法，提供网络必要的参数。调用<code>startRequest</code>方法之后调用LMNetwork发送网络请求。当网络请求回来之后，通过代理回调结果，并且将apiManager返回，调用方收到回调时候，传入reformer对数据进行处理。</p></li></ul><ul><li><p>LMReformerProtocol是一个协议，里面有一个协议方法<code>- (id)reformDataWith:(LMBaseAPIManager*)apiManager;</code>该方法用来处理返回数据。</p></li><li><p>LMProductionAPIManager是LMBaseAPIManagerd的派生类，里面提供了apiRequestProtocol协议方法的实现。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以上已经将框架介绍清楚了，下面是代码实现：</p><ol><li>首先初始化productionAPIManager并且设计代理。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (LMProductionAPIManager *)productionAPIManager&#123;</span><br><span class="line">    if(!_productionAPIManager)&#123;</span><br><span class="line">        _productionAPIManager = [[LMProductionAPIManager alloc]init];</span><br><span class="line">        _productionAPIManager.response = self;</span><br><span class="line">    &#125;</span><br><span class="line">    return _productionAPIManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于LMProductionAPIManager是LMBaseAPIManagerd的子类，因此会调用父类的init方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        if ([self conformsToProtocol:@protocol(APIRequestProtocol)]) &#123;</span><br><span class="line">            self.request = (id&lt;APIRequestProtocol&gt;)self;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSAssert(NO, @&quot;子类必须要遵循APIRequestProtocol协议&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于子类遵循了 <code>@interface LMProductionAPIManager: LMBaseAPIManager&lt;APIRequestProtocol&gt;</code> APIRequestProtocol协议，因为该类内部有一个request的属性指向该对象。而该对象是遵循了上述的协议，所以要实现上述协议里面的方法，接下来看看LMProductionAPIManager里面的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@implementation LMProductionAPIManager</span><br><span class="line">- (NSString *)apiRequestName&#123;</span><br><span class="line">    return  @&quot;http://120.197.235.101:8080/apk/iosPagingQuery?pageNo=1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSString *)apiRequestMethod&#123;</span><br><span class="line">    return GET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)apiRequestParameters&#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer&#123;</span><br><span class="line">    if (reformer == nil) &#123;</span><br><span class="line">        return self.responseData;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [reformer reformDataWith:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该对象内部提供了url以及get方法和参数，还提供处理返回数据的实现。</p><ol start="2"><li><p>接下来调用 <code>[self.productionAPIManager startRequest];</code>方法，看看该方法内部会做什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   - (void)startRequest&#123;</span><br><span class="line">    [[LMNetwork sharedInstance]requestMethod:[self.request apiRequestMethod] url:[self.request apiRequestName] parameters:[self.request apiRequestParameters] finishBlock:^(id data, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            self.responseError = error;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">         self.responseData = data;</span><br><span class="line">         &#125;</span><br><span class="line">        if ([self.response respondsToSelector:@selector(apiResponseSuccess:)]) &#123;</span><br><span class="line">            [self.response apiResponseSuccess:self.request];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>该方法会发送网络请求并且将请求后的数据复制给当前对象的相关属性，然后通过代理回到结果，并且将当前请求对象返回。</p><ol start="3"><li><p>调用方收到代理之后进行处理 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)apiResponseSuccess:(id&lt;APIRequestProtocol&gt;)request&#123;</span><br><span class="line">    [MBProgressHUD hideHUD];</span><br><span class="line">    self.productionArr =  [request fetchDataWithReformer:[LMProductReformer new]];</span><br><span class="line">    [self.tableView reloadData];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>收到回调之后首先对初始化一个LMProductionReform对象，该对象遵循了LMReformerProtocol协议，待会再来看里面的实现。</p><p>然后调用request的协议方法 <code>fetchDataWithReformer</code>该方法的实现在第一点已经提到了，该方法内部会看一下有没有传reformer进来，如果没有的话直接返回未经处理的对象，如果有的话那就调用reformer的LMReformerProtocol协议方法。</p><p>接下来来看<code>LMReformerProtocol</code>方法的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   - (id)reformDataWith:(LMBaseAPIManager *)apiManager&#123;</span><br><span class="line">    //这里根据不同的APIManager返回相应的数据</span><br><span class="line">    if ([apiManager isKindOfClass: [LMProductionAPIManager class]]) &#123;</span><br><span class="line">        NSDictionary *dict = apiManager.responseData;</span><br><span class="line">        NSArray *list = dict[@&quot;list&quot;];</span><br><span class="line">        NSMutableArray *mArr = [NSMutableArray arrayWithCapacity:list.count];</span><br><span class="line">        for (NSDictionary *dict in list) &#123;</span><br><span class="line">            NSDictionary *infoDict = @&#123;kLMProductionVer:dict[@&quot;ver&quot;],kLMProductionVerDesc:dict[@&quot;verDesc&quot;]&#125;;</span><br><span class="line">            [mArr addObject:infoDict];</span><br><span class="line">        &#125;</span><br><span class="line">        return mArr;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return  nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>reform在这里根据不同的APIManager进行不同的解析，返回不同的数据。</p><p>到这里，整个网络和去model的设计就完成了。每个API都应该对应一个APIManager，但是可以使用同一个reformer，然后reformer对apimanager做判断从而返回不同的数据。</p><p>值得注意的是：由于我们用字典的形式来存储数据，所以肯定会有hardcode，我们可以定义一个头文件了里面包含所有我们用到的字符串常量，然后在reformer的实现文件里面给这些常量赋值。<br>如在<code>LMProductReformKeys.h</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern NSString *const kLMProductionVer;</span><br><span class="line">extern NSString *const kLMProductionVerDesc;</span><br></pre></td></tr></table></figure><p>在<code>LMProductReformer.m</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString * const kLMProductionVer = @&quot;productionVer&quot;;</span><br><span class="line">NSString * const kLMProductionVerDesc = @&quot;productionVerDesc&quot;;</span><br></pre></td></tr></table></figure><p>这样只要引入LMProductReformer.h都可以使用该常量。</p><p>完整的<a href="https://github.com/codemonkeybulucck/NoModelExample.git" target="_blank" rel="noopener">demo</a></p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;偶然在网上看到&lt;a href=&quot;https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;casa的网络层设计方案&lt;/a&gt;，在以前的iOS开发中，用的最多的就是集约型的网络请求+去Model的形式，然而在看完这篇文章之后我觉得好像发现了新大陆，原来还可以这么玩。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://lemon2well.top/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="去model" scheme="http://lemon2well.top/tags/%E5%8E%BBmodel/"/>
    
  </entry>
  
</feed>
