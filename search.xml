<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>持续集成之Jenkins构建项目并上传到蒲公英</title>
      <link href="/2018/08/08/iOS%20%E5%BC%80%E5%8F%91/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
      <url>/2018/08/08/iOS%20%E5%BC%80%E5%8F%91/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%92%B2%E5%85%AC%E8%8B%B1/</url>
      <content type="html"><![CDATA[<blockquote><p>在第一篇<a href="http://lemon2well.top/2018/08/07/iOS%20开发/持续集成之Jenkins搭建/">Jenkins的搭建</a>中我们已经把本地jenkins环境都搭建好了，接下来我们通过jenkins构建一个ipa并且上传到蒲公英。</p></blockquote><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p>1.首先选择左侧的新建任务，然后下面是构建该工程的基本信息</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336240434000.jpg" alt=""></p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336241947095.jpg" alt=""></p><a id="more"></a><h2 id="填写源码地址"><a href="#填写源码地址" class="headerlink" title="填写源码地址"></a>填写源码地址</h2><ol start="2"><li>下面填写github或者gitLab的源码的地址，并且需要配置对应的Credentials，这里相当是授权。等到构建的时候jenkins会从对应的git上面拉去代码开始构建。</li></ol><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336242653880.jpg" alt=""></p><p>填完源码的网址之后需要填写git的账号密码或者输入对应的私钥。点击Add然后会出现下面的界面</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336242294039.jpg" alt=""></p><blockquote><p>如果你的git已经配置了ssh那么可以选择SSH username and private key， 然后到你的/Users/用户名/.ssh/id_rsa 将这个私钥文件里面的所有内容复制到privatekey (enter directly)上面去。<br>否则可以按照上图那样，选择username with password，然后输入用户名和密码</p></blockquote><h2 id="设置触发器（非必要）"><a href="#设置触发器（非必要）" class="headerlink" title="设置触发器（非必要）"></a>设置触发器（非必要）</h2><ol start="3"><li>构建触发器是与测试相关的操作，这里可以根据需求选择构建的触发时刻，例如选择第二个就是当代码仓库有push事件的时候，就会触发构建操作，然后构建一个版本并且通知测试去操作。因为我们是手动构建，所以这里先不管这个。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336265635081.jpg" alt=""></li></ol><h2 id="设置签名和证书"><a href="#设置签名和证书" class="headerlink" title="设置签名和证书"></a>设置签名和证书</h2><ol start="4"><li>接下我们需要设置签名文件和证书。<br>首先保存我们原先的设置，然后回到首页，选择系统管理-&gt;Keychains and Provisioning Profiles Management 点击选取文件，然后选择login.keychain文件和 provisioning file 上传。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336269763882.jpg" alt=""></li></ol><p>填写本机密码，输入描述，然后选择Add Code Signing Identity 输入签名文件的名称，这里的名称可以到钥匙串找到对应的证书然后选择显示简介然后复制头部的文字。</p><blockquote><p>这个Keychain在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下</p></blockquote><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336275407363.jpg" alt=""></p><p>上面的配置完成之后，回到任务的配置里面，选择对应的keyChain和provisioning file</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336251729871.jpg" alt=""></p><h2 id="构建命令"><a href="#构建命令" class="headerlink" title="构建命令"></a>构建命令</h2><ol start="5"><li>上面已经将所有的设置都配置好了，接下来需要选择构建的方式，你可以选择通过xcode来构建，但是这里我们选择shell 并且也推荐通过shell来构建。选择执行shell，然后输入下面的代码，里面有些地方需要改成你自己的，根据实际情况改就可以了，不过一定要注意一点，jenkins那个编辑框极其不好用，我因为不小心输入了一个空格字符然后一直报 command not found ，搞到我一直以为是jenkins配置环境的问题。如果中间有构建错误，点击构建那个红点然后可以查看具体的控制台信息，根据错误提示来修改就好了</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 工程名，记得改成你自己</span><br><span class="line">APP_NAME=&quot;TestUMCOpen&quot;</span><br><span class="line"># 证书</span><br><span class="line">CODE_SIGN_DISTRIBUTION=&quot;iPhone Distribution: XXXXXXXXXX&quot;</span><br><span class="line"># info.plist路径</span><br><span class="line">project_infoplist_path=&quot;./$&#123;APP_NAME&#125;/Info.plist&quot;</span><br><span class="line"></span><br><span class="line">#取版本号</span><br><span class="line">bundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line"></span><br><span class="line">#取build值</span><br><span class="line">bundleVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line">DATE=&quot;$(date +%Y%m%d)&quot;</span><br><span class="line">IPAFOLDER=&quot;$&#123;APP_NAME&#125;_V$&#123;bundleShortVersion&#125;_$&#123;DATE&#125;&quot;</span><br><span class="line"></span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">ARCHIVE_PATH=&quot;$&#123;HOME&#125;/Desktop/archive&quot;</span><br><span class="line">IPA_PATH=&quot;$ARCHIVE_PATH/$&#123;IPAFOLDER&#125;/$&#123;APP_NAME&#125;.ipa&quot;</span><br><span class="line">PLIST_PATH=&quot;$ARCHIVE_PATH/ADHocExportOptions.plist&quot;</span><br><span class="line">echo $&#123;IPA_PATH&#125;</span><br><span class="line">echo $&#123;PLIST_PATH&#125;</span><br><span class="line"></span><br><span class="line">#下面两行是没有Cocopods的用法</span><br><span class="line"># 清除上次构建</span><br><span class="line">xcodebuild clean -project &quot;$&#123;APP_NAME&#125;.xcodeproj&quot; -scheme $&#123;APP_NAME&#125;   -configuration &apos;Release&apos;</span><br><span class="line"># 构建xcarchive文件</span><br><span class="line">xcodebuild archive -project &quot;$&#123;APP_NAME&#125;.xcodeproj&quot; -scheme $&#123;APP_NAME&#125; -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot;</span><br><span class="line"></span><br><span class="line">#下面两行是有cocopods的用法</span><br><span class="line"># xcodebuild clean -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme $&#123;APP_NAME&#125;   -configuration &apos;Release&apos;</span><br><span class="line"></span><br><span class="line"># xcodebuild archive -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme $&#123;APP_NAME&#125; -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot;</span><br><span class="line"></span><br><span class="line"># 导出ipa</span><br><span class="line">xcodebuild -exportArchive -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot; -exportPath &quot;$ARCHIVE_PATH/$IPAFOLDER&quot; -exportOptionsPlist &quot;$PLIST_PATH&quot;</span><br><span class="line"></span><br><span class="line">#打开文件夹</span><br><span class="line">open $&#123;ARCHIVE_PATH&#125;</span><br></pre></td></tr></table></figure><p><strong>这里有个地方需要注意一下，在xcode9之后，需要提供一个信息才能打包，我们可以通过xcode打包出来ipa文件然后复制那个ExportOption.plist文件就好了以下是我的文件的内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;compileBitcode&lt;/key&gt;</span><br><span class="line">&lt;false/&gt;</span><br><span class="line">&lt;key&gt;method&lt;/key&gt;</span><br><span class="line">&lt;string&gt;enterprise&lt;/string&gt;</span><br><span class="line">&lt;key&gt;provisioningProfiles&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;your Bundle id&lt;/key&gt;</span><br><span class="line">&lt;string&gt;证书的名字&lt;/string&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;key&gt;signingCertificate&lt;/key&gt;</span><br><span class="line">&lt;string&gt;iPhone Distribution&lt;/string&gt;</span><br><span class="line">&lt;key&gt;signingStyle&lt;/key&gt;</span><br><span class="line">&lt;string&gt;manual&lt;/string&gt;</span><br><span class="line">&lt;key&gt;stripSwiftSymbols&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;teamID&lt;/key&gt;</span><br><span class="line">&lt;string&gt;7LD5QKB26C&lt;/string&gt;</span><br><span class="line">&lt;key&gt;thinning&lt;/key&gt;</span><br><span class="line">&lt;string&gt;none&lt;/string&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>如果成功之后会在我们指定的文件里面生成下面的文件，除了那个ADHocExportOption.plist是我创建的，前天的文件都是jenkins构建的。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336256611678.jpg" alt=""></p></li><li><p>上传ipa到蒲公英</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#上传到蒲公英</span><br><span class="line">uKey=&quot;aec42b3cc32*******837cc7084a819c&quot;</span><br><span class="line">#蒲公英上的API Key</span><br><span class="line">apiKey=&quot;ba4e62***************8067a87315&quot;</span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">echo $IPA_PATH</span><br><span class="line"> </span><br><span class="line">#执行上传至蒲公英的命令</span><br><span class="line">echo &quot;++++++++++++++upload+++++++++++++&quot;</span><br><span class="line">curl -F &quot;file=@$&#123;IPA_PATH&#125;&quot; -F &quot;uKey=$&#123;uKey&#125;&quot; -F &quot;_api_key=$&#123;apiKey&#125;&quot; http://www.pgyer.com/apiv1/app/upload</span><br></pre></td></tr></table></figure><h2 id="命令行构建"><a href="#命令行构建" class="headerlink" title="命令行构建"></a>命令行构建</h2><ol start="7"><li>至此我们已经完成手动构建项目了，接下来我们利用Jenkins命令行来完成一行命令构建版本<br>进入系统管理然后选择Jenkins命令行，下载最新的jenkins-cli.jar<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336535463602.jpg" alt=""></li></ol><p>下载完成之后，如果直接运行上述命令行会提示没有权限，这个时候我们需要配置一下SSH。点击右上角的用户名，然后点击设置，找到SSH，然后将本地的公钥复制粘贴到上面，保存。</p><p>下面是完整的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">add-job-to-view</span><br><span class="line">    Adds jobs to view.</span><br><span class="line">  build</span><br><span class="line">    Builds a job, and optionally waits until its completion.</span><br><span class="line">  cancel-quiet-down</span><br><span class="line">    Cancel the effect of the &quot;quiet-down&quot; command.</span><br><span class="line">  clear-queue</span><br><span class="line">    Clears the build queue.</span><br><span class="line">  connect-node</span><br><span class="line">    Reconnect to a node(s)</span><br><span class="line">  console</span><br><span class="line">    Retrieves console output of a build.</span><br><span class="line">  copy-job</span><br><span class="line">    Copies a job.</span><br><span class="line">  create-credentials-by-xml</span><br><span class="line">    Create Credential by XML</span><br><span class="line">  create-credentials-domain-by-xml</span><br><span class="line">    Create Credentials Domain by XML</span><br><span class="line">  create-job</span><br><span class="line">    Creates a new job by reading stdin as a configuration XML file.</span><br><span class="line">  create-node</span><br><span class="line">    Creates a new node by reading stdin as a XML configuration.</span><br><span class="line">  create-view</span><br><span class="line">    Creates a new view by reading stdin as a XML configuration.</span><br><span class="line">  delete-builds</span><br><span class="line">    Deletes build record(s).</span><br><span class="line">  delete-credentials</span><br><span class="line">    Delete a Credential</span><br><span class="line">  delete-credentials-domain</span><br><span class="line">    Delete a Credentials Domain</span><br><span class="line">  delete-job</span><br><span class="line">    Deletes job(s).</span><br><span class="line">  delete-node</span><br><span class="line">    Deletes node(s)</span><br><span class="line">  delete-view</span><br><span class="line">    Deletes view(s).</span><br><span class="line">  disable-job</span><br><span class="line">    禁用任务</span><br><span class="line">  disconnect-node</span><br><span class="line">    Disconnects from a node.</span><br><span class="line">  enable-job</span><br><span class="line">    启用任务</span><br><span class="line">  get-credentials-as-xml</span><br><span class="line">    Get a Credentials as XML (secrets redacted)</span><br><span class="line">  get-credentials-domain-as-xml</span><br><span class="line">    Get a Credentials Domain as XML</span><br><span class="line">  get-job</span><br><span class="line">    Dumps the job definition XML to stdout.</span><br><span class="line">  get-node</span><br><span class="line">    Dumps the node definition XML to stdout.</span><br><span class="line">  get-view</span><br><span class="line">    Dumps the view definition XML to stdout.</span><br><span class="line">  groovy</span><br><span class="line">    Executes the specified Groovy script.</span><br><span class="line">  groovysh</span><br><span class="line">    Runs an interactive groovy shell.</span><br><span class="line">  help</span><br><span class="line">    Lists all the available commands or a detailed description of single command.</span><br><span class="line">  import-credentials-as-xml</span><br><span class="line">    Import credentials as XML. The output of &quot;list-credentials-as-xml&quot; can be used as input here as is, the only needed change is to set the actual Secrets which are redacted in the output.</span><br><span class="line">  install-plugin</span><br><span class="line">    Installs a plugin either from a file, an URL, or from update center.</span><br><span class="line">  install-tool</span><br><span class="line">    Performs automatic tool installation, and print its location to stdout. Can be only called from inside a build. [deprecated]</span><br><span class="line">  keep-build</span><br><span class="line">    永久保留这次构建。</span><br><span class="line">  list-changes</span><br><span class="line">    Dumps the changelog for the specified build(s).</span><br><span class="line">  list-credentials</span><br><span class="line">    Lists the Credentials in a specific Store</span><br><span class="line">  list-credentials-as-xml</span><br><span class="line">    Export credentials as XML. The output of this command can be used as input for &quot;import-credentials-as-xml&quot; as is, the only needed change is to set the actual Secrets which are redacted in the output.</span><br><span class="line">  list-credentials-context-resolvers</span><br><span class="line">    List Credentials Context Resolvers</span><br><span class="line">  list-credentials-providers</span><br><span class="line">    List Credentials Providers</span><br><span class="line">  list-jobs</span><br><span class="line">    Lists all jobs in a specific view or item group.</span><br><span class="line">  list-plugins</span><br><span class="line">    Outputs a list of installed plugins.</span><br><span class="line">  login</span><br><span class="line">    Saves the current credentials to allow future commands to run without explicit credential information. [deprecated]</span><br><span class="line">  logout</span><br><span class="line">    Deletes the credentials stored with the login command. [deprecated]</span><br><span class="line">  mail</span><br><span class="line">    Reads stdin and sends that out as an e-mail.</span><br><span class="line">  offline-node</span><br><span class="line">    Stop using a node for performing builds temporarily, until the next &quot;online-node&quot; command.</span><br><span class="line">  online-node</span><br><span class="line">    Resume using a node for performing builds, to cancel out the earlier &quot;offline-node&quot; command.</span><br><span class="line">  quiet-down</span><br><span class="line">    Quiet down Jenkins, in preparation for a restart. Don’t start any builds.</span><br><span class="line">  reload-configuration</span><br><span class="line">    Discard all the loaded data in memory and reload everything from file system. Useful when you modified config files directly on disk.</span><br><span class="line">  reload-job</span><br><span class="line">    Reload job(s)</span><br><span class="line">  remove-job-from-view</span><br><span class="line">    Removes jobs from view.</span><br><span class="line">  restart</span><br><span class="line">    重新启动Jenkins</span><br><span class="line">  safe-restart</span><br><span class="line">    安全地重新启动Jenkins</span><br><span class="line">  safe-shutdown</span><br><span class="line">    Puts Jenkins into the quiet mode, wait for existing builds to be completed, and then shut down Jenkins.</span><br><span class="line">  session-id</span><br><span class="line">    Outputs the session ID, which changes every time Jenkins restarts.</span><br><span class="line">  set-build-description</span><br><span class="line">    Sets the description of a build.</span><br><span class="line">  set-build-display-name</span><br><span class="line">    Sets the displayName of a build.</span><br><span class="line">  set-build-parameter</span><br><span class="line">    Update/set the build parameter of the current build in progress. [deprecated]</span><br><span class="line">  set-build-result</span><br><span class="line">    Sets the result of the current build. Works only if invoked from within a build. [deprecated]</span><br><span class="line">  set-external-build-result</span><br><span class="line">    Set external monitor job result.</span><br><span class="line">  shutdown</span><br><span class="line">    立刻关闭Jenkins</span><br><span class="line">  update-credentials-by-xml</span><br><span class="line">    Update Credentials by XML</span><br><span class="line">  update-credentials-domain-by-xml</span><br><span class="line">    Update Credentials Domain by XML</span><br><span class="line">  update-job</span><br><span class="line">    Updates the job definition XML from stdin. The opposite of the get-job command.</span><br><span class="line">  update-node</span><br><span class="line">    Updates the node definition XML from stdin. The opposite of the get-node command.</span><br><span class="line">  update-view</span><br><span class="line">    Updates the view definition XML from stdin. The opposite of the get-view command.</span><br><span class="line">  version</span><br><span class="line">    Outputs the current version.</span><br><span class="line">  wait-node-offline</span><br><span class="line">    Wait for a node to become offline.</span><br><span class="line">  wait-node-online</span><br><span class="line">    Wait for a node to become online.</span><br><span class="line">  who-am-i</span><br><span class="line">    Reports your credential and permissions.</span><br></pre></td></tr></table></figure><p>我们执行命令的格式是<br><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -ssh -user username command</code><br>command 就是我们需要执行的命令，build是构建命令，下面的事情就很简单了。</p><p><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -ssh -user username build UMC10.1.0Demo</code><br><strong>UMC10.1.0Demo是我们一开始创建任务的时候的名字，这个时候就会自动构建版本并且上传蒲公英</strong><br>可以将上述命令放到.command文件里面，并且增加可执行权限，这样双击这个文件的时候就会触发构建。注意里面cli.jar的路径。</p><p>上述命令指示构建一个指定版本的脚本，下面我们可以通过列举出所有的任务，然后选择其中一个任务来开始构建版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">ps -fe|grep &quot;jenkins&quot; |grep -v grep</span><br><span class="line">if [ $? -ne 0 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;******请先使用Jenkins -h来启动jenkins**********&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;********检测到Jenkins已经启动**********&quot;</span><br><span class="line">fi</span><br><span class="line">LOCALHOST=&quot;http://localhost:8080/&quot;</span><br><span class="line">CLIJAR=&quot;/Users/lemon/jenkins-cli.jar&quot;</span><br><span class="line"></span><br><span class="line">java -jar $&#123;CLIJAR&#125; -s $&#123;LOCALHOST&#125; -ssh -user admin list-jobs</span><br><span class="line"></span><br><span class="line">echo &quot;*******请输入你要构建的任务*******&quot;</span><br><span class="line">read BuildName</span><br><span class="line"></span><br><span class="line">java -jar $&#123;CLIJAR&#125; -s $&#123;LOCALHOST&#125; -ssh -user admin build $&#123;BuildName&#125;</span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">echo &quot;*******正在构建$&#123;BuildName&#125;，构建完成后会自动打开本地文件夹*******&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;*******构建$&#123;BuildName&#125;失败，请检查是否有对应的任务*******&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述：总的来说在我们jenkins已经安装好的情况下，我们需要做的就是构建任务，然后填写源码地址，设置构建策略，设置签名和证书，编写构建代码（包括上传蒲公英），编写shell。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
            <tag> 蒲公英 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>持续集成之Jenkins搭建</title>
      <link href="/2018/08/07/iOS%20%E5%BC%80%E5%8F%91/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/08/07/iOS%20%E5%BC%80%E5%8F%91/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于一个APP来说，我相信我们开发最担心的就是出bug，只要是线上APP出bug，心里就慌得很，这是一件很严重的事情，还有可能让用户一气之下把你的APP删掉，从此再也不会出现在他的手机里面。</p><p>但是如果我们严格把控APP的质量，我们做到每天都构建一个版本并且测试，我们将这个APP上传到一个特定的测试系统，当有代码更新的时候或者每天设置一个时间去不断的跑测试，这样我们在开发阶段就发现很多问题。</p><blockquote><p>上面我们说的就是CI(Continuous Integration)持续集成+TDD(Test Driven Development)测试驱动开发。</p></blockquote><a id="more"></a><h2 id="持续集成带来的好处"><a href="#持续集成带来的好处" class="headerlink" title="持续集成带来的好处"></a>持续集成带来的好处</h2><p>持续集成带来的好处是显而易见的</p><ol><li><p>减少风险。通过每天构建版本，在开发阶段就可以发现项目的缺陷，排除一些因为项目设置的低级错误而导致的bug，用同样的脚本和过程构建和测试软件，排除因代码外的其他因素。</p></li><li><p>减少重复的过程，提高效率。当项目变大之后，频繁的打包会很影响开发的效率，但是有了持续集成我们不用关心打包的过程，将重复的build,archive,code sign交给提供构建服务的机器去做，将时间放在更有意义的事情上面。</p></li><li><p>随时可部署。持续集成有一个好处就是我们每天都会做构建版本，可以交付部署上线，当我们无休止的讨论需求软件质量或者开发进度的时候，对于客户来说，不如一个可安装的软件包来得实际</p></li></ol><h3 id="持续集成之Jenkins"><a href="#持续集成之Jenkins" class="headerlink" title="持续集成之Jenkins"></a>持续集成之Jenkins</h3><p>CI包括三个基本的元素，第一个是可自动构建版本的服务，第二个是代码仓库，第三个是搭建了服务的机器。</p><blockquote><p>可自动构建版本的服务目前有Jenkins和fastlane。<br>代码仓库也就是我们平时使用的github,gitlab等等<br>在iOS中机器必须是搭建OSX系统的机器，因为构建需要用到xcodeBuild命令，该命令由xcode提供，而xcode只能安装在OSX系统下面。</p></blockquote><p>下面我们要说的就是可自动构建版本的服务，<a href="https://jenkins.io" target="_blank" rel="noopener">Jenkins</a>。</p><p>Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性，构建完成之后通过脚本直接上传到分发平台或者测试平台。</p><h2 id="Jenkins搭建"><a href="#Jenkins搭建" class="headerlink" title="Jenkins搭建"></a>Jenkins搭建</h2><p>jenkins有两种安装方式</p><p>一种是通过在<a href="https://jenkins.io/download" target="_blank" rel="noopener">官网</a>下载pkg安装包的方式安装，图形化的安装界面直接跟着提示安装就好了。</p><p>第二种是通过homebrew安装，不过在安装之前我们需要检测本地环境是否已经安装了java，可以使用<code>java -version</code>来查看当前的java版本，如果没有安装的java的话可以在<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">这里</a>安装java。<br>还要检测是否已经安装了homebrew,查看本机homebrew版本’brew -v’。</p><p>如果java和homebrew都已经安装好，就可以开始安装jenkins了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure><p>当出现Jenkins is fully up and running之后，表明jenkins已经安装好了，如果没有自动打开<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> ，可以到网页上面自行打开该外地址。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337123514685.png" alt=""></p><p>上面给了一个地址，提示你去那里找到初始化的密码。打开/User/Shared/Jenkins/Home/secrets/initialAdminPassword复制出密码。</p><p>接下来会提示你安装一些插件，安装默认的插件即可，不过就算这里安装失败了也没关系，后面进到主界面还可以继续安装。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337131168237.png" alt=""></p><p>安装完插件之后会提示你创建一个jenkins用户。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15337133154570.jpg" alt=""></p><p>输入这些信息之后点击save And Finish安装的过程就算完成了。接下来可以进入到jenkins主界面了。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337135245241.jpg" alt=""><br>我们主要关注一下面板左侧的选项，点击“系统管理”，然后找到“管理插件”<br>在“可选插件”中选中“GitLab Plugin”和“Gitlab Hook Plugin”这两项，然后安装。<br>安装Xcode插件<br>同安装GitLab插件的步骤一样，我们依次选择系统管理-&gt;管理插件，在“可选插件”中选中“Xcode integration”安装，安装完这个插件我们还需要安装一个“Keychains and Provisioning Profiles Management”插件。这个插件用于我们设置签名和证书。</p><p>安装“Keychains and Provisioning Profiles Management”之后，我们去到系统管理-&gt;Keychains and Provisioning Profiles Management设置签名和证书。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337147054369.jpg" alt=""></p><p>这里需要选择 login.keychain ，在 /Users/用户名/Library/keychains/login.keychain 目录里。如果不能通过选择的话，可以把login.keychain拷贝到桌面，然后在选择上传。<br>Code Signing Identity，可以添加多项。进入钥匙串，选择开发者证书或发布证书，拷贝完全，粘贴至Jenkins的Code Signing Identity项。</p><p>当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下</p><p>到这里Jenkins的搭建就算完成了，下一篇文章我们将会使用jenkins创建一个任务，然后构造版本并且上传蒲公英，最终的目的都是通过一个脚本来完成上述的操作。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用队列实现栈和用栈实现队列</title>
      <link href="/2018/08/03/%E7%AE%97%E6%B3%95/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2018/08/03/%E7%AE%97%E6%B3%95/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>用两个栈来实现队列，思路和用数组实现队列一样</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//用栈实现队列</span><br><span class="line">struct QueueByStack&#123;</span><br><span class="line">    </span><br><span class="line">    var Peek: Int? &#123;</span><br><span class="line">        mutating middleCaulate()</span><br><span class="line">        return rightStack?.peek</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    typealias Element = Int</span><br><span class="line">    </span><br><span class="line">    private var leftStack:IntergerStack?</span><br><span class="line">    private var rightStack:IntergerStack?</span><br><span class="line">    </span><br><span class="line">    init() &#123;</span><br><span class="line">    leftStack = IntergerStack()</span><br><span class="line">    rightStack = IntergerStack()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var isEmpty: Bool &#123;return leftStack!.isEmpty &amp;&amp; rightStack!.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return leftStack!.Size + rightStack!.Size&#125;</span><br><span class="line">    </span><br><span class="line">    mutating func middleCaulate()&#123;</span><br><span class="line">        if leftStack!.isEmpty &#123;</span><br><span class="line">            while !rightStack!.isEmpty&#123;</span><br><span class="line">                leftStack!.push((rightStack?.pop())!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func enQueue(_ newElement: Int) &#123;</span><br><span class="line">        rightStack?.push(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func deQueue() -&gt; Int? &#123;</span><br><span class="line">        middleCaulate()</span><br><span class="line">        return leftStack?.peek</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用两个队列来实现栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct StackByQueue &#123;</span><br><span class="line">    private var queueA : IntergerQueue?</span><br><span class="line">    private var queueB : IntergerQueue?</span><br><span class="line">    init() &#123;</span><br><span class="line">        queueA = IntergerQueue()</span><br><span class="line">        queueB = IntergerQueue()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var isEmpty: Bool&#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return queueA!.isEmpty &amp;&amp; queueB!.isEmpty</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var Size: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return queueA!.Size</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var peek: Int?&#123;</span><br><span class="line">        mutating get &#123;</span><br><span class="line">            transfer()</span><br><span class="line">            let obj = queueB?.Peek</span><br><span class="line">            swap()</span><br><span class="line">            return obj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func push(_ newElement:Int)&#123;</span><br><span class="line">        queueB?.enQueue(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func pop()-&gt;Int?&#123;</span><br><span class="line">        transfer()</span><br><span class="line">        let obj = queueB?.deQueue()</span><br><span class="line">        swap()</span><br><span class="line">        return obj</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func transfer() &#123;</span><br><span class="line">        if queueB?.Size != 1&#123;</span><br><span class="line">            queueA?.enQueue((queueB?.deQueue())!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func swap()&#123;</span><br><span class="line">        (queueA,queueB) = (queueB,queueA)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>swift实现栈和队列</title>
      <link href="/2018/08/02/%E7%AE%97%E6%B3%95/swift%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2018/08/02/%E7%AE%97%E6%B3%95/swift%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>在swift中并没有内设的栈和队列，接下来我们通过数组来实现栈和队列</p><p>栈的实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protocol Stack &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    //是否为空</span><br><span class="line">    var isEmpty: Bool&#123; get &#125;</span><br><span class="line">    //栈的大小</span><br><span class="line">    var Size: Int&#123; get &#125;</span><br><span class="line">    //栈顶元素</span><br><span class="line">    var peek: Element? &#123; get &#125;</span><br><span class="line">    //入栈</span><br><span class="line">    mutating func push(_ newElement:Element)</span><br><span class="line">    //出栈</span><br><span class="line">    mutating func pop()-&gt;Element?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct IntegerStack:Stack &#123;</span><br><span class="line">    typealias Element  = Int</span><br><span class="line">    private var stack = [Element]()</span><br><span class="line">    var isEmpty: Bool &#123;return stack.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return stack.count&#125;</span><br><span class="line">    var peek: Int? &#123;return stack.last&#125;</span><br><span class="line">    mutating func push(_ newElement: Int) &#123;</span><br><span class="line">        self.stack.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    func pop() -&gt; Int? &#123;</span><br><span class="line">        return stack.last</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>队列的实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protocol Queue &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    var isEmpty: Bool &#123;get&#125;</span><br><span class="line">    var Size: Int &#123;get&#125;</span><br><span class="line">    var Peek:Element? &#123;get&#125;</span><br><span class="line">    mutating func enQueue(_ newElement:Element)</span><br><span class="line">    mutating func deQueue()-&gt;Element?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct IntergerQueue:Queue &#123;</span><br><span class="line">    typealias Element = Int</span><br><span class="line">    private var left = [Element]()</span><br><span class="line">    private var right = [Element]()</span><br><span class="line">    var isEmpty: Bool &#123;return left.isEmpty &amp;&amp; right.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return left.count + right.count&#125;</span><br><span class="line">    var Peek: Element? &#123;return left.isEmpty ? right.first : left.last&#125;</span><br><span class="line">    mutating func enQueue(_ newElement: Int) &#123;</span><br><span class="line">       right.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func deQueue() -&gt; Element? &#123;</span><br><span class="line">        if left.isEmpty &#123;</span><br><span class="line">            left = right.reversed()</span><br><span class="line">            right.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        return left.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络层设计方案以及去Model化实践</title>
      <link href="/2018/08/02/iOS%20%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E4%BB%A5%E5%8F%8A%E5%8E%BBModel%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/08/02/iOS%20%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E4%BB%A5%E5%8F%8A%E5%8E%BBModel%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然在网上看到<a href="https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="noopener">casa的网络层设计方案</a>，在以前的iOS开发中，用的最多的就是集约型的网络请求+去Model的形式，然而在看完这篇文章之后我觉得好像发现了新大陆，原来还可以这么玩。</p><a id="more"></a><blockquote><ol><li>此网络层设计方案最大的好处就是解耦，每个API都有特定的APIManager管理，可以方便的缓存数据以及取消网络请求。</li><li>在集约型网络基础上封装了散约型的API，参数以及请求以及处理请求数据全部封装到该APIManager方法里面。</li><li>通过Delegate的方法回调，更好的方便调试以及释放对象。如果以block来调用的话首先不方便调试，其次会延长对象的生命周期，对象需要必须等到网络请求回来之后才能释放。</li><li>提供一个BaseAPIManager，然后通过IOP的方式约束子类必须要遵循APIRequestProtocol，通过实现该协议的方式来提供给API参数，这样父类就不用提供空载函数。 该父类还提供一个代理，该代理用于返回数据。</li><li>最后是去Model化的设计，APIRequestProtocol 提供了一个<code>-(id)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer;</code>协议方法，在该方法里面可以会传入一个遵守ReformProtocol协议的reformer，到时reformer就可以自定义处理数据的方法，返回特定的数据</li><li>ReformProtocol有一个<code>- (id)reformDataWith:(LMBaseAPIManager*)apiManager;</code>的协议方法，里面可以根据apiManager做判断，然后返回不同的数据，也就是说，一个reformer可以对应多个apiManager。</li></ol></blockquote><p>具体的原理和好处在case的文章里面已经说得很清楚了</p><h2 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h2><p><img src="http://pcd17v2u0.bkt.clouddn.com/15331959524160.jpg" alt=""></p><ul><li>LMNetwork是具体的网络出口类，里面提供了集约化的网络请求方法，通过block返回数据。</li><li><p>LMBaseAPIManager是网络请求基类，里面有一个遵循了APIRequestProtocol协议的request，这个协议提供了网络请求参数的的方法和处理网络请求结果的方法。发送网络请求的时候会通过这个request获取必要的参数，以及返回数据的时候通过这个类处理数据。</p><p>该类还提供了一个遵循了APIResponseProtocol的代理对象，当网络返回数据的时候会调用该协议方法，该协议方法返回一个遵循APIRequestProtocol的request，调用方需要调用<code>fetchDataWithReformer:</code>方法，并且传入一个reformer，然后在该方法的实现里面就可以将apiManager传给reformer，reformer可以根据不同apiManager做不同的数据返回了。</p><p>LMBaseAPIManager还提供了两个属性，一个responseData和error，网络请求结果和错误都会放到这里面，到时将apiManager传到reformer的时候，通过这两个属性可以取出数据。</p><p>LMBaseAPIManager还可以提供一个isCache的方法，可以自己设置缓存策略。</p><p>总的来说，LMBaseAPIManager需要派生一个子类，然后子类需要实现apiRequestProtocol方法，提供网络必要的参数。调用<code>startRequest</code>方法之后调用LMNetwork发送网络请求。当网络请求回来之后，通过代理回调结果，并且将apiManager返回，调用方收到回调时候，传入reformer对数据进行处理。</p></li></ul><ul><li><p>LMReformerProtocol是一个协议，里面有一个协议方法<code>- (id)reformDataWith:(LMBaseAPIManager*)apiManager;</code>该方法用来处理返回数据。</p></li><li><p>LMProductionAPIManager是LMBaseAPIManagerd的派生类，里面提供了apiRequestProtocol协议方法的实现。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以上已经将框架介绍清楚了，下面是代码实现：</p><ol><li>首先初始化productionAPIManager并且设计代理。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (LMProductionAPIManager *)productionAPIManager&#123;</span><br><span class="line">    if(!_productionAPIManager)&#123;</span><br><span class="line">        _productionAPIManager = [[LMProductionAPIManager alloc]init];</span><br><span class="line">        _productionAPIManager.response = self;</span><br><span class="line">    &#125;</span><br><span class="line">    return _productionAPIManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于LMProductionAPIManager是LMBaseAPIManagerd的子类，因此会调用父类的init方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        if ([self conformsToProtocol:@protocol(APIRequestProtocol)]) &#123;</span><br><span class="line">            self.request = (id&lt;APIRequestProtocol&gt;)self;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSAssert(NO, @&quot;子类必须要遵循APIRequestProtocol协议&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于子类遵循了 <code>@interface LMProductionAPIManager: LMBaseAPIManager&lt;APIRequestProtocol&gt;</code> APIRequestProtocol协议，因为该类内部有一个request的属性指向该对象。而该对象是遵循了上述的协议，所以要实现上述协议里面的方法，接下来看看LMProductionAPIManager里面的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@implementation LMProductionAPIManager</span><br><span class="line">- (NSString *)apiRequestName&#123;</span><br><span class="line">    return  @&quot;http://120.197.235.101:8080/apk/iosPagingQuery?pageNo=1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSString *)apiRequestMethod&#123;</span><br><span class="line">    return GET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)apiRequestParameters&#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer&#123;</span><br><span class="line">    if (reformer == nil) &#123;</span><br><span class="line">        return self.responseData;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [reformer reformDataWith:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该对象内部提供了url以及get方法和参数，还提供处理返回数据的实现。</p><ol start="2"><li><p>接下来调用 <code>[self.productionAPIManager startRequest];</code>方法，看看该方法内部会做什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   - (void)startRequest&#123;</span><br><span class="line">    [[LMNetwork sharedInstance]requestMethod:[self.request apiRequestMethod] url:[self.request apiRequestName] parameters:[self.request apiRequestParameters] finishBlock:^(id data, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            self.responseError = error;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">         self.responseData = data;</span><br><span class="line">         &#125;</span><br><span class="line">        if ([self.response respondsToSelector:@selector(apiResponseSuccess:)]) &#123;</span><br><span class="line">            [self.response apiResponseSuccess:self.request];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>该方法会发送网络请求并且将请求后的数据复制给当前对象的相关属性，然后通过代理回到结果，并且将当前请求对象返回。</p><ol start="3"><li><p>调用方收到代理之后进行处理 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)apiResponseSuccess:(id&lt;APIRequestProtocol&gt;)request&#123;</span><br><span class="line">    [MBProgressHUD hideHUD];</span><br><span class="line">    self.productionArr =  [request fetchDataWithReformer:[LMProductReformer new]];</span><br><span class="line">    [self.tableView reloadData];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>收到回调之后首先对初始化一个LMProductionReform对象，该对象遵循了LMReformerProtocol协议，待会再来看里面的实现。</p><p>然后调用request的协议方法 <code>fetchDataWithReformer</code>该方法的实现在第一点已经提到了，该方法内部会看一下有没有传reformer进来，如果没有的话直接返回未经处理的对象，如果有的话那就调用reformer的LMReformerProtocol协议方法。</p><p>接下来来看<code>LMReformerProtocol</code>方法的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   - (id)reformDataWith:(LMBaseAPIManager *)apiManager&#123;</span><br><span class="line">    //这里根据不同的APIManager返回相应的数据</span><br><span class="line">    if ([apiManager isKindOfClass: [LMProductionAPIManager class]]) &#123;</span><br><span class="line">        NSDictionary *dict = apiManager.responseData;</span><br><span class="line">        NSArray *list = dict[@&quot;list&quot;];</span><br><span class="line">        NSMutableArray *mArr = [NSMutableArray arrayWithCapacity:list.count];</span><br><span class="line">        for (NSDictionary *dict in list) &#123;</span><br><span class="line">            NSDictionary *infoDict = @&#123;kLMProductionVer:dict[@&quot;ver&quot;],kLMProductionVerDesc:dict[@&quot;verDesc&quot;]&#125;;</span><br><span class="line">            [mArr addObject:infoDict];</span><br><span class="line">        &#125;</span><br><span class="line">        return mArr;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return  nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>reform在这里根据不同的APIManager进行不同的解析，返回不同的数据。</p><p>到这里，整个网络和去model的设计就完成了。每个API都应该对应一个APIManager，但是可以使用同一个reformer，然后reformer对apimanager做判断从而返回不同的数据。</p><p>值得注意的是：由于我们用字典的形式来存储数据，所以肯定会有hardcode，我们可以定义一个头文件了里面包含所有我们用到的字符串常量，然后在reformer的实现文件里面给这些常量赋值。<br>如在<code>LMProductReformKeys.h</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern NSString *const kLMProductionVer;</span><br><span class="line">extern NSString *const kLMProductionVerDesc;</span><br></pre></td></tr></table></figure><p>在<code>LMProductReformer.m</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString * const kLMProductionVer = @&quot;productionVer&quot;;</span><br><span class="line">NSString * const kLMProductionVerDesc = @&quot;productionVerDesc&quot;;</span><br></pre></td></tr></table></figure><p>这样只要引入LMProductReformer.h都可以使用该常量。</p><p>完整的<a href="https://github.com/codemonkeybulucck/NoModelExample.git" target="_blank" rel="noopener">demo</a></p><p>以上。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 去model </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快行指针</title>
      <link href="/2018/08/01/%E7%AE%97%E6%B3%95/%E5%BF%AB%E8%A1%8C%E6%8C%87%E9%92%88/"/>
      <url>/2018/08/01/%E7%AE%97%E6%B3%95/%E5%BF%AB%E8%A1%8C%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<p>快行指针的定义就是有两个指针访问链表，但是一个指针的速度比另外一个快，或者说一个指针在前，一个在后。</p><p>根据这个特性我们可以用来检测一个链表中是否有环。</p><blockquote><p>假设：一个指针的速度是另外一个指针的两倍，它们同时开始访问同一个链表，如果链表有环的情况下，那么快行指针总会追上慢行指针，也就是总有一个时刻快行指针和慢行指针指向同一个节点，当慢行指针跑一圈的时候，快行指针此时刚好跑了两圈。<br><a id="more"></a><br>以下是具体算法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:Equatable &#123;</span><br><span class="line">//遵守Equatable协议</span><br><span class="line">    static func == (lhs: ListNode, rhs: ListNode) -&gt; Bool &#123;</span><br><span class="line">        if lhs.val == rhs.val &amp;&amp; lhs.next == rhs.next&#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      public var val: Int</span><br><span class="line">      public var next: ListNode?</span><br><span class="line">      public init(_ val: Int) &#123;</span><br><span class="line">          self.val = val</span><br><span class="line">          self.next = nil</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class quickSolution &#123;</span><br><span class="line">    func checkCycle(_ l1:ListNode?)-&gt;Bool&#123;</span><br><span class="line">        guard let l1 = l1 else&#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        var slowNode:ListNode? = l1,fastNode:ListNode? = l1</span><br><span class="line">        while fastNode != nil &amp;&amp; fastNode?.next != nil &#123;</span><br><span class="line">            slowNode = slowNode?.next</span><br><span class="line">            fastNode = fastNode?.next!.next</span><br><span class="line">            if slowNode == fastNode &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们依然可以用这个方法来解决另外一个问题。<br>删除链表中的第n个节点，例如：1-&gt;3-&gt;6-&gt;5-&gt;2 ，这里要删除倒数第2个节点。那么删除后的链表为： 1-&gt;3-&gt;6-&gt;2。</p><blockquote><p>思路：<br>假设快行指针从一开始就比慢行指针快n个节点，然后他们以相同的速度前进，当快行指针走到链表的最后一个节点的时候，慢行指针的当前节点的下一个节点就是我们要删除的节点。</p></blockquote><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class DeleteSolution &#123;</span><br><span class="line">    func deleteNode(_ l1:ListNode?,n:Int)-&gt;ListNode?&#123;</span><br><span class="line">        guard let l1 = l1 else&#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        let dummy = ListNode(0)</span><br><span class="line">        dummy.next = l1</span><br><span class="line">        var slowNode:ListNode? = dummy</span><br><span class="line">        var fastNode:ListNode? = dummy</span><br><span class="line">        //设置快行指针比慢行指针快n个节点</span><br><span class="line">        for _ in 0 ..&lt; n &#123;</span><br><span class="line">            if fastNode == nil &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            fastNode = fastNode?.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //同时移动两个指针</span><br><span class="line">        while fastNode != nil &amp;&amp; fastNode?.next != nil &#123;</span><br><span class="line">            slowNode = slowNode?.next</span><br><span class="line">            fastNode = fastNode?.next</span><br><span class="line">        &#125;</span><br><span class="line">        //删除需要删除的节点</span><br><span class="line">        slowNode?.next = slowNode?.next?.next</span><br><span class="line">        return dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dummy节点和尾巴插法</title>
      <link href="/2018/07/31/%E7%AE%97%E6%B3%95/dummy%E8%8A%82%E7%82%B9%E5%92%8C%E5%B0%BE%E5%B7%B4%E6%8F%92%E6%B3%95/"/>
      <url>/2018/07/31/%E7%AE%97%E6%B3%95/dummy%E8%8A%82%E7%82%B9%E5%92%8C%E5%B0%BE%E5%B7%B4%E6%8F%92%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>给出一个链表和一个数X，要求将链表中所有小于X的值放到左边，等于或者大于X的值放到右边，并且原链表的节点顺序不变。</p><p>示例：<br>假设： 1-&gt;7-&gt;3-&gt;5-&gt;2-&gt;8-&gt;4，给定x=4<br>那么变换后的节点为： 1-&gt;3-&gt;2-&gt;7-&gt;5-&gt;8-&gt;4</p><a id="more"></a><blockquote><p>思路：<br>我们先把题目简单化，我们可以先找出链表中小于X的节点放到一个新的链表里面<br>然后再找出等于或者大于X的节点放到另外一个条链表<br>最后将第一条链表的next指向第二条链表的头结点，这样就完成了题目的要求。</p></blockquote><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">      public var val: Int</span><br><span class="line">      public var next: ListNode?</span><br><span class="line">      public init(_ val: Int) &#123;</span><br><span class="line">          self.val = val</span><br><span class="line">          self.next = nil</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class NewSoluction &#123;</span><br><span class="line">    func getNewList(_ l1:ListNode?,x:Int)-&gt;ListNode?&#123;</span><br><span class="line">        let headDummy = ListNode(0), tailDummy = ListNode(0)</span><br><span class="line">        var head = headDummy,tail = tailDummy</span><br><span class="line">        var node = l1</span><br><span class="line">        while node != nil &#123;</span><br><span class="line">            if node!.val &lt; x &#123;</span><br><span class="line">                head.next = node!</span><br><span class="line">                head = node!</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                tail.next = node!</span><br><span class="line">                tail = node!;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node!.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = nil;</span><br><span class="line">        //头链加上尾链</span><br><span class="line">        head.next = tailDummy.next</span><br><span class="line">        return headDummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：tail.next = nil 是为了防止形成环，因为<code>tail.next = node ! ,tail = node</code>这一句实际上是形成了环，所以需要将tail.next置空来打破环</strong></p>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 组件化实践《二》基于现有项目拆分组件化实践</title>
      <link href="/2018/07/31/iOS%20%E5%BC%80%E5%8F%91/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%BA%8C%E3%80%8B-%E5%9F%BA%E4%BA%8E%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/07/31/iOS%20%E5%BC%80%E5%8F%91/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%BA%8C%E3%80%8B-%E5%9F%BA%E4%BA%8E%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><blockquote><p>在<a href="http://lemon2well.top/2018/07/30/iOS%20开发/组件化实践《一》创建私有pod/">第一篇</a>介绍中已经介绍了如果发布一个私有pod，下面将会介绍如何基于一个现有的项目拆分成组件化形式的项目。<br>假设我们现有的项目是有一个AViewController,还有一个BViewController，目前的功能是点击rootViewController页面的按钮会push到AviewController，然后点击AviewController的一个按钮会跳转到BViewController。这里是未拆分的<a href="https://github.com/codemonkeybulucck/TestModule" target="_blank" rel="noopener">demo</a></p></blockquote><a id="more"></a><h2 id="0x02-拆分组件"><a href="#0x02-拆分组件" class="headerlink" title="0x02 拆分组件"></a>0x02 拆分组件</h2><blockquote><p>现在我们要拆分AViewController和BViewController,将他们拆分成两个组件，并且按照Target-Action的形式提供对外的接口，通过中间件去调用Target对应的Action，在最上层是中间件的分类，给调用方提供具体且便利的方法和接口。</p></blockquote><h3 id="0x02-1-分析如何拆分AViewController"><a href="#0x02-1-分析如何拆分AViewController" class="headerlink" title="0x02.1 分析如何拆分AViewController"></a>0x02.1 分析如何拆分AViewController</h3><ol><li><p>首先AViewController，现在AViewController需要外部传一个NSString类型的参数进去，然后返回一个AViewController的对象。这个时候应该创建一个Target_AViewController的类，然后对外一个<code>Action_fectchAViewController:</code>的方法，这个方法需要接收一个字典类型的参数，到时我们会从这个字典中取出key为navTitle的值来作为AViewController的参数。以下是该方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   - (UIViewController*)Action_fetchAViewController:(NSDictionary*)params&#123;</span><br><span class="line">    AViewController *aViewControlelr = [[AViewController alloc]init];</span><br><span class="line">    NSString *title = params[@&quot;navTitle&quot;];</span><br><span class="line">    aViewControlelr.navTitle = title;</span><br><span class="line">    return aViewControlelr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>然后我们要创建CTMediator的分类<code>CTMediator+ModuleAActions</code>，这个分类方法对外提供了一个<code>fetchAViewController</code>的方法，到时调用方调用此方法即可获取到一个AViewController的实例，而不用自己去初始化AViewController。</p></li><li><p>那么上面那个分类具体做了什么操作呢，该方法会传一个“AViewController”和“fetchAViewController”来表明需要调用Target_AViewController的Action_fetchAViewller方法，也就是我们刚刚提供的Target_Action。本来调用方是不用通过类别来调用组件Target_Action的，因为可以通过CTMediator的<code>perform Target: action: params:</code>来直接调用。但是那样非常不友好以及不统一。<br>加上了该分类之后，可以做更多的容错处理以及有一个容易的入口。</p></li><li><p>所以在后面做成pod的时候，category是一个pod，它只依赖于CTMediator，调用方法是通过CTMediator通过runtime来找到Target_Action来调用。所以另外一个pod就是AViewController+Target_AViewController。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   - (UIViewController*)fetchAViewController&#123;</span><br><span class="line">    UIViewController *vc = [self performTarget:@&quot;AViewController&quot; action:@&quot;fetchAViewController&quot; params:@&#123;@&quot;navTitle&quot;:@&quot;This is A ViewController&quot;&#125; shouldCacheTarget:NO];</span><br><span class="line">    if ([vc isKindOfClass:[UIViewController class]]) &#123;</span><br><span class="line">        return vc;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [[UIViewController alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>以上提到的pod：</strong><br><a href="https://github.com/codemonkeybulucck/AViewControllerCategory" target="_blank" rel="noopener">CategoryAViewController</a><br><a href="https://github.com/codemonkeybulucck/LMAViewController" target="_blank" rel="noopener">AviewControllerPod</a><br><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="noopener">CTMediactor</a></p><h3 id="0x02-2-创建BViewController的category和Target-Action的pod"><a href="#0x02-2-创建BViewController的category和Target-Action的pod" class="headerlink" title="0x02.2 创建BViewController的category和Target_Action的pod"></a>0x02.2 创建BViewController的category和Target_Action的pod</h3><p>1、为什么需要先创建BViewController组件，因为AViewController会依赖于BViewController，所以我们先创建BViewController组件。</p><p>2、首先我们先创建BViewController私有pod，按照我的<a href="http://lemon2well.top/2018/07/30/iOS%20开发/组件化实践《一》创建私有pod/">组件化实践《一》</a>创建好<a href="https://github.com/codemonkeybulucck/BViewController" target="_blank" rel="noopener">BViewController</a>的pod，这个pod不用依赖于任何其他组件，所以应该没啥困难。</p><p>3、接下来我们需要创建<a href="https://github.com/codemonkeybulucck/BCategory" target="_blank" rel="noopener">BViewControllerCategory</a>，这里有一点要注意的是在podspec文件的最下面需要加入<code>s.dependency &#39;CTMediator&#39;</code>，因为里面需要用到CTMediator的perform方法去调用到对应的组件。因为CTMediator已经发布到cocoapods所以可以直接用，如果这里的依赖是你自己改动之后的私有Mediator，记得在pod spec lint 的时候要加上<code>--sources=yourgithub/spec,master</code>将源改成你自己的私有索引库的地址，不然默认是从公有索引库里面找不到对应的Mediator。待会在AViewController调用B的时候会用到这个命令。</p><h3 id="0x02-3-创建AViewController的category和Target-Action的pod"><a href="#0x02-3-创建AViewController的category和Target-Action的pod" class="headerlink" title="0x02.3 创建AViewController的category和Target_Action的pod"></a>0x02.3 创建AViewController的category和Target_Action的pod</h3><p>1、方法同上，首先创建AViewController的<a href="https://github.com/codemonkeybulucck/AViewControllerCategory" target="_blank" rel="noopener">Category</a>组件，这里只需要注意在podspec文件的最下面需要加入<code>s.dependency &#39;CTMediator&#39;</code>。<br>2、 然后我们创建<a href="https://github.com/codemonkeybulucck/LMAViewController" target="_blank" rel="noopener">AViewController</a>私有pod，由于在AViewController里面我们有个按钮点击之后会push到BViewController，那必然要引入BViewController，但是在组件中不会直接引入BViewController，我们通过引入BViewControllerCategory来让程序编译的时候不要报错就行。podspec文件要加入<code>s.dependency &#39;BCategory&#39;</code>。</p><p>3、 验证，因为第二部中我们的私有工程依赖了另外一个私有工程，这个时候的<code>pod spec lint</code>和 <code>pod repo push</code>命令都要加上 <code>--source</code>说明</p><p><strong>注意：组件间的调用依然是利用Target对应的分类来调用。记住分类是统一的入口，组件里面的代码不会依赖于另外一个组件，而是依赖于对应的分类组件或者CTMediator，然后所有依赖的pod都要写到主工程的podfile里面</strong></p><h2 id="0x03-引用组件"><a href="#0x03-引用组件" class="headerlink" title="0x03 引用组件"></a>0x03 引用组件</h2><p>我们将AViewController和BViewController拆分后，我们创建一个demo来测试一下刚刚拆分的组件。创建一个OC项目，在项目的跟目录下执行<code>pod init</code>，然后在podfile文件里面写入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/codemonkeybulucck/LMSpec&apos;</span><br><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"></span><br><span class="line">target &apos;moduleTest&apos; do</span><br><span class="line">  # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line">  pod &apos;ACategory&apos;</span><br><span class="line">  pod &apos;AViewController&apos;,&apos;~&gt;0.1.1&apos;</span><br><span class="line">  pod &apos;BViewController&apos;</span><br><span class="line">  # Pods for moduleTest</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>完成后执行 <code>pod install</code>，成功之后再<code>#import &quot;CTMediator+ModuleAActions.h&quot;</code> 然后调用方式就变成了<br><code>UIViewController *vc = [[CTMediator sharedInstance] fetchAViewController];</code></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>组件化最核心的思想就是解耦，将庞大的项目抽丝剥茧，分离成互相独立的一个一个模块，每个模块都是可复用的。上述的方案其实已经做到了解耦，调用者只需要用到中间件的分类的方法接口而不需要引入实际的组件的类。<br>但是在分类里面有一个弊端就是：动态调用方法的时候需要硬编码也就是，这样容错率就很低，不过幸好这个东西是在分类中，在开发的过程中就可以发现的问题。<br>另外一个方面也不是所有的项目都适合用组件化，只有当项目规模扩大到一定的程度，并且人员众多的情况下用组件化的便捷性才体现出来。所以很多时候我们讨论架构或者讨论一种新的技术，并不是它就是最好的，没有什么东西是最好的，只有最合适的，因地制宜。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocoapods </tag>
            
            <tag> 组件化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2018/07/31/%E7%AE%97%E6%B3%95/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2018/07/31/%E7%AE%97%E6%B3%95/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><p>示例：</p><p>给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。</p><p>给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。</p><p>给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列  而不是子串。</p><a id="more"></a><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">leetcode链接</a></p><blockquote><p>解答思路：</p><ol><li>首先从头开始遍历字符串，并且将已经遍历过的字符串放到一个数组里面</li><li>但是放到数组里面的前提是当前遍历的字符并不存在在数组当中，也就是如果当前遍历的字符不在数组中，那么就将字符放到数组中，开始下一次遍历</li><li>如果当前当前的字符在数组中，那么找到该字符在数组中的下标，删除数组中从下标为0到该字符下标区间的元素，然后将当前字符放到数组里面开始下一次遍历。</li><li>每遍历一次，都要判断上一次的最长字符串maxCount是否小于当前数组的元素的数量，如果是，那么就更新maxCount。</li></ol></blockquote><p>下面是代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func _maxLongString(s:String!)-&gt;Int&#123;</span><br><span class="line">        if s.count == 0 &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">        var subArr = [CChar]()</span><br><span class="line">        var maxCount = 0;</span><br><span class="line">        var array = s.cString(using:.utf8)!</span><br><span class="line">        array.removeLast() //由于字符串会有一个结束符，所以需要删掉最后的结束符</span><br><span class="line">        for str in array&#123;</span><br><span class="line">            if subArr.contains(str) &#123;</span><br><span class="line">                let index:Int = subArr.index(of: str)!</span><br><span class="line">                let empty = 0..&lt;index+1</span><br><span class="line">                subArr.removeSubrange(empty)</span><br><span class="line">            &#125;</span><br><span class="line">            subArr.append(str)</span><br><span class="line">            maxCount = max(maxCount, subArr.count)</span><br><span class="line">        &#125;</span><br><span class="line">        return maxCount</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>非空链表相加</title>
      <link href="/2018/07/30/%E7%AE%97%E6%B3%95/%E9%9D%9E%E7%A9%BA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/"/>
      <url>/2018/07/30/%E7%AE%97%E6%B3%95/%E9%9D%9E%E7%A9%BA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/</url>
      <content type="html"><![CDATA[<p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p><blockquote><p>思路：</p><ol><li>只要两个非空链表中的其中一个链表不为空的时候就循环便利两个链表</li><li>如果其中一个链表为空而另外一个链表不为空，那么为空的那个链表的值就为0</li><li>用一个carry位来表示是否有进位，0代表无进位，1代表有进位，因为链表中都是个位数，所以最大进位也只能为1，初始化进位为0</li><li>用x,y来表示当前两个链表的值，sum = x+y+carry为新链表的值，但是有可能有进位，所以新的carry = sum / 10,当前节点位的值为sum = sum %10。<a id="more"></a></li><li>创建一个新节点，将上述中sum的值赋给新节点，然后将新链表当前节点的next指向新节点，然后将当前节点指向到新节点</li><li>两个链表的当前节点都要指向下一个节点</li><li>当遍历完成之后，还需要判断一下carry的值是不是大于0，如果大于0则代表还需要创建一个节点，并且将新链表的节点的next指向该节点</li></ol></blockquote><p>以下是代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">      public var val: Int</span><br><span class="line">      public var next: ListNode?</span><br><span class="line">      public init(_ val: Int) &#123;</span><br><span class="line">          self.val = val</span><br><span class="line">          self.next = nil</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;</span><br><span class="line">        let resultNode = ListNode(0)</span><br><span class="line">        var currentNode = resultNode</span><br><span class="line">        var p = l1</span><br><span class="line">        var q = l2</span><br><span class="line">        var carry = 0 //表示进位</span><br><span class="line">        while p != nil || q != nil &#123;</span><br><span class="line">            //获取当前的值</span><br><span class="line">            var x = 0,y = 0;</span><br><span class="line">            if let p = p &#123;</span><br><span class="line">                x = p.val</span><br><span class="line">            &#125;</span><br><span class="line">            if let q = q &#123;</span><br><span class="line">                y = q.val</span><br><span class="line">            &#125;</span><br><span class="line">            let sum = x + y + carry</span><br><span class="line">            carry = sum / 10</span><br><span class="line">            let newSum = sum % 10;</span><br><span class="line">            currentNode.next = ListNode(newSum)</span><br><span class="line">            currentNode = currentNode.next!</span><br><span class="line">            p = p?.next</span><br><span class="line">            q = q?.next</span><br><span class="line">        &#125;</span><br><span class="line">        if carry &gt; 0 &#123;</span><br><span class="line">            currentNode.next = ListNode(carry)</span><br><span class="line">        &#125;</span><br><span class="line">        return resultNode.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 组件化实践《一》创建私有pod</title>
      <link href="/2018/07/30/iOS%20%E5%BC%80%E5%8F%91/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%B8%80%E3%80%8B%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89pod/"/>
      <url>/2018/07/30/iOS%20%E5%BC%80%E5%8F%91/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%B8%80%E3%80%8B%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89pod/</url>
      <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>本次组件化实践的方式来自于<a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">casaty组件化方案</a>，该方案是基于target-action模式和Mediator模式，通过Mediator利用runtime的机制来调用对应的target-action。并且在上层通过category的方式暴露对外调用的接口，这样调用者在调用的时候就知道需要传递哪些参数。</p><a id="more"></a><p>具体的调用方式就是：<br><img src="http://pcd17v2u0.bkt.clouddn.com/WX20180730-160336@2x.png" alt="WX20180730-160336@2x"></p><blockquote><p>实际上是可以不使用category的形式而是直接调用CTMediactor的<code>- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget</code> 方法直接调用对应target的action，但是那样对于调用方来说极其不友好，最直观的感受就是不知道params应该传哪些参数。</p></blockquote><blockquote><p>利用catogory的方式暴露方法的好处在于<br>1、一个组件对应一个category，每个category提供了组件所有的调用方法，调用方直接调用，可以直观的看到需要传递哪些参数。<br>2、提供统一的调用入口，所有的组件的被调用都是通过category<br>3、可以做异常处理，将参数的校验提前，并且可以做请求转发。</p></blockquote><h2 id="0x02-组件化实践"><a href="#0x02-组件化实践" class="headerlink" title="0x02 组件化实践"></a>0x02 组件化实践</h2><p>在简单的介绍了组件化的实际逻辑之后下面开始真正的开始动手实现组件化实践流程。</p><blockquote><p>一个私有pod的创建具体分为以下几步：</p></blockquote><ol><li>创建工程</li><li>创建私有库，修改podSpec文件，将本地代码库和远程代码库关联起来，上传代码到远程仓库。</li><li>创建远程索引库和本地索引库，也就是用于放置podspec的地方，每个podspec文件可以索引到我们远程不同的代码私有库</li><li>本地测试podspec文件是否可用</li><li>向索引库Spec Repo中提交podspec</li><li>测试Spec Repo中的的 podspec 是否可用</li></ol><p>1、 首先到github里面创建一个空的工程，例如我要创建一个FirstViewController<br><img src="http://pcd17v2u0.bkt.clouddn.com/15329320727207.jpg" alt=""></p><hr><p>2、 创建私有库，终端运行<code>pod lib create FirstViewController</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:Module lemon$ pod lib create FirstViewController</span><br><span class="line">Cloning `https://github.com/CocoaPods/pod-template.git` into `FirstViewController`.</span><br><span class="line">Configuring FirstViewController template.</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">To get you started we need to ask a few questions, this should only take a minute.</span><br><span class="line"></span><br><span class="line">If this is your first time we recommend running through with the guide:</span><br><span class="line"> - https://guides.cocoapods.org/making/using-pod-lib-create.html</span><br><span class="line"> ( hold cmd and click links to open in a browser. )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line"> &gt; iOS //pod平台</span><br><span class="line"></span><br><span class="line">What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line"> &gt; ObjC //pod语言</span><br><span class="line"></span><br><span class="line">Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class="line"> &gt; No //是否需要提供demo</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line"> &gt; None //测试框架</span><br><span class="line"></span><br><span class="line">Would you like to do view based testing? [ Yes / No ]</span><br><span class="line"> &gt; No //是否需要测试视图</span><br><span class="line"></span><br><span class="line">What is your class prefix?</span><br><span class="line"> &gt; LM //demo类前缀</span><br><span class="line"></span><br><span class="line">Running pod install on your new library.</span><br><span class="line"></span><br><span class="line">Analyzing dependencies</span><br><span class="line">Fetching podspec for `FirstViewController` from `../`</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing FirstViewController (0.1.0)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br></pre></td></tr></table></figure><p>上述命令执行完成之后会本地帮我们生成一个pod的模板文件，我们在这里首先需要改动的就是FirstViewController.podspec文件，用xcode打开该文件。<br>目前我们需要注意下面几处地方：</p><ul><li><code>s.version          = &#39;1.0.0&#39;</code>    //pod的版本，后面将podSpec文件提交到私有repo的时候会验证远程的仓库中是否已经存在对应的tag，所以这个要与后面提交代码的时候的tag相同,我们先修改为1.0.0，可以按照你们自己的标准修改。</li><li><code>s.homepage         = &#39;https://github.com/codemonkeybulucck/FirstViewController&#39;</code>  //homepage这里填写在第一步中再github创建的远程仓库的地址即可。</li><li><p><code>s.source           = { :git =&gt; &#39;https://github.com/codemonkeybulucck/FirstViewController.git&#39;, :tag =&gt; s.version.to_s }</code>  //这里填写远程仓库的地址，记得后面要加上.git的后缀</p></li><li><p><code>s.ios.deployment_target = &#39;8.0&#39;</code> //该pod的最低运行环境</p></li><li><p><code>s.source_files = &#39;FirstViewController/Classes/**/*&#39;</code> //pod中源代码的路径，后面会将实际的代码放在Classes文件夹下面</p></li></ul><p>一些其他设置的说明：</p><p>  s.summary          = ‘A short description of FirstViewController.’  //pod的简述<br>  s.description      = &lt;&lt;-DESC //具体描述<br> s.license          = { :type =&gt; ‘MIT’, :file =&gt; ‘LICENSE’ } //许可证<br>  s.author           = { <a href="mailto:&#39;545390087@qq.com" target="_blank" rel="noopener">&#39;545390087@qq.com</a>‘ =&gt; <a href="mailto:&#39;codebulucck@163.com" target="_blank" rel="noopener">&#39;codebulucck@163.com</a>‘ } //作者信息<br> s.dependency ‘AFNetworking’, ‘~&gt; 2.3’ //依赖库，如果该pod依赖其他pod，可以在此处加上。</p><p>完成podspec文件修改之后我们可以将对应的组件代码放到Classes文件夹路径下面。下面将本地代码库和远程代码库关联起来，然后将本地代码推送到远程仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git remote add origin https://github.com/codemonkeybulucck/FirstViewController.git</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git add .</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git commit -m &quot;初始化&quot;</span><br><span class="line">[master 8ac032c] 初始化</span><br><span class="line"> 25 files changed, 1209 insertions(+)</span><br><span class="line"> create mode 100644 Example/FirstViewController.xcworkspace/contents.xcworkspacedata</span><br><span class="line"> create mode 100644 Example/FirstViewController.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist</span><br><span class="line"> create mode 100644 Example/Podfile.lock</span><br><span class="line"> create mode 100644 Example/Pods/Local Podspecs/FirstViewController.podspec.json</span><br><span class="line"> create mode 100644 Example/Pods/Manifest.lock</span><br><span class="line"> create mode 100644 Example/Pods/Pods.xcodeproj/project.pbxproj</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-dummy.m</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-prefix.pch</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-umbrella.h</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController.modulemap</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController.xcconfig</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/Info.plist</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Info.plist</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-acknowledgements.markdown</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-acknowledgements.plist</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-dummy.m</span><br><span class="line"> create mode 100755 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-frameworks.sh</span><br><span class="line"> create mode 100755 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-resources.sh</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-umbrella.h</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.debug.xcconfig</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.modulemap</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.release.xcconfig</span><br><span class="line"> create mode 100644 FirstViewController/Classes/FirstViewController.h</span><br><span class="line"> create mode 100644 FirstViewController/Classes/FirstViewController.m</span><br><span class="line"> delete mode 100644 FirstViewController/Classes/ReplaceMe.m</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git push origin master</span><br><span class="line">Counting objects: 62, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (55/55), done.</span><br><span class="line">Writing objects: 100% (62/62), 23.04 KiB | 2.56 MiB/s, done.</span><br><span class="line">Total 62 (delta 10), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (10/10), done.</span><br><span class="line">To https://github.com/codemonkeybulucck/FirstViewController.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure><hr><p>3、 创建远程索引库和本地索引库，同样在github创建一个新的仓库，仓库的名字叫做LMSpec，这个仓库是pod的索引库，也就是后面如果要引用组件pod的话只要引入这个LMSpec就能从里面找到对应的组件。<br>    创建完远程仓库之后我们创建一个本地索引库，并且将本地索引库和远程仓库连接起来。<br>    <code>pod repo add LMSpec https://github.com/codemonkeybulucck/LMSpec.git</code> 执行完这条命令之后，去到 <code>~/.cocoapods/repo</code>路径下就能看到有一个master和LMSpec，master是公有cocoapod的索引库，LMSpec就是我们自己新建的索引库。到此我们已经创建好代码库以及索引库了。</p><hr><p>4、本地测试podspec文件是否可用 本地测试podspec文件是否可用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ pod lib lint</span><br><span class="line"></span><br><span class="line"> -&gt; FirstViewController (1.0.0)</span><br><span class="line">    - WARN  | summary: The summary is not meaningful.</span><br><span class="line"></span><br><span class="line">[!] FirstViewController did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it).</span><br><span class="line">You can use the `--no-clean` option to inspect any issue.</span><br></pre></td></tr></table></figure><p>上述验证表明我们本地验证已经没有错误了，但是有一个警告，我们可以使用<br><code>pod lib lint --allow-warnings</code>来忽略警告。如果我们使用<code>pod spec lint</code>来验证的话，记得要先本地代码库打tag然后将tag推动到远程仓库才能通过验证，因为该命令是同时验证本地和远程仓库，因为我们还没有打tag推送到远程仓库，所以我们先用<code>pod lib lint</code>来验证。</p><hr><p>5、 向索引库Spec Repo中提交podspec<br>  在第四步中我们已经验证我们的podspec文件没有问题了，但是我们现在还不能推送到索引库，因为我们还没有打tag，这个tag应该是与podspec文件里面的version一致，不一致的话远程验证的时候是通不过验证的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git tag -a 1.0.0 -m &quot;第一个版本pod&quot;</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git push origin master 1.0.0</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 183 bytes | 183.00 KiB/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/codemonkeybulucck/FirstViewController.git</span><br><span class="line"> * [new tag]         1.0.0 -&gt; 1.0.0</span><br></pre></td></tr></table></figure><p>完成上述步骤后我们需要将podspec提交到索引库中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ pod repo push LMSpec FirstViewController.podspec --allow-warnings</span><br><span class="line"></span><br><span class="line">Validating spec</span><br><span class="line"> -&gt; FirstViewController (1.0.0)</span><br><span class="line">    - WARN  | summary: The summary is not meaningful.</span><br><span class="line"></span><br><span class="line">Updating the `LMSpec&apos; repo</span><br><span class="line"></span><br><span class="line">Already up to date.</span><br><span class="line"></span><br><span class="line">Adding the spec to the `LMSpec&apos; repo</span><br><span class="line"></span><br><span class="line"> - [Add] FirstViewController (1.0.0)</span><br><span class="line"></span><br><span class="line">Pushing the `LMSpec&apos; repo</span><br></pre></td></tr></table></figure><p>至此为止我们已经将podspec文件推送到本地LMSpec和远程LMSpec里面了，可以到 <code>~/.cocoapods/repo/LMSpec</code>文件夹下看有没有对应FirstViewControll文件夹。该文件夹下会有一个1.0.0的文件夹，也就是我们刚刚打的tag的数值。后续如果修改代码需要重新打tag,然后到时这里也会出现新的版本的代码。<br><strong>注</strong> 如果该私有库里面引用了其他的私有库，也就是podspec文件中s.dependency引用了其他私有库的信息，需要指定私有库的位置，那么推送命令将变为</p><p><code>pod repo push LMSpec FirstViewController.podspec --allow-warnings --sources=https://github.com/codemonkeybulucck/LMSpec,master</code> </p><hr><p>6、 测试Spec Repo中的的 podspec 是否可用<br>创建一个ModuleTest的工程，进入到工程里面先执行 <code>pod init</code> ，然后编辑podfile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/codemonkeybulucck/LMSpec&apos;</span><br><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"></span><br><span class="line">target &apos;moduleTest&apos; do</span><br><span class="line">  # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line">  pod &apos;FirstViewController&apos;</span><br><span class="line">  # Pods for moduleTest</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>执行<code>pod install</code>如果没出错就代表私有库已经添加成功。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocoapods </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>两数之和</title>
      <link href="/2018/07/29/%E7%AE%97%E6%B3%95/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2018/07/29/%E7%AE%97%E6%B3%95/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>给定一个数组和一个目标数，判断数组中是否有两个数的和等于该目标数，如果存在则输出它们在数组中的序号。</p><blockquote><p>解法1：第一眼看到上述题目我们第一时间的反应应该是通过两个循环遍历来找出它们的序号。第一个循环找出一个数X，然后用目标数减去该数值X得到第二个数Y，然后第二次循环找出有没有与Y相等的数值。这样时间的复杂度是O(n²)。</p></blockquote><a id="more"></a><blockquote><p>解法2：我们可以通过使用字典的的方式，数值作为字典的key，数组下标作为字典的value。我们可以在第一次便利的时候，用目标数减去循环得到的数X，然后得到目标数Y，然后判断字典中有没有以Y作为key的value。<br>如果有的话，那么此次循环的i就是第一个数值的下标，以Y作为key那个value就是第二个数值的下标。<br>如果不存在则将该次循环的下标和数值保存到字典里面。继续下一次遍历。<br>以下是Swift代码示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func _sum(_ array:[Int],targetNum:Int)-&gt;[Int]&#123;</span><br><span class="line">       var dict = [Int:Int]()</span><br><span class="line">       for(i,num) in array.enumerated()&#123;</span><br><span class="line">           let secondNum = targetNum - num</span><br><span class="line">           if let secondIndex = dict[secondNum]&#123;</span><br><span class="line">               return [i,secondIndex]</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               dict[num] = i</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return [0,0]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>字符串反转算法</title>
      <link href="/2018/07/29/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E7%AE%97%E6%B3%95/"/>
      <url>/2018/07/29/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h1><p>给定一个字符串，要求按照其按照单词的顺序进行反转<br>即： oc is the best language<br>反转后的字符串应该为： language is the bast oc</p><blockquote><p>思路：我们首先可以对给定的字符串进行普通的反转，然后将反转后的字符串进行切割成单词只有再反转会正常的单词。swift实现如下：</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func _reverseWold(_ s: String?)-&gt;String?&#123;</span><br><span class="line">        //首先先对整体字符串反转</span><br><span class="line">        guard let s = s else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        let rs = String(s.reversed())</span><br><span class="line">        //对反转后的字符串在切割成单词反转</span><br><span class="line">        var result = String()</span><br><span class="line">        let array = rs.split(separator: &quot; &quot;)</span><br><span class="line">        for (i,word) in array.enumerated()&#123;</span><br><span class="line">            let rw = String(word.reversed())</span><br><span class="line">            if i != array.count-1&#123;</span><br><span class="line">                result.append(rw+&quot; &quot;)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result.append(rw)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串反转 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS防止被逆向调试</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%98%B2%E6%AD%A2%E8%A2%AB%E9%80%86%E5%90%91%E8%B0%83%E8%AF%95/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%98%B2%E6%AD%A2%E8%A2%AB%E9%80%86%E5%90%91%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><blockquote><p>反调试主要分为两种，第一种阻止调试器附加，第二种是检测是否有调试器存在</p></blockquote><a id="more"></a><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>第一种方法：</p><h3 id="0x01-ptrace"><a href="#0x01-ptrace" class="headerlink" title="0x01 ptrace"></a>0x01 ptrace</h3><blockquote><p>ptrace是系统用来对运行中的进程进行调试和跟踪的工具，通过ptrace，可以对另一个进程实现调试跟踪。但是里面提供了一个非常有用的参数，就是PT_DENY_ATTACH，const值是31，这个参数用户告诉系统阻止调试器附加。<br>在main.m里面加入以下代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line">#import &lt;dlfcn.h&gt;</span><br><span class="line">#import &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int  (*ptrace_ptr_t)(int _request,pid_t pid,caddr_t _addr,int _data);</span><br><span class="line">#ifndef PT_DENY_ATTACH</span><br><span class="line">#define PT_DENY_ATTACH 31</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">       // ptrace(PT_DENY_ATTACH,0,0,0); //系统函数并没有暴露出此方法所以不能直接通过此方式调用</span><br><span class="line">        void *handle = dlopen(0, RTLD_NOW|RTLD_GLOBAL);</span><br><span class="line">        ptrace_ptr_t ptrace_ptr = (ptrace_ptr_t)dlsym(handle, &quot;ptrace&quot;);</span><br><span class="line">        ptrace_ptr(PT_DENY_ATTACH,0,0,0);</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的代码中，本来是直接调用上面被注释的那一行代码就可以了，不过由于不是公开的函数所以没法直接调用。所以我们通过dlopen的方式，当path 参数为0是,他会自动查找 $LD_LIBRARY_PATH,$DYLD_LIBRARY_PATH, $DYLD_FALLBACK_LIBRARY_PATH 和 当前工作目录中的动态链接库，通过句柄找到对应的ptarce对应的地址，然后传入PT_DENY_ATTACH。</p></blockquote><h3 id="0x02-syscall"><a href="#0x02-syscall" class="headerlink" title="0x02 syscall"></a>0x02 syscall</h3><blockquote><p>另外一种方式可以使用syscall的方式来调用ptrace，syscall是系统提供的一个系统调用函数，因为上面的调用方式会容易被反反调试，通过NSFindSymbol找到_ptrace然后hook对应的函数，所以可以最好是通过syscall来反调试<br>在Kernel Syscalls里面找到<a href="https://www.theiphonewiki.com/wiki/Kernel_Syscalls" target="_blank" rel="noopener">ptrace</a>对应的const。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ joker -u ~/Documents/projects/iOS.6.0.iPod4.kernel </span><br><span class="line">This is an ARM binary. Applying iOS kernel signatures</span><br><span class="line">Entry point is 0x80085084....This appears to be XNU 2107.2.33</span><br><span class="line">Syscall names are @2a70f0</span><br><span class="line">Sysent offset in file/memory (for patching purposes): 0x2ef0c0/0x802f00c0</span><br><span class="line"></span><br><span class="line">Suppressing enosys (0x800b3429)  T = Thumb</span><br><span class="line">1. exit                  801d4a74 T</span><br><span class="line">2. fork                  801d7980 T</span><br><span class="line">3. read                  801eb584 T</span><br><span class="line">4. write                 801eb958 T</span><br><span class="line">5. open                  800b13a4 T</span><br><span class="line">6. close                 801ccab4 T</span><br><span class="line">7. wait4                 801d56bc T</span><br><span class="line">9. link                  800b18e8 T</span><br><span class="line">10. unlink               800b1ff0 T</span><br><span class="line">12. chdir                800b0c60 T</span><br><span class="line">13. fchdir               800b0af0 T</span><br><span class="line">14. mknod                800b14bc T</span><br><span class="line">15. chmod                800b2b40 T</span><br><span class="line">16. chown                800b2c9c T</span><br><span class="line">18. getfsstat            800b088c T</span><br><span class="line">20. getpid               801dc20c T</span><br><span class="line">23. setuid               801dc4c0 T</span><br><span class="line">24. getuid               801dc290 T</span><br><span class="line">25. geteuid              801dc2a0 T</span><br><span class="line">26. ptrace               801e812c T</span><br><span class="line">27. recvmsg              8020a8fc T</span><br><span class="line">28. sendmsg              8020a444 T</span><br><span class="line">29. recvfrom             8020a528 T</span><br><span class="line">30. accept               80209dfc T</span><br><span class="line">31. getpeername          8020abc8 T</span><br><span class="line">32. getsockname          8020ab18 T</span><br><span class="line">33. access               800b24ac T</span><br><span class="line">34. chflags              800b2928 T</span><br><span class="line">35. fchflags             800b29f0 T</span><br><span class="line">36. sync                 800b0320 T</span><br><span class="line">37. kill                 801dfdcc T</span><br><span class="line">39. getppid              801dc214 T</span><br><span class="line">41. dup                  801cab04 T</span><br><span class="line">42. pipe                 801edbe4 T</span><br><span class="line">43. getegid              801dc318 T</span><br><span class="line">46. sigaction            801deee8 T</span><br><span class="line">47. getgid               801dc308 T</span><br><span class="line">48. sigprocmask          801df42c T</span><br><span class="line">49. getlogin             801dd0e8 T</span><br><span class="line">50. setlogin             801dd160 T</span><br><span class="line">51. acct                 801c54ec T</span><br><span class="line">52. sigpending           801df5d0 T</span><br></pre></td></tr></table></figure><blockquote><p>注意一下代码中的26就是ptrace的const。<br>综上所述：调用syscall(26,31,0,0,0)就可以达到反调试的目的。</p></blockquote><h3 id="0x03-sysctl"><a href="#0x03-sysctl" class="headerlink" title="0x03 sysctl"></a>0x03 sysctl</h3><blockquote><p>可以通过sysctl查看内核进程状态标志位，如果一个进程在调试状态，会有一个标志位（info.kp_proc.p_flag）来标识当前是否正在调试。<br>代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BOOL existDebugger()&#123;</span><br><span class="line">    int name[4];//指定查询信息的数组</span><br><span class="line">    struct kinfo_proc info;//查询的返回结果</span><br><span class="line">    size_t info_size = sizeof(info);</span><br><span class="line">    info.kp_proc.p_flag = 0;</span><br><span class="line">    </span><br><span class="line">    name[0] = CTL_KERN;</span><br><span class="line">    name[1] = KERN_PROC;</span><br><span class="line">    name[2] = KERN_PROC_PID;</span><br><span class="line">    name[3] = getpid();</span><br><span class="line">    if (sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0) == -1) &#123;</span><br><span class="line">        NSLog(@&quot;sysctl error ...&quot;);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以定时执行以上代码，当检测到程序正在被调试，可以调用exit(0)来让程序奔溃或者做其他的操作</p></blockquote><h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><blockquote><p>syscall可以通过软中断实现从用户态切换到系统内核态的转换，同时可以通过arm 汇编实现以上功能。通过asm volatile内联汇编，实际上也是调用了ptrace。<br>代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __arm__</span><br><span class="line">        asm volatile(</span><br><span class="line">                     &quot;mov r0,#31\n&quot;</span><br><span class="line">                     &quot;mov r1,#0\n&quot;</span><br><span class="line">                     &quot;mov r2,#0\n&quot;</span><br><span class="line">                     &quot;mov r12,#26\n&quot;</span><br><span class="line">                     &quot;svc #80\n&quot;</span><br><span class="line"></span><br><span class="line">                     );</span><br><span class="line">#endif</span><br><span class="line">#ifdef __arm64__</span><br><span class="line">        asm volatile(</span><br><span class="line">                     &quot;mov x0,#26\n&quot;</span><br><span class="line">                     &quot;mov x1,#31\n&quot;</span><br><span class="line">                     &quot;mov x2,#0\n&quot;</span><br><span class="line">                     &quot;mov x3,#0\n&quot;</span><br><span class="line">                     &quot;mov x16,#0\n&quot;</span><br><span class="line">                     &quot;svc #128\n&quot;</span><br><span class="line">                     );</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反调试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS字符串加密以及静态混淆</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E6%B7%B7%E6%B7%86/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E6%B7%B7%E6%B7%86/</url>
      <content type="html"><![CDATA[<h2 id="0x01-字符串加密"><a href="#0x01-字符串加密" class="headerlink" title="0x01 字符串加密"></a>0x01 字符串加密</h2><blockquote><h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>在开发中我们总是会用到加解密，有些同学可能不注意会直接把对称加密的key直接写到程序中，这样使用Hopper或者IDA静态分析的时候是可以直接看到加密的key，这样容易被别人破解，所以需要采用一些方法对文件里面的key进行加密，使得在静态分析阶段无法直接获取加密的key，增加逆向难度。</p><h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>在这里我们可以使用异或计算方法对某一个key进行加密，异或的原理是如果二进制位相同则为0，不相同则为1，如果a^b = c,那么b^c=a。</p></blockquote><a id="more"></a><blockquote><p>代码参考如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#define XOR_KEY 0xBB</span><br><span class="line"></span><br><span class="line">void xorString(unsigned char *str, unsigned char key)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char *p = str;</span><br><span class="line">    while( ((*p) ^=  key) != &apos;\0&apos;)  p++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testFunction</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char str[] = &#123;(XOR_KEY ^ &apos;e&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;n&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;k&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;e&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;y&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;\0&apos;)&#125;;</span><br><span class="line">    xorString(str, XOR_KEY);</span><br><span class="line">    static unsigned char result[6];</span><br><span class="line">    memcpy(result, str, 6);</span><br><span class="line">    NSLog(@&quot;%s&quot;,result);      //output: enkey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>如果在工程中需要加密的字符串很多，这个时候就要遍历文件进行加密，这个时候如果手动查找的话那工作量就会很大，还好Clang可以帮助我们完成这个事情。iOS中有一个libClang提供了Clang的C接口，用于源代码转换成抽象语法树，并对抽象语法树进行便利和分析。具体的操作思路可以看<a href="https://bbs.pediy.com/thread-217991.htm" target="_blank" rel="noopener">iOS加固浅谈之字符串加密</a></p></blockquote><h2 id="0x02-类和方法加密"><a href="#0x02-类和方法加密" class="headerlink" title="0x02 类和方法加密"></a>0x02 类和方法加密</h2><blockquote><h3 id="0x01-1"><a href="#0x01-1" class="headerlink" title="0x01"></a>0x01</h3><p>如果对程序的安全要求更高一点，可以对程序中所有的类和方法进行混淆，也就是用一些乱序无意义的字符串来对程序的类和方法进行替换。但是这个方法有一个弊端，至于什么弊端会在0x04说明</p><h3 id="0x02-1"><a href="#0x02-1" class="headerlink" title="0x02"></a>0x02</h3><p>第一种混淆方法是宏定义，通过增加一个pch文件，在pch文件中将类名和方法名定义成一些无意义的字符串，然后配置prefix Header的路径为pch的路径，这样在静态分析的时候看到的就是乱序的字符串。以下为PCH的内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ifndef PrefixHeader_pch</span><br><span class="line">#define PrefixHeader_pch</span><br><span class="line">// Classes</span><br><span class="line">#ifndef TestClass</span><br><span class="line">#define TestClass l4prfxSkn</span><br><span class="line">#endif</span><br><span class="line">// Methods</span><br><span class="line">#ifndef testClasssMehtod</span><br><span class="line">#define testClasssMehtod l9b0e29rLKJNqI23</span><br><span class="line">#endif // testClasssMehtod</span><br><span class="line">#ifndef testInstanceMethod</span><br><span class="line">#define testInstanceMethod e0lvc2hezXEA2jIBNw</span><br><span class="line">#endif // testInstanceMethod</span><br><span class="line"></span><br><span class="line">#endif /* PrefixHeader_pch */</span><br></pre></td></tr></table></figure><blockquote><p>下面是testClass.h</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface TestClass : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">- (void)testInstanceMethod;</span><br><span class="line">+ (void)testClasssMehtod;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>静态分析截图<br><img src="https://upload-images.jianshu.io/upload_images/2269918-0567c17a9a579829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><blockquote><p>通过上面我们已经可以看到静态分析之后完全看不出上面是哪个类调用了哪个方法。</p><h3 id="0x03-1"><a href="#0x03-1" class="headerlink" title="0x03"></a>0x03</h3><p>和字符串加密一样，一个项目中肯定有很多类和很多方法，如果我们手动去宏定义的话那这是一个巨大的工作量，不过还好Github已经有现成的项目来帮我们生成宏定义。<a href="https://github.com/Polidea/ios-class-guard" target="_blank" rel="noopener">ios-class-guard</a>这个项目可以把所有使用系统库符号的dump下来并过滤掉，只生成用户需要混淆的符号。然后将生成的符号添加到pch文件里面即可</p><h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>上面无序随机字符串加密的弊端就是在提交到AppStore审核的时候，苹果会认为你的APP可能会存在隐藏的功能然后拒接你的上架。<br>另外一种解决方法就是将上线无序随机字符串换成有意义的单词，使得方法名看起来是有意义的，但是它的意义却不是该方法真正的作用。</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码混淆 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LLDB解密framework</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/LLDB%E8%A7%A3%E5%AF%86framework/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/LLDB%E8%A7%A3%E5%AF%86framework/</url>
      <content type="html"><![CDATA[<blockquote><p>除了使用dumpdecrypted去解密APP和framework的内容以外，也可以使用LLDB直接从内存中dump出解密后的模块。</p></blockquote><a id="more"></a><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>获取framework文件，查看文件对应的偏移<br>以下是要执行的命令以及解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lemons-iPhone5S:~ root# ps aux | grep WeChat  //查看Wechat的沙盒目录</span><br><span class="line">mobile    2636   0.0  2.7  1019472  27476   ??  Ss    9:14AM   0:15.37 /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app/WeChat</span><br><span class="line">root      3316   0.0  0.0   525920    224 s001  R+    4:52PM   0:00.01 grep WeChat</span><br><span class="line">lemons-iPhone5S:~ root# /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app</span><br><span class="line">-sh: /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app: is a directory</span><br><span class="line">lemons-iPhone5S:~ root# cd /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app</span><br><span class="line">找到对应的MMCommon.framework，将MMCommon.framework复制到mac</span><br></pre></td></tr></table></figure><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>在mac查看MMCommon.framework的加密偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd MMCommon.framework</span><br><span class="line">otool -hf MMCommon  //查看MMcommon的文件头部的基础信息</span><br><span class="line">otool -arch arm64 -l MMCommon | grep crypt //获取64位机器加密数据信息</span><br></pre></td></tr></table></figure><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p>使用LLDB附加越狱机器，查看MMcommon进程的偏移<br>image list MMCommon<br>通过如下命令dump出解密后的二进制数据<br>memory read –force –outfile ~/Desktop/outputStream –binary –count 3928342 16384+0x00000000384829894</p><ul><li>3928342 是在上述otool -arch 命令中获取到的cryptsize的值，表明当加密数据的的大小</li><li>16384 是在上述otool -arch命令汇总获取到的cryptoff的值，代表加密的数据在MMCommon中偏移</li><li>0x00000000384829894 是在上述image list MMCommon中的模块基地址</li></ul><p>上述命令执行完成之后会在桌面生成一个outputStream文件</p><h2 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h2><p>修复文件，因为dump出来的文件都没有mach-O文件头，所以需要把dump出来的数据放回原来的framework里面，替换原来加密的数据</p><p>dd seek=2384834 bs=1 conv=notrunc if=/Users/lemon/Desktop/outputSteam of=./MMCommon</p><p>lipo MMCommon -thin arm64 -output MMCommon_arm64</p><ul><li>2384834是上述otool -hf的时候architecture 1中的offset的值加上16384（加密数据偏移的值），两者相加，得到了写入的加密数据在文件中的偏移值。</li><li>替换之后，使用lipo 从FAT文件中提取arm64架构的文件。将MMcommon_arm64拖到MachOView中，修改cryptid为00000000。</li></ul>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dumpdecrypted介绍及其使用</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/dumpdecrypted%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/dumpdecrypted%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><blockquote><p>dumpdecrypted 是一个开源的工具，它会注入可执行文件中，动态的从内存中dump解密后的内容。</p></blockquote><p>##2.原始版dumpdecrypted使用</p><p>###2.1下载以及编译dumpdecrypted</p><blockquote><p>从github下载源代码并且编译：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MacBookPro:dumpdecrypted lemon$ git clone https://github.com/stefanesser/dumpdecrypted.git</span><br><span class="line">Cloning into &apos;dumpdecrypted&apos;...</span><br><span class="line">remote: Counting objects: 31, done.</span><br><span class="line">remote: Total 31 (delta 0), reused 0 (delta 0), pack-reused 31</span><br><span class="line">Unpacking objects: 100% (31/31), done.</span><br><span class="line">MacBookPro:dumpdecrypted lemon$ cd dumpdecrypted/</span><br><span class="line">MacBookPro:dumpdecrypted lemon$ make</span><br><span class="line">`xcrun --sdk iphoneos --find gcc` -Os  -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -c -o dumpdecrypted.o dumpdecrypted.c</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-2-用PS命令定位待解密的可执行文件"><a href="#2-2-用PS命令定位待解密的可执行文件" class="headerlink" title="2.2 用PS命令定位待解密的可执行文件"></a>2.2 用PS命令定位待解密的可执行文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MacBookPro:~ lemon$ ssh 5s</span><br><span class="line">lemons-iPhone5S:~ root# ps -e | grep /var</span><br><span class="line">  481 ??         0:05.44 /usr/libexec/pkd -d/var/db/PlugInKit-Annotations</span><br><span class="line"> 6707 ??         0:06.07 /var/containers/Bundle/Application/4503A878-7B82-46C3-B938-8D8719A6D78E/Friday.app/Friday</span><br><span class="line"> 6715 ttys000    0:00.01 grep /var</span><br></pre></td></tr></table></figure><h3 id="2-3-获取目标APP的document目录"><a href="#2-3-获取目标APP的document目录" class="headerlink" title="2.3 获取目标APP的document目录"></a>2.3 获取目标APP的document目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lemons-iPhone5S:~ root# cat /var/containers/Bundle/Application/4503A878-7B82-46C3-B938-8D8719A6D78E/Friday.app/Info.plist | grep CFBundleIdentifier -A 1</span><br><span class="line">    &lt;key&gt;CFBundleIdentifier&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;com.xtuone.Friday&lt;/string&gt;</span><br></pre></td></tr></table></figure><h3 id="2-4-将dylib复制到document目录"><a href="#2-4-将dylib复制到document目录" class="headerlink" title="2.4 将dylib复制到document目录"></a>2.4 将dylib复制到document目录</h3><h4 id="2-4-1-通过私有api获取目标app的document目录"><a href="#2-4-1-通过私有api获取目标app的document目录" class="headerlink" title="2.4.1 通过私有api获取目标app的document目录"></a>2.4.1 通过私有api获取目标app的document目录</h4><blockquote><p>新建一个xcode项目，将以下代码复制到APPDelegate的application:didfinishLaunchingWithOptions:下，然后运行项目，就可以在控制器输出document的目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundleId = @&quot;com.xtuone.Friday&quot;;</span><br><span class="line">    NSURL *url = [[NSClassFromString(@&quot;LSApplicationProxy&quot;) performSelector:@selector(applicationProxyForIdentifier:) withObject:bundleId]performSelector:@selector(dataContainerURL)];</span><br><span class="line">    NSLog(@&quot;%@&quot;,[url.absoluteString stringByAppendingString:@&quot;/Documents&quot;]);</span><br></pre></td></tr></table></figure><blockquote><p>通过以上代码获得的document目录是：/var/mobile/Containers/Data/Application/06B16FDB-4EA1-4093-A729-613111061798/Documents</p></blockquote><p>####2.4.2 通过cycript获取目标app的document目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lemons-iPhone5S:~ root# cycript -p 6707</span><br><span class="line">cy# [[NSBundle mainBundle]bundleIdentifier]</span><br><span class="line">@&quot;com.xtuone.Friday&quot;</span><br><span class="line">cy# NSHomeDirectory()</span><br><span class="line">@&quot;/var/mobile/Containers/Data/Application/06B16FDB-4EA1-4093-A729-613111061798&quot;</span><br><span class="line">cy#</span><br></pre></td></tr></table></figure><h4 id="2-4-3-复制dumpdecrypted-dylib到上述的document路径中"><a href="#2-4-3-复制dumpdecrypted-dylib到上述的document路径中" class="headerlink" title="2.4.3 复制dumpdecrypted.dylib到上述的document路径中"></a>2.4.3 复制dumpdecrypted.dylib到上述的document路径中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 dumpdecrypted.dylib root@localhost:/var/mobile/Containers/Data/Application/06B16FDB-4EA1-4093-A729-613111061798/Documents</span><br></pre></td></tr></table></figure><h3 id="2-5-解密"><a href="#2-5-解密" class="headerlink" title="2.5 解密"></a>2.5 解密</h3><blockquote><p>通过DYLD_INSERT_LIBRARIES注入解密</p></blockquote><h2 id="3-通过frida-ios-dump-来给应用脱壳"><a href="#3-通过frida-ios-dump-来给应用脱壳" class="headerlink" title="3 通过frida-ios-dump 来给应用脱壳"></a>3 通过<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a> 来给应用脱壳</h2><h2 id="4-Clutch"><a href="#4-Clutch" class="headerlink" title="4 Clutch"></a>4 <a href="https://github.com/KJCracks/Clutch" target="_blank" rel="noopener">Clutch</a></h2><blockquote><p>clutch同样是一个开源解密工具，与dumpdecrypted不同的是，Clutch会生成一个新的进程，然后暂停进程并且dump内存来生成新的ipa。</p></blockquote><h3 id="4-1-下载并编译Clutch"><a href="#4-1-下载并编译Clutch" class="headerlink" title="4.1 下载并编译Clutch"></a>4.1 下载并编译Clutch</h3><blockquote><p>git clone  <a href="https://github.com/KJCracks/Clutch" target="_blank" rel="noopener">https://github.com/KJCracks/Clutch</a><br>下载完成之后用xcode打开工程，设置Debug生成所有的架构，设置Build Active Architecture 为 NO ，选择真机设备 command+B 编译。编译完成之后在本地的Build文件夹里面会有一个Clutch的命令行文件</p></blockquote><h3 id="4-2-将文件复制到设备中"><a href="#4-2-将文件复制到设备中" class="headerlink" title="4.2 将文件复制到设备中"></a>4.2 将文件复制到设备中</h3><blockquote><p>使用如下命令，把生成的Build/Clutch复制到设备/usr/bin目录下，并且设置可执行权限。<br>scp -P 2222 root@localhost:/usr/bin<br>ssh 5s<br>chmod +x /usr/bin/Cluch</p></blockquote><h3 id="4-3-Clutch解密"><a href="#4-3-Clutch解密" class="headerlink" title="4.3 Clutch解密"></a>4.3 Clutch解密</h3><blockquote><p>SSH到越狱设备，使用Clutch -i 运行获取目标target的BundleID<br>使用Clutch -b target.BundleID来解密</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lemons-iPhone5S:~ root# Clutch -b com.xtuone.Friday</span><br><span class="line">2018-06-21 16:46:11.732 Clutch[6958:1126993] command: Only dump binary files from specified bundleID</span><br><span class="line">Zipping Friday.app</span><br><span class="line">Dumping &lt;FridayExtensionOC&gt; (arm64)</span><br><span class="line">Patched cryptid (64bit segment)</span><br><span class="line">Writing new checksum</span><br><span class="line">2018-06-21 16:46:12.872 clutch[6960:1127016] command: Only dump binary files from specified bundleID</span><br><span class="line">Failed to dump framework (null) :(</span><br><span class="line">Dumping &lt;Friday&gt; (arm64)</span><br><span class="line">Patched cryptid (64bit segment)</span><br><span class="line">Writing new checksum</span><br><span class="line">Zipping lame.framework</span><br><span class="line">Zipping FridayExtensionOC.appex</span><br><span class="line">DONE: /private/var/mobile/Documents/Dumped/com.xtuone.Friday-iOS8.0-(Clutch-(null)).ipa</span><br><span class="line">Finished dumping com.xtuone.Friday in 20.8 seconds</span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>给应用砸壳实际上有两种方法，一种是基于DYLD_INSERT_LIBRARIES环境变量将动态库注入到目标进程，然后dump内存。另外一种是通过posix_spawnp创建一个进程，然后dump内存。</p>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dumpdecrypted </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 逆向常用工具</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/iOS-%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/iOS-%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h2 id="mac工具"><a href="#mac工具" class="headerlink" title="mac工具"></a>mac工具</h2><h3 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h3><ul><li><a href="https://iterm2.com/" target="_blank" rel="noopener">iTerm2</a></li></ul><blockquote><p>代替默认的Terminal，提供了很多高级设置，例如自动补全，高亮等等</p></blockquote><ul><li><a href="https://github.com.robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a></li></ul><blockquote><p>自定义主题，git显示，Tab补全等</p></blockquote><ul><li><a href="http://zipzapmac.com/go2shell" target="_blank" rel="noopener">Go2Shell</a></li></ul><blockquote><p>从finder中打开终端并且自动切换到当前目录</p></blockquote><ul><li><a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a></li></ul><blockquote><p>工作流软件，快速打开软件，添加自己的工作流。参见<a href="https://bestswifter.gitbook.io/effectivemac/mac-gong-zuo-liu/alfred-jian-jie" target="_blank" rel="noopener">bestswifter的博客</a></p></blockquote><a id="more"></a><h3 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h3><ul><li><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a></li></ul><blockquote><p>MacOS的包管理器，快速安装各种工作</p></blockquote><ul><li><a href="https://github.com/libimobiledevice" target="_blank" rel="noopener">libimobiledevice</a></li></ul><blockquote><p>提供了很多能与iOS交付的工具，例如端口映射查看日志，安装程序</p></blockquote><h3 id="逆向工具"><a href="#逆向工具" class="headerlink" title="逆向工具"></a>逆向工具</h3><ul><li><a href="http://www.newosxbook.com/tools/jtool.html" target="_blank" rel="noopener">jtool</a></li></ul><blockquote><p>查看文件的结构，代码签名</p></blockquote><ul><li><a href="http://www.capstone-engine.org/" target="_blank" rel="noopener">capstone</a></li></ul><blockquote><p>多平台，多架构支持的反汇编框架</p></blockquote><ul><li><a href="https://github.com/keystone-engine/keystone" target="_blank" rel="noopener">keystone</a></li></ul><blockquote><p>将汇编指令转换成Hex机器码</p></blockquote><ul><li><a href="https://github.com/radare/radare2" target="_blank" rel="noopener">redare2</a></li></ul><blockquote><p>一款开放源代码的逆向工程平台</p></blockquote><ul><li><a href="https://github.com/imkira/mobiledevice" target="_blank" rel="noopener">mobiledevice</a></li></ul><blockquote><p>安装app或者ipa包</p></blockquote><ul><li><a href="http://www.i-funbox.com/" target="_blank" rel="noopener">iFunBox</a></li></ul><blockquote><p>查看越狱设备的文件目录</p></blockquote><ul><li><a href="https://github.com/stefanesser/dumpdecrypted.git" target="_blank" rel="noopener">dumpdecrypted</a></li></ul><blockquote><p>dumpdecrypted 是一个开源的砸壳工具，它会注入可执行文件，动态的从内存中dump出解密后的内容。使用教程请看<a href="">这里</a></p></blockquote><ul><li><a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">class-dump</a></li></ul><blockquote><p>class-dump 是一个用于从可执行文件中获取类，方法和属性的工具，上述源代码在导出ARMV7架构的时候会出问题，原因是在读取类没有分64和32位系统进行不同的操作，最新的fix bug的源码在<a href="https://github.com/AloneMonkey/class-dump" target="_blank" rel="noopener">AloneMonkey/Class-dump</a></p></blockquote><ul><li><a href="https://revealapp.com" target="_blank" rel="noopener">Reveal</a></li></ul><blockquote><p>Reveal 是一个用户动态查看APP UI层级架构的工具，可以在开发过程中动态调试修改程序的样式，也可以注入第三方APP以查看应用的界面结构。<br>有两种方式可以使用Reveal，第一种是正向开发的时候通过pod的方式加入Reveal</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target &apos;RevealAPP&apos; do</span><br><span class="line">    pod &apos;Reveal-SDK&apos;, :configurations=&gt; [&apos;Debug&apos;]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>第二种方式是越狱设备注入Raveal,可以调试所有的APP，在越狱设备，可以将RevealServer重命名为libReveal.dylib，以及新建libReveal.plist文件，里面输入需要调试的APP的BundleID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   Filter = &#123;</span><br><span class="line">         Bundles = (</span><br><span class="line">             &quot;com.lemon.example&quot;,</span><br><span class="line">         );</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上两个文件复制到越狱设备的 /Library/MobileSubstrate/DynamicLibraries/目录下，这样可以通过Cydia Substrate的MobileLoader在程序运行的时候通过dyld_insert_libraries命令将自己加载到目标APP的Document目录下，然后查找上述路径的所有的plist，找到对应的Bundleid之后，通过dlopen()函数将动态库注入到APP中 </p><h2 id="越狱设备工具"><a href="#越狱设备工具" class="headerlink" title="越狱设备工具"></a>越狱设备工具</h2><ul><li>cydia</li></ul><blockquote><p>cydia是一个可以让用户在越狱设备上面安装各种插件的软件管理器，相当于越狱设备的APPStore</p></blockquote><ul><li>SSH</li></ul><blockquote><p>SSH是一种网络协议，用于计算机之前的加密登录，他存在多种实现，因为不同系统使用的越狱工具不一样，所以需要根据iOS的版本来进行设置。<br>iOS8 &amp; iOS9 ，可以通过安装OpenSSH来登录，安装方法：1.在cydia中搜索OpenSSH并且安装，安装完成之后打开Wifi设置界面，打开当前连接的wifi，获取ip地址(假设是192.168.2.21)，然后打开终端，输入以下命令后回车： ssh <a href="mailto:root@192.168.2.21" target="_blank" rel="noopener">root@192.168.2.21</a>  2.稍等片刻之后输入yes并且回车，然后输入默认密码alpine完成登录。（当远程主机的公钥被接受以后，他会保存到mac的$HOME/.ssh/known_hosts文件中，再次连接这台主机时，系统就会认出他的公钥已经保存到本地，从而跳过警告部分，直接提示用户输入密码。）<br>iOS10.0 &amp; iOS10.2 ，越狱工具yalu内置了一个相对轻量级的工具dropbear，供用户直接使用。安装方法：1.在cydia中搜索MTerminal和adv-cmds，然后运行ps aux | grep dropbear 命令。如果有输出内容，则代表默认支持usb连接，如果这是要连接，在mac上转发端口即可登录，命令如下：<br>iproxy 22 2222<br>ssh root@localhost -p 2222<br>如果要通过wifi连接，需要在终端设备执行一下命令<br>/usr/local/bin/dropbear -F -R -p 22<br>然后在mac上直接SSH登录<br>ssh <a href="mailto:root@192.168.2.21" target="_blank" rel="noopener">root@192.168.2.21</a></p></blockquote><ul><li><a href="通过cydia安装">iFile</a></li></ul><blockquote><p>查看越狱设备的文件目录</p></blockquote><ul><li><a href="从cydia安装">cydia substrate</a></li></ul><blockquote><p>cydia substrate是一个框架，允许第三方开发者在越狱系统方法里面打一下运行时补丁和扩展一些方法，是开发越狱插件的基石。cydia substrate主要包含三个模块，分别是MobileHooker,MObileLoader,Safe mode。<br>MobileHooker 用于替换系统或者应用的方法，它提供了MSHookMessageEX 来hook OC的函数，MSHookFunction来hook C函数。<br>MobileLoader 用于将第三方动态库加载到目标应用里面。首先它会通过dyld_insert_libraries将自己加载到目标程序里面，然后通过查找/Library/MobileSubstrate/DynamicLibraries/目录下的所有plist文件，如果plist文件里面包含有当前应用的BundleID，那么就会通过dlopen()函数打开对应的dylib文件。<br>safe mode 当插件加载导致了系统奔溃时，mobilesafety会捕捉到这个异常并且让设备进入安全模式。找到最近安装的导致奔溃的插件并且卸载即可退出安全模式。</p></blockquote><ul><li>adv-cmds</li></ul><blockquote><p>提供ps命令</p></blockquote><ul><li>appsync</li></ul><blockquote><p>让系统不再校验应用的签名</p></blockquote><ul><li>scp</li></ul><blockquote><p>对于iOS10以后的版本，使用yalu越狱之后就没有scp这个工具了，可以在网上找到scp的源代码使用iFunBox复制到设备的/usr/bin目录下，然后通过ssh访问该目录，执行以下命令：<br>cd /usr/bin<br>ldid -S scp<br>chmod 777 scp</p></blockquote><ul><li><a href="https://github.com/facebook/chisel" target="_blank" rel="noopener">chisel</a></li></ul><blockquote><p>提供便利的LLDB调试命令<br>安装教程</p><ol><li>brew install chisel</li><li>如果不存在~/.lldbinit文件那就创建一个文件，并且将以下代码放到该文件中<br>#~/.lldbinit<br>…<br>command script import /usr/local/opt/chisel/libexec/fblldb.py</li><li>重启Xcode或者在LLDB中输入 command source ~/.lldbinit命令在加载脚本。</li></ol></blockquote><h3 id="安全工具"><a href="#安全工具" class="headerlink" title="安全工具"></a>安全工具</h3><ul><li><a href="https://github.com/Polidea/ios-class-guard" target="_blank" rel="noopener">ios-class-guard</a></li></ul><blockquote><p>该工具是从class-dump fork出来的，用于dump出APP中的类和方法并且生成混淆代码，将生成的混淆的宏定义添加到项目的pch文件中，达到混淆所有的类和方法的作用</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS 逆向常用命令</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/iOS-%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/iOS-%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="1-查看信息相关"><a href="#1-查看信息相关" class="headerlink" title="1. 查看信息相关"></a>1. 查看信息相关</h3><ul><li>查看越狱设备所有的APP的BundleID （前提需要安装frida-iOS-dump）</li></ul><blockquote><p>MacBookPro:frida-ios-dump-master lemon$ ./dump.py -l</p></blockquote><ul><li>查看设备UDID (前提需要安装ideviceinstall)</li></ul><blockquote><p>MacBookPro:~ lemon$ idevice_id  -l</p></blockquote><ul><li>查看iPA是否已经砸壳 (如果返回cryptid=0代表已砸壳，否则代表未砸壳)</li></ul><blockquote><p>MacBookPro:~ lemon$ otool -l target.app/target | grep cryptid</p></blockquote><a id="more"></a><ul><li>查看设备日志</li></ul><blockquote><p>MacBookPro:~ lemon$ idevicesyslog -u deviceudid</p></blockquote><ul><li>给特定的设备安装程序</li></ul><blockquote><p>MacBookPro:~ lemon$ ideviceinstaller -i target.ipa -u  deviceudid</p></blockquote><ul><li>砸壳 (使用frida)</li></ul><blockquote><p>MacBookPro:frida-ios-dump-master lemon$ ./dump.py BundleID</p></blockquote><ul><li>class-dump头文件</li></ul><blockquote><p>MacBookPro:~ lemon$ class-dump -s -S -H target.app/target -o /path/to/save/header</p></blockquote><ul><li>查看动态库架构</li></ul><blockquote><p>lipo -info</p></blockquote><ul><li>ssh</li></ul><blockquote><p>ssh root@deviceip</p></blockquote><ul><li>查找进程</li></ul><blockquote><p>ps aux | grep /App<br>ps -e | grep /Applications</p></blockquote><ul><li>查找文件</li></ul><blockquote><p>grep -r Header /System/Library/</p></blockquote><ul><li>分离fat binary</li></ul><blockquote><p>lipo -thin armv7 WeChat.decrypted -output WeChat_armv7.decrypted<br>lipo -thin arm64 xxx.decryptec -output xxx.arm64.decrypted</p></blockquote><h3 id="2-LLDB"><a href="#2-LLDB" class="headerlink" title="2. LLDB"></a>2. LLDB</h3><ul><li>打印UI结构</li></ul><blockquote><p>po [[[UIWindow keyWindow] rootViewController] _printHierarchy]    (iOS 8)<br>po [[UIWindow keyWindow] recursiveDescription]</p></blockquote><ul><li>打印调用栈信息</li></ul><blockquote><p>bt (backtrace)<br>bt all (all threads)</p></blockquote><ul><li>objc_msgSend参数打印</li></ul><blockquote><p>po $xo</p></blockquote><blockquote><p>p (char*)$x1</p></blockquote><blockquote><p>p (SEL)$x1</p></blockquote><ul><li>返回地址</li></ul><blockquote><p>p/x $lr</p></blockquote><ul><li>增加断点</li></ul><blockquote><p>b -a ox00002224</p></blockquote><ul><li>列举模块</li></ul><blockquote><p>image lisg -o -f </p></blockquote><ul><li>lldb基础指令</li></ul><blockquote><p>c<br>n<br>ni<br>br list<br>br del<br>br dis<br>br en</p></blockquote><ul><li>远程调试</li></ul><blockquote><p>debugserver *:1234 -a pid</p></blockquote><blockquote><p>debugserver -x backboard *:1234 /var/mobile/Containers/Bundle/Application/9DB7CE45-3B4C-42A3-9D4D-49A3A5122903/AlipayWallet.app/AlipayWallet</p></blockquote><ul><li>远程连接</li></ul><blockquote><p>proces connect connect://192.168.2.154:1234</p></blockquote><ul><li>lldb expr例子</li></ul><blockquote><p>(lldb) expr char <em>$str = (char </em>)malloc(8)</p><p>(lldb) expr (void)strcpy($str, “munkeys”)</p><p>(lldb) expr $str[1] = ‘o’</p><p>(char) $0 = ‘o’</p><p>(lldb) p $str</p><p>(char *) $str = 0x00007fd04a900040 “monkeys”</p><p>(lldb) x/4c $str</p><p>(lldb) x/1w <code>$str + 3</code></p><p>(lldb) expr (void)free($str)</p><p>(lldb) expr id $myView = (id)0x7f82b1d01fd0</p><p>(lldb) expr (void)[$myView setBackgroundColor:[UIColor blueColor]]</p><p>(lldb) expr (void)[CATransaction flush]</p><p>(lldb) po [$myButton allTargets]</p><p>(lldb) p (ptrdiff_t)ivar_getOffset((struct Ivar *)class_getInstanceVariable([MyView class], “_layer”))</p></blockquote><ul><li>给断点增加命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br command add 1</span><br><span class="line">Enter your debugger command(s).  Type &apos;DONE&apos; to end.</span><br><span class="line">&gt; register read $rdi </span><br><span class="line">&gt; c </span><br><span class="line">&gt; DONE</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><ul><li>修改寄存器的值</li></ul><blockquote><p>register write x0 1</p></blockquote><h3 id="3-Cycript"><a href="#3-Cycript" class="headerlink" title="3. Cycript"></a>3. Cycript</h3><ul><li>查看当前界面的元素层级结构</li></ul><blockquote><p>cy# [[UIApp keyWindow]recursiveDescription].toString()</p></blockquote><ul><li>查看当前keywindow的根控制器的所有subView</li></ul><blockquote><p>cy# [[[UIApp keyWindow] rootViewController] _printHierarchy].toString()</p></blockquote><ul><li>输出简单的视图信息</li></ul><blockquote><p>cy# [[UIApp keyWindow] _autolayoutTrace].toString()</p></blockquote><ul><li>查看一个实例的所有ivar</li></ul><blockquote><p>cy# [choose(SBApplication)[0] _ivarDescription].toString()</p></blockquote><ul><li>查看一个class的对象方法和类方法</li></ul><blockquote><p>cy# [choose(SBApplicationController)[0] _methodDescription].toString()</p></blockquote><ul><li>访问对象和实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0xb226710 url]</span><br><span class="line">@&quot;ww4fd1rfRDShBo_4K6rqfwAAACMAAQED&quot;</span><br><span class="line"></span><br><span class="line">cy# c = #0x1752d8c0</span><br><span class="line">cy#&quot;&lt;FavAudioPlayerController: 0x1752d8c0; frame = (0 0; 290 60); autoresize = W; layer = &lt;CALayer: 0x172dc2b0&gt;&gt;&quot;</span><br><span class="line">cy# c-&gt;m_audioInfo</span><br><span class="line">cy#&quot;&lt;FavAudioInfo: 0x172b2a30&gt;&quot;</span><br><span class="line">cy# c-&gt;m_audioInfo.m_nsAudioPath</span><br></pre></td></tr></table></figure><h3 id="4-ARM"><a href="#4-ARM" class="headerlink" title="4. ARM"></a>4. ARM</h3><h3 id="5-工具"><a href="#5-工具" class="headerlink" title="5. 工具"></a>5. 工具</h3><ul><li><a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpdecrypted</a></li><li><a href="https://github.com/theos/theos" target="_blank" rel="noopener">theos</a></li><li><a href="https://cgit.sukimashita.com/usbmuxd.git/" target="_blank" rel="noopener">usbmuxd</a> </li><li><a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a></li><li><a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">class-dummp</a></li><li><a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a></li></ul>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>通过theos提供的logify来为类的所有方法添加追踪日志</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/%E9%80%9A%E8%BF%87theos%E6%8F%90%E4%BE%9B%E7%9A%84logify%E6%9D%A5%E4%B8%BA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E8%BF%BD%E8%B8%AA%E6%97%A5%E5%BF%97/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/%E9%80%9A%E8%BF%87theos%E6%8F%90%E4%BE%9B%E7%9A%84logify%E6%9D%A5%E4%B8%BA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E8%BF%BD%E8%B8%AA%E6%97%A5%E5%BF%97/</url>
      <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>###logify是THEOS自带的为代码添加Log的工具，可以使用该工具给指定的类添加Log代码并且生成一个新的Tweak.xm文件</p><h2 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h2><h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h3><h4 id="2-1-1-安装Theos"><a href="#2-1-1-安装Theos" class="headerlink" title="2.1.1 安装Theos"></a>2.1.1 安装Theos</h4><p> 首先需要安装<a href="https://github.com/theos/theos" target="_blank" rel="noopener">Theos</a>，安装完成之后会默认安装此工具。</p><a id="more"></a><h4 id="2-1-2-将APP脱壳，有两种方式可以获得脱壳的APP"><a href="#2-1-2-将APP脱壳，有两种方式可以获得脱壳的APP" class="headerlink" title="2.1.2 将APP脱壳，有两种方式可以获得脱壳的APP"></a>2.1.2 将APP脱壳，有两种方式可以获得脱壳的APP</h4><h5 id="2-1-2-1-无越狱机"><a href="#2-1-2-1-无越狱机" class="headerlink" title="2.1.2.1 无越狱机"></a>2.1.2.1 无越狱机</h5><p>通过PP助手去越狱市场下载脱壳的ipa，有时下载下来的也不一定是脱壳后的，你可以通过在终端执行以下命令<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -l target.app/target | grep crypt</span><br></pre></td></tr></table></figure></p><p> 如果输出<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cryptoff 16384</span><br><span class="line">cryptsize 58753024</span><br><span class="line">cryptid 0 //0 代表已经砸壳，1代表未砸壳</span><br></pre></td></tr></table></figure></p><h5 id="2-1-2-2-有越狱机"><a href="#2-1-2-2-有越狱机" class="headerlink" title="2.1.2.2 有越狱机"></a>2.1.2.2 有越狱机</h5><p> 你需要一台越狱机器，安装完整版之后通过工具来脱壳，这个时候你也有两个方法获得脱壳应用。方法一：你可以使用<a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpdecrypted</a>工具来砸壳。方式二：你也可以使用庆总开源的工具<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-iOS-dump</a>一条命令行进行砸壳。</p><h4 id="2-1-3-class-dump-出头文件"><a href="#2-1-3-class-dump-出头文件" class="headerlink" title="2.1.3 class-dump 出头文件"></a>2.1.3 class-dump 出头文件</h4><p>通过以上的方式得到砸壳后的应用之后，需要利用<a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">clas-dump</a>工具dump出头文件。具体的用法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class-dump -s -S -H target.app/target -o /path/to/save/header</span><br></pre></td></tr></table></figure><h4 id="2-1-4-使用logify工具生成Tweak-xm文件"><a href="#2-1-4-使用logify工具生成Tweak-xm文件" class="headerlink" title="2.1.4 使用logify工具生成Tweak.xm文件"></a>2.1.4 使用logify工具生成Tweak.xm文件</h4><p>该文件里面会hook该头文件对应的类，并且会在代码里面加上Log打印<br>用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logify.pl HookHeader.h的全路径 &gt;Tweak.xm</span><br></pre></td></tr></table></figure><p>如果要跟踪多个头文件，则继续转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logify.pl 其它头文件 &gt;&gt; Tweak.xm</span><br></pre></td></tr></table></figure><p> <em>注意中间是 &gt;&gt;</em></p><h4 id="2-1-5-使用nic-pl命令来生成Theos工程，选择Teak工具。"><a href="#2-1-5-使用nic-pl命令来生成Theos工程，选择Teak工具。" class="headerlink" title="2.1.5 使用nic.pl命令来生成Theos工程，选择Teak工具。"></a>2.1.5 使用nic.pl命令来生成Theos工程，选择Teak工具。</h4><h4 id="2-1-6-创建完Tweak工程之后，将在2-1-4中生成的Tweak-xm替换掉工程中的Teak-xm-不过此时还需要对该文件做一些修改"><a href="#2-1-6-创建完Tweak工程之后，将在2-1-4中生成的Tweak-xm替换掉工程中的Teak-xm-不过此时还需要对该文件做一些修改" class="headerlink" title="2.1.6 创建完Tweak工程之后，将在2.1.4中生成的Tweak.xm替换掉工程中的Teak.xm.不过此时还需要对该文件做一些修改"></a>2.1.6 创建完Tweak工程之后，将在2.1.4中生成的Tweak.xm替换掉工程中的Teak.xm.不过此时还需要对该文件做一些修改</h4><p>a.去掉.cxx_destruct 方法</p><p>b.将HBLogDebug 改为NSLog</p><p>然后修改makefile文件，在最上面那一行增加<br>THEOS_DEVICE_IP = 你的设备的IP</p><h4 id="2-1-7"><a href="#2-1-7" class="headerlink" title="2.1.7"></a>2.1.7</h4><p> 使用一下make package install 生成deb包，并且安装到越狱设备上。</p><h4 id="2-1-8-运行目标APP，观察日志。"><a href="#2-1-8-运行目标APP，观察日志。" class="headerlink" title="2.1.8 运行目标APP，观察日志。"></a>2.1.8 运行目标APP，观察日志。</h4><p> 有两种方法可以观察日志，第一种是通过xcode-&gt;window-&gt;Device and simulators-&gt;view device logs 。<br> 第二种是通过idevicesyslog -u udid 来查看特定设备的日志。这种方式需要安装<a href="https://www.jianshu.com/p/746f3ddded1f" target="_blank" rel="noopener">libimobiledevice</a></p>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logify </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>导出iOS真机缓存的dyld_shared_cache_arm64文件</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/%E5%AF%BC%E5%87%BAiOS%E7%9C%9F%E6%9C%BA%E7%BC%93%E5%AD%98%E7%9A%84dyld-shared-cache-arm64%E6%96%87%E4%BB%B6/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/%E5%AF%BC%E5%87%BAiOS%E7%9C%9F%E6%9C%BA%E7%BC%93%E5%AD%98%E7%9A%84dyld-shared-cache-arm64%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h3 id="1前言"><a href="#1前言" class="headerlink" title="1前言"></a>1前言</h3><p>在iOS系统中，存在着这么一个文件夹，/System/Library/Caches/com.apple.dyld，这个文件夹里面放着的是什么文件呢，在我的iphone5s中，两个文件dyld_shared_cache_armv7s和dyly_shared_arm64，这两个文件分别代表两个arm架构，一个是armv7s一个是arm64。</p><a id="more"></a><p>顾名思义，这两个都是缓存文件，里面放着的都是各种系统所可能用到的动态库。如Foundation.framework,Security.framework等等。在/System/Library/Frameworks/这个路径下面所有的动态库只放了一些配置文件，而真正的执行文件就在上面说的缓存文件里面。因为几乎所有的iOS程序都会用到系统库，当程序运行的时候会使用dyld(位于/usr/lib/dylb)程序进行连接，另一方面，由于每个iOS程序都会连接很多的动态库，如果需要一个一个连接会很耗时，如果把它们放在一个地方打包好，等到运行的时候全部连接岂不美滋滋，基于这些原因，就有了dyld_shared_cache_armv7s和dyld_shared_cache_armv64两个缓存文件（有些设备有可能还会有dyld_shared_cache_armv7）。</p><h4 id="2工具"><a href="#2工具" class="headerlink" title="2工具"></a>2工具</h4><p>上面我已经解释了为什么会存在这两个文件以及这两个文件的作用，在iOS逆向中，我们常常需要查看某一个系统类的实现，这个时候就要去对应的系统库里面查看，这些系统库就放在对应的缓存文件里面了。但是这些文件是经过处理的，不可以直接查看，所以需要用到一些工具来查看。这里介绍两个工具，一个是<a href="https://github.com/kennytm/Miscellaneous/downloads" target="_blank" rel="noopener">dyld_decache[v0.1c]</a> 另外一个是<a href="https://opensource.apple.com/source/dyld/dyld-195.6/launch-cache/dsc_extractor.cpp" target="_blank" rel="noopener">dsc_extractor</a>，<a href="https://www.jianshu.com/p/a7b1fed0359f" target="_blank" rel="noopener">编译方法</a> 。这两个工具的不同之处是，第一个工具是不可以用来解析arm64指令集的缓存文件的，而dsc_extractor是可以用来解析arm64指令集的缓存文件的，现在基本上大家用的都是arm64位指令集的设备了。（iPhone5s以上都是arm64位结构）</p><h4 id="3还原"><a href="#3还原" class="headerlink" title="3还原"></a>3还原</h4><p>通过2中的dyld_decache[v0.1c]工具和dsc_extractor我们可以还原出<br>dyld_shared_cache_armX缓存文件中隐藏的framework。下面是语法</p><p>#####3.1 dsc_extractor<br>usage: dsc_extractor <path-to-cache-file> <path-to-device-dir></path-to-device-dir></path-to-cache-file></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usage: dsc_extractor 你要解析的arm64的缓存文件路径 保存的路径</span><br></pre></td></tr></table></figure><p>解析过程中会出现类似于<br>0/969</p><p>1/969</p><p>2/969</p><p>3/969</p><p>4/969</p><p>5/969</p><p>…..</p><p>这样的文字。</p><h5 id="3-2-dyld-decache-v0-1c"><a href="#3-2-dyld-decache-v0-1c" class="headerlink" title="3.2 dyld_decache[v0.1c]"></a>3.2 dyld_decache[v0.1c]</h5><p>dyld_decache[v0.1c] -o 要保存的路径   你要解析的缓存文件路径</p><p>解析完成后会出现两个文件加，一个是system,另外一个usr，如无意外，所有的动态库都会在里面，接下来尽情的蹂躏他们吧。不过记得在开始这一切之前，要将iphone里面的dyld_shared_cache_arm64文件拷贝一份到OSX上面去操作。</p>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>dsc_extractor的编译和使用</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/dsc-extractor%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/dsc-extractor%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="1前言"><a href="#1前言" class="headerlink" title="1前言"></a>1前言</h3><p>在iOS逆向中，我们常常需要对dyld_shared_cache_armX类型的文件进行还原，第一个我们经常使用的是dyld_decache工具，但是这个工具并不能用从来还原dyld_shared_cache_arm64文件，也就是64位指令集架构的缓存文件，这个时候dsc_extractor就为你续命了。</p><a id="more"></a><h3 id="2编译"><a href="#2编译" class="headerlink" title="2编译"></a>2编译</h3><p>打开终端依次执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir dsc_extractor</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd dsc_extractor</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://opensource.apple.com/tarballs/dyld/dyld-210.2.3.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf dyld-210.2.3.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd dyld-210.2.3/launch-cache/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch dsc_extractor.patch</span><br></pre></td></tr></table></figure><p>通过上面的操作，我们下载下来了touch dsc_extractor的源码并且解压出来，并在其中创建了一个touch dsc_extractor.patch的空文件，接下来把以下内容复制到该文件里面去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">--- dyld-210.2.3/launch-cache/dsc_extractor.cpp  2012-05-21 02:35:15.000000000 -0400</span><br><span class="line">+++ dyld-210.2.3/launch-cache/dsc_extractor.cpp2013-07-26 16:05:03.000000000 -0400</span><br><span class="line">@@ -37,6 +37,7 @@</span><br><span class="line"> #include &lt;mach-o/arch.h&gt;</span><br><span class="line"> #include &lt;mach-o/loader.h&gt;</span><br><span class="line"> #include &lt;Availability.h&gt;</span><br><span class="line">+#include &lt;dlfcn.h&gt;</span><br><span class="line"> </span><br><span class="line"> #define NO_ULEB </span><br><span class="line"> #include &quot;Architectures.hpp&quot;</span><br><span class="line">@@ -456,7 +457,7 @@</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">-#if 1</span><br><span class="line">+/* #if 1 */</span><br><span class="line"> </span><br><span class="line"> typedef int (*extractor_proc)(const char* shared_cache_file_path, const char* extraction_root_path,</span><br><span class="line"> void (^progress)(unsigned current, unsigned total));</span><br><span class="line">@@ -468,7 +469,7 @@</span><br><span class="line"> return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">-void* handle = dlopen(&quot;/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle&quot;, RTLD_LAZY);</span><br><span class="line">+void* handle = dlopen(&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle&quot;, RTLD_LAZY);</span><br><span class="line"> if ( handle == NULL ) &#123;</span><br><span class="line"> fprintf(stderr, &quot;dsc_extractor.bundle could not be loaded\n&quot;);</span><br><span class="line"> return 1;</span><br><span class="line">@@ -484,7 +485,7 @@</span><br><span class="line"> fprintf(stderr, &quot;dyld_shared_cache_extract_dylibs_progress() =&gt; %d\n&quot;, result);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line">-#endif</span><br><span class="line">+/* #endif */</span><br></pre></td></tr></table></figure><h3>记住，在+/<em>endif </em>/后面是还有一行空行的。</h3><p>然后执行一下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch &lt; dsc_extractor.patch</span><br></pre></td></tr></table></figure><p>执行完成该命令后，你可以在dsc_extractor.patch文件的同级目录下看到一个dsc_extractor.cpp文件，接下来打开这个文件，要修改里面的内容。如下：<br>原处：230行</p><p>const char* afterSlash = &amp;dirs[1];<br>修改成：</p><p>char* afterSlash = &amp;dirs[1];  去除const<br>原处：460行</p><p>#if 0<br>修改成：</p><p>#if 1<br>原处：488行</p><p>/<em> #endif </em>/<br>修改成：</p><p>#endif 放开注释</p><p>修改完成后，回到终端，运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ -o dsc_extractor dsc_extractor.cpp dsc_iterator.cpp</span><br></pre></td></tr></table></figure><p>到了这里，dsc_extractor终于编译完成了，你可以在同级目录下看到dsc_extractor的执行文件。你可以把它复制到任何地方然后使用。</p><h3 id="3使用"><a href="#3使用" class="headerlink" title="3使用"></a>3使用</h3><p>编译dsc_extractor成功后，用iFunBox将iOS 里面的/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64复制到OSX的任何位置，然后在终端运行</p><p>dsc_extractor完成路径 arm64缓存文件路径  要保存文件的路径</p><p>然后终端显示<br>0/1004<br>1/1004<br>2/1004<br>3/1004<br>4/1004<br>5/1004<br>6/1004<br>7/1004<br>这样的文本的时候就成功了</p>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dsc-extractor </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 基础汇编知识</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS-%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS-%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h3 id="1-寄存器-内存-栈"><a href="#1-寄存器-内存-栈" class="headerlink" title="1 寄存器 内存  栈"></a>1 寄存器 内存  栈</h3><p>在高级语言里面，操作对象是变量，在ARM汇编里面，操作对象是寄存器（register），内存和栈(stack)</p><a id="more"></a><h3 id="2-数据操作指令"><a href="#2-数据操作指令" class="headerlink" title="2 数据操作指令"></a>2 数据操作指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op &#123;cond&#125;&#123;s&#125; Rd, Rn, Op2</span><br></pre></td></tr></table></figure><p>其中，cond和s是两个可选后缀，cond用来指定指令op在什么条件下执行，共有下面17种条件。</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>EQ</td><td>结果为0, Equal to 0</td></tr><tr><td>NE</td><td>结果不为0，Not Equal to 0</td></tr><tr><td>CS</td><td>有进位或者借位  Carry Set</td></tr><tr><td>HS</td><td>同CS,unsigned Higher or same</td></tr><tr><td>CC</td><td>没有进位或者借位 Carry clear</td></tr><tr><td>LO</td><td>同CC unsigned Lower</td></tr><tr><td>MI</td><td>结果小于0 ， Minus</td></tr><tr><td>PL</td><td>结果大于0 ， Plus</td></tr><tr><td>VS</td><td>溢出， oVerflow set</td></tr><tr><td>VC</td><td>无溢出  ， oVerflow clear</td></tr><tr><td>HI</td><td>无符号比较大于 ，unsigned higher</td></tr><tr><td>LS</td><td>无符号比较小于，unsigned lower or same</td></tr><tr><td>GE</td><td>有符号比较大于等于 ，signed greater than or Equal</td></tr><tr><td>LT</td><td>有符号比较小于，signed less than</td></tr><tr><td>GT</td><td>有符号比较大于，signed greater than</td></tr><tr><td>LE</td><td>无符号比较小于等于，signed less than equal</td></tr><tr><td>AL</td><td>无条件（Always ,默认）</td></tr></tbody></table><p>例如：<br>比较 R0,R1<br>移动 GE R2, R1<br>移动 LT R2, R0<br>比较R0和R1的值，如果R0大于R1，那么R2等于R1,如果R0小于R1，那么R2等于R0。</p><hr><p>s的作用是指定指令op是否设置flag，共有下面四种flag。</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>N（Negative）</td><td>如果结果小于0则置1，否则置0</td></tr><tr><td>Z (Zero)</td><td>如果结果是0则置1，否则置0</td></tr><tr><td>C （Carry）</td><td>对于加操作来说，如果产生进位则置1，否则置0，对于减操作来说，如果产生借位则置0，否则置1，对于有位移的非加/减操作来说，C置移出值的最后一位，对于其他的非加/减操作来说，C的值一般不变</td></tr><tr><td>V（Overflos）</td><td>如果操作溢出则置1，否则置0</td></tr></tbody></table><p>需要注意的是，Cflag表示的是无符号位运算结果是否溢出，Vflag表示的是有符号位数运算结果是否溢出。</p><hr><p>算术操作</p><p>ADD R0, R1, R2 ; R0 = R1 + R2</p><p>ADC R0, R1, R2 ; R0 = R1 + R2 + C(arry)</p><p>SUB R0, R1, R2 ; R0 = R1 - R2</p><p>SBC R0, R1, R2 ; R0 = R1 - R2 - !C</p><p>RSB R0, R1, R2 ; R0 = R2 - R1</p><p>RSC R0, R1, R2 ; R0 = R2 - R1 - !C</p><hr><p>逻辑操作</p><p>AND R0, R1, R2 ; R0 = R1 &amp; R2 //按位与</p><p>ORR R0, R1, R2 ; R0 = R1 | R2 //按位或</p><p>EOR R0, R1, R2 ; R0 = R1 ^ R2 //按位异或</p><p>BIC R0, R1, R2 ; R0 = R1 &amp;~ R2 //按位取反与</p><p>MOV R0, R2 ; R0 = R2  //赋值</p><p>MVN R0, R2 ; R0 = ~R2  //按位取反</p><hr><p>比较操作</p><p>CMP R1, R2 ; 执行R1 - R2并依结果设置flag</p><p>CMN R1, R2 ; 执行R1 + R2并依结果设置flag</p><p>TST R1, R2 ; 执行R1 &amp; R2并依结果设置flag</p><p>TEQ R1, R2 ; 执行R1 ^ R2并依结果设置flag</p><hr><p>乘法操作</p><p>MUL R4, R3, R2 ; R4 = R3 * R2</p><p>MLA R4, R3, R2, R1 ; R4 = R3 * R2 + R1</p><p>乘法操作的操作数必须来自寄存器</p><p>###3 内存操作指令<br>内存操作指令的基本格式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op&#123;cond&#125;&#123;type&#125; Rn, [Rn,?Op2]</span><br></pre></td></tr></table></figure></p><p>其中Rn是基址寄存器，用户存放基地址</p><p>cond的作用于数据操作指令相同，都是用来指定op是在什么条件下执行</p><p>type指定指令op操作的数据类型，共有四种</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>B(unsigned Byte)</td><td>无符号byte，执行时扩展到32bit,以0填充</td></tr><tr><td>SB(Signed Byte)</td><td>有符号byte，仅用于LDR指令，执行时扩展到32bit，以符号位填充</td></tr><tr><td>H (signed Halfword)</td><td>无符号halfword,执行时扩展到32bitj,以0填充</td></tr><tr><td>SH （signed halfword）</td><td>有符号halfword 仅用于LDR指令，执行时扩展到32bit,以符号位填充</td></tr></tbody></table><p>如果不指定byte，则默认的数据类型是word<br>ARM内存操作基础指令只有两个： LDR (LoaD Register)将数据从内存中读出来，存到寄存器中。以及STR(STore Register)将寄存器的数据读出来，存到内存中。两个指令的使用情况如下：</p><p>LDR<br>-<br>LDR Rt, [Rn {,#offset}]  ;  Rt = *(Rn {+ offset}),{}代表可选</p><p>LDR Rt, [Rn, #offset]! ; Rt = *(Rn + offset); Rn<br>= Rn + offset</p><p>LDR Rt, [Rn], #offset ; Rt = *Rn; Rn = Rn +<br>offset</p><p>STR<br>-</p><p>STR Rt, [Rn {, #offset}] ; *(Rn {+ offset}) = Rt</p><p>STR Rt, [Rn, #offset]! ; *(Rn {+ offset}) = Rt; Rn<br>= Rn + offset</p><p>STR Rt, [Rn], #offset ; *Rn = Rt; Rn = Rn +<br>offset</p><p>此外， LDR和STR的变种LDRD和STRD还可以操<br>作双字（ Doubleword），即一次性操作2个寄存器，<br>其基本格式如下：<br>op{cond} Rt, Rt2, [Rn {, #offset}]</p><p>用法及原型类似，如下：<br>STRD R4, R5, [R9,#offset]  ； *(R9+offset) = R4 ,  *(R9+offset+R4) = R5</p><p>LDRD R4, R5, [R9,#offset] ; R4 = *(R9 + offset);<br>R5 = *(R9 + offset + 4)</p><p>除了LDR和STR外，还可以通过LDM（ LoaD<br>Multiple）和STM（ STore Multiple）进行块传输，一<br>次性操作多个寄存器。块传输指令的基本格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op&#123;cond&#125;&#123;mode&#125; Rd&#123;!&#125;, reglist</span><br></pre></td></tr></table></figure><p>其中Rd是基址寄存器，可选的“!”指定Rd变化后<br>的值是否写回Rd； reglist是一系列寄存器，用大括号<br>括起来，它们之间可以用“,”分隔，也可以用“-”表示<br>一个范围，比如， {R4–R6,R8}表示寄存器R4、 R5、<br>R6、 R8；这些寄存器的顺序是按照自身的编号由小<br>到大排列的，与大括号内的排列顺序无关。<br>需要特别注意的是， LDM和STM的操作方向与<br>LDR和STR完全相反： LDM是把从Rd开始，地址连续<br>的内存数据存入reglist中， STM是把reglist中的值存入<br>从Rd开始，地址连续的内存中。</p><p>“cond”的作用与数据操作指令相同。 “mode”指定<br>Rd值的4种变化规律，如下所示：</p><p>IA（ Increment After）<br>每次传输后增加Rd的值；</p><p>IB（ Increment Before）<br>每次传输前增加Rd的值；</p><p>DA（ Decrement After）<br>每次传输后减少Rd的值；</p><p>DB（ Decrement Before）<br>每次传输前减少Rd的值</p><p>示例： 假设R0的值为5</p><p>执行以下命令后， R4、 R5、 R6的值分别变成：<br>foo():<br>LDMIA R0, {R4 – R6} ; R4 = 5, R5 = 6,<br>R6 = 7<br>LDMIB R0, {R4 – R6} ; R4 = 6, R5 = 7,<br>R6 = 8<br>LDMDA R0, {R4 – R6} ; R4 = 5, R5 = 4,<br>R6 = 3<br>LDMDB R0, {R4 – R6} ; R4 = 4, R5 = 3,<br>R6 = 2</p><h4 id="4-分支指令"><a href="#4-分支指令" class="headerlink" title="4 分支指令"></a>4 分支指令</h4><p>分支指令可以分为无条件分支和条件分支两种。</p><p>. 无条件分支<br>foo():<br>B Label ; 跳转到Label处往下执行<br>…… ; 得不到执行<br>Label:<br>……</p><p>. 条件分支</p><p>条件分支的cond是依照6.2.1节提到的4种flag来判<br>断的，它们的对应关系如下：<br>cond flag<br>EQ Z = 1</p><p>NE Z = 0</p><p>CS C = 1</p><p>HS C = 1</p><p>CC C = 0</p><p>LO C = 0</p><p>MI N = 1</p><p>PL N = 0</p><p>VS V = 1</p><p>VC V = 0</p><p>HI C = 1 &amp; Z = 0</p><p>LS C = 0 | Z = 1</p><p>GE N = V</p><p>LT N != V</p><p>GT Z = 0 &amp; N = V</p><p>LE Z = 1 | N != V</p><p>在条件分支指令前会有一条数据操作指令来设置<br>flag，分支指令根据flag的值来决定代码走向，举例如<br>下：<br>Label:<br>LDR R0, [R1], #4<br>CMP R0, 0 ; 如果R0 == 0， Z = 1；否则Z = 0<br>BNE Label ; Z == 0则跳转</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LLDB &amp;&amp; debugserver的使用</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/LLDB-debugserver%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/LLDB-debugserver%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h4 id="1-1-LLDB"><a href="#1-1-LLDB" class="headerlink" title="1.1 LLDB"></a>1.1 LLDB</h4><p>  </p><h4>LLDB全称为low level debugger,是xcode自带的动态调试工具，可用于c,c++,objective-c，全盘支持iOS，OSX以及iOS模拟器。<br> LLDB有以下四个功能：<p></p><p> 1.在特定的情况下暂停程序</p><p> 2.在特定的情况下启动程序</p><p> 3.在程序停止的情况下检查程序内部</p><p> 4.在程序停止的情况下改动程序，观察执行过程。</p><p> LLDB是运行在OSX程序中的，可以通过特定的语句配合debugServer对iOS中的程序进行监视。</p><a id="more"></a><h4 id="1-2-debugServer"><a href="#1-2-debugServer" class="headerlink" title="1.2 debugServer"></a>1.2 debugServer</h4><p> </p><h4>debugserver是运行在iOS程序中的，顾名思义，作为server端，它接受与来自服务端，也就是LLDB传送过来的命令，继而执行的操作。再把执行结果返回给LLDB,默认情况下， iOS并没有安装debugserver，只有在设备连接了一次xcode之后，并在window-&gt;device中添加此设备之后，debugservercai才会别安装到iOS中，默认位于Developer/usr/bin目录下。<p></p><p> 但是默认的debugserver只用用户调试我们自己的app，如果想要调试iOS里面所有的app，还需要通过给debugserver赋予task_for_pid的权限。以下是配置task_for_pid的教程</p><p> 1.debugserver瘦身，首先根据你的iOS设备确定你的手机对应的ARM，4s是armv7,5,5c是armv7s，5s以上的机型都是arm64，我的手机是5s，所以对应的arm是arm64，所以只从debugserver保留arm64的架构即可。具体步骤:<br> 首先将未经处理的debugserver从iOS拷贝到OSX中，可以用scp命令，也可以用iFunBox。<br> 然后利用命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -thin arm64（这里对应你的iOS设备的结构） (未经处理的debugServer的路径) -output (新的debugserver的保存路径)</span><br></pre></td></tr></table></figure><p> 2.给debugServer添加task_for_pid权限，将以下xml保存为ent.xml。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;com.apple.springboard.debugapplications&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;get-task-allow&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;task_for_pid-allow&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;run-unsigned-code&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure><p> 运行以下命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldid -S(ent.xml的全路径) (debugServer的全路径)</span><br></pre></td></tr></table></figure><p> 以上命令实质上是通过ldid这个签名工具，为debugserver添加task_for_pid权限，上面的命令也可以用xcode自带的codesign实现。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codesign -s -f - --entitlements ent.plist -f debugserver</span><br></pre></td></tr></table></figure><p> 3.将添加权限后的debugserver放回去iOS复制到/usr/bin/debugserver，这样的好处是可以全局执行debugserver命令。另一个原因是因为在developer里面的是不可以写的，无法覆盖。<br> 4.给新的debugserver添加可执行的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/bin/debugserver</span><br></pre></td></tr></table></figure><p>####1.3 debugserver使用</p><p></p><h4>debugserver有两个命令。<p></p><p> 1.启动进程,debugserver会启动进程，并且开启port端口，等待来自ip的LLDB接入。ip如果为*则代表任意ip</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugserver backend ip:port /path/to/excutable</span><br></pre></td></tr></table></figure><p> 2.附加进程，附加进程是在进程已打开的情况下，可以执行以下命令。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugserver ip:port -a &quot;processname&quot;</span><br></pre></td></tr></table></figure><h4 id="1-4-LLDB-amp-amp-debugserver配合使用"><a href="#1-4-LLDB-amp-amp-debugserver配合使用" class="headerlink" title="1.4 LLDB &amp;&amp; debugserver配合使用"></a>1.4 LLDB &amp;&amp; debugserver配合使用</h4><p></p><h5><br>假设我们要调试在iOS中要按下home键的处理。通过IDA我们知道按下home键的时候调用了 -[SpringBoard _menuButtonDown:] 这个方法，现在我们的需求是在menuButtonDown的方法下面打一个断点。<p></p><p>(1)首先利用debugserver启动进程或者附加进程。系统的SpringBoard默认是启动的，所以不需要启动进程，使用附加进程命令即可。SSH到iOS中，然后附加到SpringBoard进程(以下命令开启了1234接口并且等待来自任意ip的LLDB接入)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Last login: Sun Apr  8 11:04:23 on ttys016</span><br><span class="line">MacBookPro:~ lemon$ ssh root@192.168.2.154</span><br><span class="line">lemons-iPhone5S:~ root# debugserver *:1234 -a &quot;SpringBoard&quot;</span><br><span class="line">debugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-340.3.124</span><br><span class="line"> for arm64.</span><br><span class="line">Attaching to process SpringBoard...</span><br><span class="line">Listening to port 1234 for a connection from *...</span><br></pre></td></tr></table></figure><p>(2)在OSX的terminal中启动LLDB，然后连接远程1234端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MacBookPro:~ lemon$ lldb</span><br><span class="line">(lldb) process connect connect://192.168.2.154:1234</span><br><span class="line">Process 2148 stopped</span><br><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = signal SIGSTOP</span><br><span class="line">    frame #0: 0x000000018208cfd8 libsystem_kernel.dylib`mach_msg_trap + 8</span><br><span class="line">libsystem_kernel.dylib`mach_msg_trap:</span><br><span class="line">-&gt;  0x18208cfd8 &lt;+8&gt;: ret    </span><br><span class="line"></span><br><span class="line">libsystem_kernel.dylib`mach_msg_overwrite_trap:</span><br><span class="line">    0x18208cfdc &lt;+0&gt;: mov    x16, #-0x20</span><br><span class="line">    0x18208cfe0 &lt;+4&gt;: svc    #0x80</span><br><span class="line">    0x18208cfe4 &lt;+8&gt;: ret    </span><br><span class="line">Target 0: (SpringBoard) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>(3)通过以上两步我们已经可以在电脑的终端利用LLDB调试APP了。现在在终端输入 image list -o -f 可以看到当前所有iOS中启动的所有的进程模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[(lldb) image list -o -f</span><br><span class="line">[  0] 0x0000000000040000 /Users/lemon/Library/Developer/Xcode/iOS DeviceSupport/9.3.1 (13E238)/Symbols/usr/lib/dyld</span><br><span class="line">[  1] 0x00000000000dc000 /System/Library/CoreServices/SpringBoard.app/SpringBoard(0x00000001000dc000)</span><br><span class="line">[  2] 0x0000000100988000 /Library/MobileSubstrate/MobileSubstrate.dylib(0x0000000100988000)</span><br><span class="line">[  3] 0x0000000001acc000 /Users/lemon/Library/Developer/Xcode/iOS DeviceSupport/9.3.1 (13E238)/Symbols/System/Library/PrivateFrameworks/StoreServices.framework/StoreServices</span><br></pre></td></tr></table></figure><p>(4)通过3中的信息我们发现了Spring的偏移是0x00000000000dc000，接下来我们需要用ida查看menuButtonDown这个函数在模块中的地址是多少。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                     -[SpringBoard _menuButtonDown:]:</span><br><span class="line">0000000100016fe8         stp        x28, x27, [sp, #0xffffffa0]!                ; Objective C Implementation defined at 0x1006a4550 (instance)</span><br><span class="line">0000000100016fec         stp        x26, x25, [sp, #0x10]</span><br><span class="line">0000000100016ff0         stp        x24, x23, [sp, #0x20]</span><br><span class="line">0000000100016ff4         stp        x22, x21, [sp, #0x30]</span><br><span class="line">0000000100016ff8         stp        x20, x19, [sp, #0x40]</span><br><span class="line">0000000100016ffc         stp        x29, x30, [sp, #0x50]</span><br><span class="line">0000000100017000         add        x29, sp, #0x50</span><br><span class="line">0000000100017004         sub        sp, sp, #0x60</span><br></pre></td></tr></table></figure><p>通过上面的信息可以看到，该函数的第一条指令的地址是0000000100016fe8，所以该函数偏移后的地址是：原地址+偏移 =》0x00000000000dc000 +   0000000100016fe8 = 0x1000F2FE8</p><p>(5)在偏移后的地址出打断点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0x1000F2FE8</span><br><span class="line">Breakpoint 1: where = SpringBoard`_mh_execute_header + 71804, address = 0x00000001000f2fe8</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>(6)在打完断点之后，可以按下home键，这个时候程序就会停在断点处，可以用1.5里面的命令进行调试等等</p><h4 id="1-5-LLDB命令解析"><a href="#1-5-LLDB命令解析" class="headerlink" title="1.5 LLDB命令解析"></a>1.5 LLDB命令解析</h4><p></p><h5><br>(1) b NSog // 在函数的起始位置设置断点<p></p><p>(2) br s -a address //在地址处设置断点</p><p>(3) br s -a ‘address + offsetAddress’ //在地址处设置断点</p><p>(4) br dis //禁用所有的断点</p><p>(5) br dis 6 //禁用序号为6的断点</p><p>(6) br del //删除所有断点</p><p>(7) br del 6 //删除序号为6的断点</p><p>(8) br en //启用所有断点</p><p>(9) br en 6 //启用序号为6的断点</p><p>(10)br com add 1 //当序号为1的断点执行的时候，可以执行预先设置的指令。当执行了这条指令之后，llDB会要求你输入一些指令，并且以DONE结束，当程序停在序号为1的断点时，就会执行这些预先设定的指令。</p><p>(11)p $R1 //打印R1的值</p><p>(12)p/x $sp //打印SP的地址，以16进制输出</p><p>(13)x/10 $sp //打印sp的地址，以10进制输出</p><p>(14)nexti 和 stepi //nexti不进入函数体，stepi进入函数体，nexti可以简写成ni,setpi可以简写成si。</p><p>(15)register write r0 1 //用于给指定的寄存器r0赋值为1从而达到对程序进行改动的目的。</p></h5></h5></h4></h4></h4>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLDB </tag>
            
            <tag> debugserver </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>libimobiledevice的安装和使用</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/libimobiledevice%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/libimobiledevice%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p></p><h5>libimobiledevice 是一个跨平台的软件库，支持 iPhone®, iPod Touch®, iPad® and Apple TV® 等设备的通讯协议。不依赖任何已有的私有库，不需要越狱。应用软件可以通过这个开发包轻松访问设备的文件系统、获取设备信息，备份和恢复设备，管理 SpringBoard 图标，管理已安装应用，获取通讯录、日程、备注和书签等信息，使用 libgpod 同步音乐和视频。<p></p><a id="more"></a><h2 id="2-安装方式"><a href="#2-安装方式" class="headerlink" title="2.安装方式"></a>2.安装方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install -HEAD libimobiledevice #安装最新的更新，支持 iOS 10</span><br><span class="line">brew install ideviceinstaller  # 仅在 iOS9工作</span><br></pre></td></tr></table></figure><h2 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3.常用命令"></a>3.常用命令</h2><h3 id="3-1-查看当前所连接的设备"><a href="#3-1-查看当前所连接的设备" class="headerlink" title="3.1 查看当前所连接的设备"></a>3.1 查看当前所连接的设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MacBookPro:~ lemon$ idevice_id -l # 显示当前所连接的设备[udid]，包括 usb、WiFi 连接</span><br><span class="line">********c06e788b2d8dc60004a7015ce5dad782</span><br><span class="line">********9a816a4089bd28f4f2e63c57a8138c63</span><br><span class="line"></span><br><span class="line">instruments -s devices      # 列出设备包括模拟器、真机及 mac 电脑本身</span><br></pre></td></tr></table></figure><h3 id="3-2-安装应用"><a href="#3-2-安装应用" class="headerlink" title="3.2 安装应用"></a>3.2 安装应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ideviceinstaller -u [udid] -i [xxx.ipa] # 给指定连接的设备安装应用</span><br></pre></td></tr></table></figure><h3 id="3-3-卸载应用"><a href="#3-3-卸载应用" class="headerlink" title="3.3 卸载应用"></a>3.3 卸载应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ideviceinstaller -u [udid] -U [bundleId] # 给指定连接的设备卸载应用</span><br></pre></td></tr></table></figure><h3 id="3-4-查看设备已安装的应用"><a href="#3-4-查看设备已安装的应用" class="headerlink" title="3.4 查看设备已安装的应用"></a>3.4 查看设备已安装的应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ideviceinstaller -u [udid] -l                   # 指定设备，查看安装的第三方应用</span><br><span class="line">ideviceinstaller -u [udid] -l -o list_user      # 指定设备，查看安装的第三方应用</span><br><span class="line">ideviceinstaller -u [udid] -l -o list_system    # 指定设备，查看安装的系统应用</span><br><span class="line">ideviceinstaller -u [udid] -l -o list_all       # 指定设备，查看安装的系统应用和第三方应用</span><br></pre></td></tr></table></figure><h3 id="3-5-获取设备信息"><a href="#3-5-获取设备信息" class="headerlink" title="3.5  获取设备信息"></a>3.5  获取设备信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ideviceinfo -u [udid]                       # 指定设备，获取设备信息</span><br><span class="line">ideviceinfo -u [udid] -k DeviceName         # 指定设备，获取设备名称：iPhone6s</span><br><span class="line">idevicename -u [udid]                       # 指定设备，获取设备名称：iPhone6s</span><br><span class="line">ideviceinfo -u [udid] -k ProductVersion     # 指定设备，获取设备版本：10.3.1</span><br><span class="line">ideviceinfo -u [udid] -k ProductType        # 指定设备，获取设备类型：iPhone8,1</span><br><span class="line">ideviceinfo -u [udid] -k ProductName        # 指定设备，获取设备系统名称：iPhone OS</span><br></pre></td></tr></table></figure></h5>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>logos基础语法</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/logos%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/logos%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Logos-语法"><a href="#Logos-语法" class="headerlink" title="Logos 语法"></a>Logos 语法</h1><ol><li><p>%hook className 指定需要hook的class，必须以end结尾 如：hook了系统界面的home按钮按下方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">- (void)_munuButtonDown:(id)down&#123;</span><br><span class="line">   NSLog(@&quot;You are press the home button&quot;);</span><br><span class="line">   %orig;//call the original _menuButton</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>%log 打印日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%log((NSString *)@&quot;iOSRE&quot;, (NSString *)@&quot;Debug&quot;);</span><br></pre></td></tr></table></figure></li><li><p>%orig 执行原始代码，必须在%hook里面使用，如果在hook方法里面不增加这一行代码，那么原始函数不会被调用。另外还可以用该函数修改原始函数的参数。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%hook SBLockScreenDateViewController</span><br><span class="line">//以下方法设置锁屏界面的日期的文字，改成了lemon love well</span><br><span class="line">- (void)setCustomSubtitleText:(id)arg1 withColor:(id)arg2</span><br><span class="line">&#123;</span><br><span class="line">   %orig(@&quot;Lemon love Well&quot;,arg2);</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure></li><li><p>%group 用户将%hook分组，便于代码管理和条件初始化分组，必须以%end结尾，一个%group可以包括多个%hook，如果一个%hook不在一个%group里面，那么这个%hook属于%group_ungrouped。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%group iOS7Hook</span><br><span class="line">%hook iOS7Class</span><br><span class="line">- (id)iOS7Method&#123;</span><br><span class="line">id result = %orig;</span><br><span class="line">NSLog(@&quot;This class &amp; method only exist in iOS</span><br><span class="line">7.&quot;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line">%end</span><br><span class="line">%group iOS8Hook</span><br><span class="line">%hook iOS8Class</span><br><span class="line">- (id)iOS8Method&#123;</span><br><span class="line">id result = %orig;</span><br><span class="line">NSLog(@&quot;This class &amp; method only exist in iOS</span><br><span class="line">8.&quot;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line">%end</span><br></pre></td></tr></table></figure></li><li><p>%init 值得注意的是，每个%group必须配合下面的%init使用才能生效，该指令用户初始化一个%group，必须在%hook里面调用或者%ctor里面调用。如果带参数，那么初始化指定的group，如果不带参数，那么初始化_ungrouped。如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#ifndef kCFCoreFoundationVersionNumber_iOS_8_0</span><br><span class="line">#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10</span><br><span class="line">#endif</span><br><span class="line">%hook SpringBoard</span><br><span class="line">- (void)applicationDidFinishLaunching:(id)application</span><br><span class="line">&#123;</span><br><span class="line">%orig;</span><br><span class="line">%init; // Equals to %init(_ungrouped)</span><br><span class="line">if (kCFCoreFoundationVersionNumber &gt;=</span><br><span class="line">kCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp;</span><br><span class="line">kCFCoreFoundationVersionNumber &lt;</span><br><span class="line">kCFCoreFoundationVersionNumber_iOS_8_0)          %init(iOS7Hook);//init iOS7Hook group</span><br><span class="line">if (kCFCoreFoundationVersionNumber &gt;=</span><br><span class="line">kCFCoreFoundationVersionNumber_iOS_8_0) %init(iOS8Hook);</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure></li><li><p>%ctor，tweak的constructor，完成初始化工作，如果不显式定义，theos会自动生成一个%ctor，并在里面调用%init(_ungrouped)。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//以下代码段可以生效，因为theos隐式调用了%ctor并且%init(_ungroped)</span><br><span class="line">%hook SpringBoard</span><br><span class="line">- (void)reboot</span><br><span class="line">&#123;</span><br><span class="line">   NSLog(@&quot;If rebooting does not word then i screwed&quot;);</span><br><span class="line">   %orig;//call origin method</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line">//以下代码段不能生效，虽然显式定义了%ctor，但是没有在里面调用%init方法</span><br><span class="line">%hook SpringBoard</span><br><span class="line">   - (void)reboot</span><br><span class="line">&#123;</span><br><span class="line">   NSLog(@&quot;If rebooting does not word then i screwed&quot;);</span><br><span class="line">   %orig;//call origin method</span><br><span class="line">&#125;</span><br><span class="line">%ctor&#123;</span><br><span class="line">   //need to call %init here.</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>%new在%hook内部使用，给一个现有的class添加新的函数，功能与class_addMethod一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">%new </span><br><span class="line">- (void)createNewMethod</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;This is a new method&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>%c 该指令的作用等同于NSClassFromString()或者obj_getClass()动态获取一个类的定义，在%hook或者%ctor内使用。</p></li></ol>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logos </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS适配国际化(跟随系统切换和应用内切换)</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%80%82%E9%85%8D%E5%9B%BD%E9%99%85%E5%8C%96-%E8%B7%9F%E9%9A%8F%E7%B3%BB%E7%BB%9F%E5%88%87%E6%8D%A2%E5%92%8C%E5%BA%94%E7%94%A8%E5%86%85%E5%88%87%E6%8D%A2/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%80%82%E9%85%8D%E5%9B%BD%E9%99%85%E5%8C%96-%E8%B7%9F%E9%9A%8F%E7%B3%BB%E7%BB%9F%E5%88%87%E6%8D%A2%E5%92%8C%E5%BA%94%E7%94%A8%E5%86%85%E5%88%87%E6%8D%A2/</url>
      <content type="html"><![CDATA[<blockquote><p>在开发中我们的APP可能会有海外的版本，可能APP需要匹配英语，俄语，日语等等，这个时候就要做国际化的匹配处理，但是国际化适配也分两种情况，一种是根据iPhone系统语言自动切换界面语言，另外一种是在APP内选择语言，直接刷新APP的界面。下面我会分别介绍这两种情况。<a href="https://github.com/codemonkeybulucck/LocalizableDemo.git" target="_blank" rel="noopener">Demo在这里</a></p></blockquote><a id="more"></a><h2 id="第一种情况，比较简单的跟随系统语言自动切换。这种情况主要使用的是系统提供给我们的一个宏"><a href="#第一种情况，比较简单的跟随系统语言自动切换。这种情况主要使用的是系统提供给我们的一个宏" class="headerlink" title="第一种情况，比较简单的跟随系统语言自动切换。这种情况主要使用的是系统提供给我们的一个宏"></a>第一种情况，比较简单的跟随系统语言自动切换。这种情况主要使用的是系统提供给我们的一个宏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define NSLocalizedString(key, comment) \</span><br><span class="line">    [NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:nil]</span><br></pre></td></tr></table></figure><p>key的作用是去localizable.strings文件里面根据这个key去匹配文本内容，然后返回。如果用了这个宏，因为实际上调用的是 <code>[NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:nil]</code> 这个方法，table为nil代表默认去Localizable.strings里面找，所以当创建strings文件的时候命名必须为Localizable,如果strings命名为其他名字，那么要用 <code>#define NSLocalizedStringFromTable(key, tbl, comment)</code>指定table的名字为strings的文件名字。<br>以上是基本的介绍。</p><h3 id="下面开始说说开发步骤："><a href="#下面开始说说开发步骤：" class="headerlink" title="下面开始说说开发步骤："></a>下面开始说说开发步骤：</h3><p>1.首先需要在项目中增加需要匹配的语言</p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-7681990a7fc5939d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20170608-104014.png"></p><p>如我需要匹配的语言是简体中文和英语。<br>2.创建Localizable.strings文件</p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-64952a4b48db1030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20170608-104053.png"><br>创建完成后点击该文件，然后在右侧面板的点击Localization 选择English和Chinese，然后就会生成以下两个文件<br><img src="http://upload-images.jianshu.io/upload_images/2269918-cd15913998ecf15b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20170608-104133.png"></p><h3 id="Localizable-strings-English-代表当系统语言是中文的时候，会来到这个文件根据key匹配text"><a href="#Localizable-strings-English-代表当系统语言是中文的时候，会来到这个文件根据key匹配text" class="headerlink" title="Localizable.strings(English)代表当系统语言是中文的时候，会来到这个文件根据key匹配text"></a>Localizable.strings(English)代表当系统语言是中文的时候，会来到这个文件根据key匹配text</h3><h4 id="Localizable-strings-Simplified-代表当系统语言是英文的时候，会来到这个文件根据key匹配text。"><a href="#Localizable-strings-Simplified-代表当系统语言是英文的时候，会来到这个文件根据key匹配text。" class="headerlink" title="Localizable.strings(Simplified)代表当系统语言是英文的时候，会来到这个文件根据key匹配text。"></a>Localizable.strings(Simplified)代表当系统语言是英文的时候，会来到这个文件根据key匹配text。</h4><p>以下是两个文件的内容：</p><h3 id="Localizable-strings-English"><a href="#Localizable-strings-English" class="headerlink" title="Localizable.strings(English)"></a>Localizable.strings(English)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;LoginButtonText&quot;=&quot;Login&quot;;</span><br><span class="line">&quot;LabelText&quot;=&quot;The language of System is English now&quot;;</span><br></pre></td></tr></table></figure><h3 id="Localizable-strings-Chinese-simplified"><a href="#Localizable-strings-Chinese-simplified" class="headerlink" title="Localizable.strings(Chinese(simplified))"></a>Localizable.strings(Chinese(simplified))</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;LoginButtonText&quot;=&quot;登陆&quot;;</span><br><span class="line">&quot;LabelText&quot;=&quot;现在系统的语言是中文&quot;;</span><br></pre></td></tr></table></figure><p>3.使用NSLocalizedString(key,comment) 宏来赋值<br>在前面已经说了这个宏的作用了，在我的demo中我给button和label设置text。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[button setTitle:NSLocalizedString(@&quot;LoginButtonText&quot;, @&quot;&quot;) forState:UIControlStateNormal];</span><br><span class="line">    label.text = NSLocalizedString(@&quot;LabelText&quot;, @&quot;&quot;);</span><br></pre></td></tr></table></figure></p><p>最后去设置里面切换语言就能看到效果。</p><h2 id="第二种情况，像微博或者微信可以在应用的语言设置里面直接设置本APP的语言，这种设置不会影响其他APP，只是本APP的一种行为，主要是利用NSUserDefault来保存本地自定的语言的值，如en-zh-hans等，然后通过读取这个值来加载对应的lproj文件，然后再生成对应的bundle，每个bundle下面就会放着每个table的stings文件。"><a href="#第二种情况，像微博或者微信可以在应用的语言设置里面直接设置本APP的语言，这种设置不会影响其他APP，只是本APP的一种行为，主要是利用NSUserDefault来保存本地自定的语言的值，如en-zh-hans等，然后通过读取这个值来加载对应的lproj文件，然后再生成对应的bundle，每个bundle下面就会放着每个table的stings文件。" class="headerlink" title="第二种情况，像微博或者微信可以在应用的语言设置里面直接设置本APP的语言，这种设置不会影响其他APP，只是本APP的一种行为，主要是利用NSUserDefault来保存本地自定的语言的值，如en,zh-hans等，然后通过读取这个值来加载对应的lproj文件，然后再生成对应的bundle，每个bundle下面就会放着每个table的stings文件。"></a>第二种情况，像微博或者微信可以在应用的语言设置里面直接设置本APP的语言，这种设置不会影响其他APP，只是本APP的一种行为，主要是利用NSUserDefault来保存本地自定的语言的值，如en,zh-hans等，然后通过读取这个值来加载对应的lproj文件，然后再生成对应的bundle，每个bundle下面就会放着每个table的stings文件。</h2><h3 id="话不多说，以下是开发步骤："><a href="#话不多说，以下是开发步骤：" class="headerlink" title="话不多说，以下是开发步骤："></a>话不多说，以下是开发步骤：</h3><p>1.和第一种情况一样，首先需要在项目中增加需要匹配的语言<br><img src="http://upload-images.jianshu.io/upload_images/2269918-7681990a7fc5939d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20170608-104014.png"></p><p>2.创建.strings文件，这里和第一种情况不太一样的是，这里你可以任意指定一个名字，如FirstTabBarItem.strings 来放置tabbar的第一个item的多语言文件，SecondTabBarItem.strings 来放置tabbar的第二个item的多语言文件，这里可以灵活处理。创建完strings文件之后，还是和之前一样点击Localization。然后选择你要适配的语言，生成文件。</p><p>3.第三步创建一个LocalizableHelper 的类，这个类的作用是提供一个让外界根据key和table来获取文本的宏，当设置成功之后就会发出一个通知，接受者只需要监听这个通知然后更新必要界面就可以了。具体请看<a href="https://github.com/codemonkeybulucck/LocalizableDemo.git" target="_blank" rel="noopener">demo</a>，里面已经写了所有步骤的注释。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS 国际化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS SDK利用Aggregate打包动态库和静态库</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS-SDK%E5%88%A9%E7%94%A8Aggregate%E6%89%93%E5%8C%85%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS-SDK%E5%88%A9%E7%94%A8Aggregate%E6%89%93%E5%8C%85%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/</url>
      <content type="html"><![CDATA[<blockquote><p>前言：可能做SDK的iOS开发者都体验过打包动态库或者静态库的时候那些繁琐的步骤，需要分别选择真机和模拟器来编译，最后还要用命令行将他们合并起来，每次都这样打包的话特别麻烦。但是我们可以使用Aggregate的脚本来自动打包。</p></blockquote><a id="more"></a><h2 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h2><p>新建一个target,选择cross-platform的Aggregate，如下图<br><img src="http://upload-images.jianshu.io/upload_images/2269918-95f30fdbd0120257.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><h2 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h2><p>创建完Aggregate之后，增加一个run script，具体步骤为，选中刚刚创建的Aggregate target,然后在build phases 下面点击加号，选择 new run script phase<br><img src="http://upload-images.jianshu.io/upload_images/2269918-974c8e93ac6449ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p><h2 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h2><p>在图中红色框框标注的地方输入以下脚本<br><img src="http://upload-images.jianshu.io/upload_images/2269918-cb9318bf8185f24e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p><h2 id="如果要生成-a后缀的静态库，那么使用以下脚本"><a href="#如果要生成-a后缀的静态库，那么使用以下脚本" class="headerlink" title="如果要生成.a后缀的静态库，那么使用以下脚本"></a>如果要生成.a后缀的静态库，那么使用以下脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">set -e</span><br><span class="line"># Sets the target folders and the final framework product.</span><br><span class="line"># 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME</span><br><span class="line"># 例如: FMK_NAME=&quot;MyFramework&quot;</span><br><span class="line">FMK_NAME=&quot;IDMPCMCC&quot;</span><br><span class="line"># Install dir will be the final output to the framework.</span><br><span class="line"># The following line create it in the root folder of the current project.</span><br><span class="line"># 获取当前时间</span><br><span class="line">DATE=$(date +%Y%m%d-%H:%M:%S)</span><br><span class="line"># 定义IDMPCMCC+当前时间 命名的文件夹名字</span><br><span class="line">INSTALL_DIR=$&#123;HOME&#125;/Desktop/IDMPCMCC$&#123;DATE&#125;</span><br><span class="line"># 支持真机静态库所在的路径</span><br><span class="line">DEVICE_DIR=$&#123;BUILD_DIR&#125;/Release-iphoneos/</span><br><span class="line"># 支持模拟器静态库所在的路径</span><br><span class="line">SIMULATOR_DIR=$&#123;BUILD_DIR&#125;/Release-iphonesimulator/</span><br><span class="line"># -configuration $&#123;CONFIGURATION&#125;</span><br><span class="line"># Clean and Building both architectures.</span><br><span class="line"># 配置生成静态库一些参数</span><br><span class="line">xcodebuild build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot; -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphoneos clean build ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION</span><br><span class="line">xcodebuild build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot;  -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphonesimulator clean build ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION</span><br><span class="line"># Cleaning the oldest.</span><br><span class="line">if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]</span><br><span class="line">then</span><br><span class="line">rm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">fi</span><br><span class="line">mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;</span><br><span class="line"># Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.</span><br><span class="line"># 合并真机和模拟器架构静态库</span><br><span class="line">lipo -create &quot;$&#123;DEVICE_DIR&#125;/lib$&#123;FMK_NAME&#125;.a&quot; &quot;$&#123;SIMULATOR_DIR&#125;/lib$&#123;FMK_NAME&#125;.a&quot; -output &quot;$&#123;INSTALL_DIR&#125;/lib$&#123;FMK_NAME&#125;.a&quot;</span><br><span class="line"></span><br><span class="line">open &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="如果要生成-framework的静态库或者动态库的话，使用以下脚本"><a href="#如果要生成-framework的静态库或者动态库的话，使用以下脚本" class="headerlink" title="如果要生成.framework的静态库或者动态库的话，使用以下脚本"></a>如果要生成.framework的静态库或者动态库的话，使用以下脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">set -e</span><br><span class="line"># Sets the target folders and the final framework product.</span><br><span class="line"># 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME</span><br><span class="line"># 例如: FMK_NAME=&quot;MyFramework&quot;</span><br><span class="line">FMK_NAME=&quot;IDMPCMCC&quot;</span><br><span class="line"># Install dir will be the final output to the framework.</span><br><span class="line"># The following line create it in the root folder of the current project.</span><br><span class="line"># 获取当前时间</span><br><span class="line">DATE=$(date +%Y%m%d-%H:%M:%S)</span><br><span class="line"># 定义IDMPCMCC+当前时间 命名的文件夹名字</span><br><span class="line">INSTALL_DIR=$&#123;HOME&#125;/Desktop/IDMPCMCC$&#123;DATE&#125;/$&#123;FMK_NAME&#125;.framework</span><br><span class="line">DEVICE_DIR=$&#123;BUILD_DIR&#125;/Release-iphoneos/$&#123;FMK_NAME&#125;.framework</span><br><span class="line">SIMULATOR_DIR=$&#123;BUILD_DIR&#125;/Release-iphonesimulator/$&#123;FMK_NAME&#125;.framework</span><br><span class="line"># -configuration $&#123;CONFIGURATION&#125;</span><br><span class="line"># Clean and Building both architectures.</span><br><span class="line">xcodebuild build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot;  -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphoneos clean build ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION</span><br><span class="line">xcodebuild build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot; -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphonesimulator clean build ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION</span><br><span class="line"># Cleaning the oldest.</span><br><span class="line">if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]</span><br><span class="line">then</span><br><span class="line">rm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">fi</span><br><span class="line">mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;</span><br><span class="line"># Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.</span><br><span class="line">lipo -create &quot;$&#123;DEVICE_DIR&#125;/$&#123;FMK_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;/$&#123;FMK_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;/$&#123;FMK_NAME&#125;&quot;</span><br><span class="line"></span><br><span class="line">open &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br></pre></td></tr></table></figure><p><code>build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot;</code>这一句代码是用来开启bitcode</p><h2 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h2><p>选择创建的Aggregate运行即可。<br><img src="http://upload-images.jianshu.io/upload_images/2269918-f690c4f4ec8531ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDK </tag>
            
            <tag> Aggregate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS链式编程实(仿Masonry框架)</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E-%E4%BB%BFMasonry%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E-%E4%BB%BFMasonry%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<blockquote><p>前言： 相信做过iOS开发的都知道系统给开发者提供的代码设置约束有多难用，设置一个元素的位置往往要写十多行的代码，因为NSLayoutConstraint这个类是在太难用了。所以一个简单的代码布局框架就会很受开发者欢迎。所以也有了这次实践，通过链式编程实现简单的自动布局。下面也是模仿<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a>做一套自己的自动布局框架。</p></blockquote><a id="more"></a><h1 id="1-先看看我们最终实现同样的效果的代码对比"><a href="#1-先看看我们最终实现同样的效果的代码对比" class="headerlink" title="1.先看看我们最终实现同样的效果的代码对比"></a>1.先看看我们最终实现同样的效果的代码对比</h1><h2 id="1-1使用系统代码设置约束"><a href="#1-1使用系统代码设置约束" class="headerlink" title="1.1使用系统代码设置约束"></a>1.1使用系统代码设置约束</h2><pre><code>greenView.translatesAutoresizingMaskIntoConstraints = NO;[superview addConstraints:@[                            //greenView constraints                            [NSLayoutConstraint constraintWithItem:greenView                                                         attribute:NSLayoutAttributeTop                                                         relatedBy:NSLayoutRelationEqual                                                            toItem:superview                                                         attribute:NSLayoutAttributeTop                                                        multiplier:1.0                                                          constant:20],                            [NSLayoutConstraint constraintWithItem:greenView                                                         attribute:NSLayoutAttributeLeft                                                         relatedBy:NSLayoutRelationEqual                                                            toItem:superview                                                         attribute:NSLayoutAttributeLeft                                                        multiplier:1.0                                                          constant:20],                            [NSLayoutConstraint constraintWithItem:greenView                                                         attribute:NSLayoutAttributeBottom                                                         relatedBy:NSLayoutRelationEqual                                                            toItem:nil                                                         attribute:NSLayoutAttributeNotAnAttribute                                                        multiplier:1.0                                                          constant:80],                            [NSLayoutConstraint constraintWithItem:greenView                                                         attribute:NSLayoutAttributeRight                                                         relatedBy:NSLayoutRelationEqual                                                            toItem:superview                                                         attribute:NSLayoutAttributeNotAnAttribute                                                        multiplier:1                                                          constant:80],                            ]];</code></pre><h2 id="1-2使用链式编程实现约束"><a href="#1-2使用链式编程实现约束" class="headerlink" title="1.2使用链式编程实现约束"></a>1.2使用链式编程实现约束</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[greenView makeLayout:^void(LMLayout *layout) &#123;</span><br><span class="line">      layout.width.equalTo(@(80));</span><br><span class="line">      layout.height.equalTo(@80);</span><br><span class="line">      layout.left.equalTo(self.view.lm_left).offSet(20);</span><br><span class="line">      layout.top.equalTo(self.view.lm_top).offSet(20);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><h1 id="2-以上的代码缩减了这么多主要是因为将复杂的方法调用用链式的方式实现出来了，那么什么是链式编程呢？"><a href="#2-以上的代码缩减了这么多主要是因为将复杂的方法调用用链式的方式实现出来了，那么什么是链式编程呢？" class="headerlink" title="2.以上的代码缩减了这么多主要是因为将复杂的方法调用用链式的方式实现出来了，那么什么是链式编程呢？"></a>2.以上的代码缩减了这么多主要是因为将复杂的方法调用用链式的方式实现出来了，那么什么是链式编程呢？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout.left.equalTo(self.view.lm_left).offSet(20);</span><br></pre></td></tr></table></figure><pre><code>以这句代码为例，可以通过点语法一直不断的调用下一个方法，像一条链子一样，这样的方式就叫做链式编程。</code></pre><p>那么在代码层面，如何可以实现一直不断的通过点语法调用下一个方法。<br>实质上就是通过点语法调用方法的时候，返回一个block。而这个block必须需要包涵一个很重要的特点，这个block有返回值，这个返回值的类型是一个调用下一个方法的对象，这样下次又可以通过这个对象执行下一个方法。代码示例为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(LMLayout *(^)(NSObject *object))equalTo;</span><br></pre></td></tr></table></figure></p><p>上述代码返回了一个(LMLayout <em>(^)(NSObject </em>object)block,该block返回了一个LMLayout对象，以便后面可以继续调用下一个方法，然后接受输入一个object的参数，该参数可以用来设置内部的约束的值。</p><h1 id="3-基于以上的了解，我们开始着手写一个仿masonry的框架。"><a href="#3-基于以上的了解，我们开始着手写一个仿masonry的框架。" class="headerlink" title="3.基于以上的了解，我们开始着手写一个仿masonry的框架。"></a>3.基于以上的了解，我们开始着手写一个仿masonry的框架。</h1><p>以下使我们最终要实现的调用方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[greenView makeLayout:^void(LMLayout *layout) &#123;</span><br><span class="line">      layout.width.equalTo(@(80));</span><br><span class="line">      layout.height.equalTo(@80);</span><br><span class="line">      layout.left.equalTo(self.view.lm_left).offSet(20);</span><br><span class="line">      layout.top.equalTo(self.view.lm_top).offSet(20);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure></p><h2 id="3-1先从外层的方法看起，首先给UIView创建了一个分类，并且定义了一个makeLayout的方法，需要传进一个block的参数，该block的作用就是设置greenView的约束。所以最外层的方法就是"><a href="#3-1先从外层的方法看起，首先给UIView创建了一个分类，并且定义了一个makeLayout的方法，需要传进一个block的参数，该block的作用就是设置greenView的约束。所以最外层的方法就是" class="headerlink" title="3.1先从外层的方法看起，首先给UIView创建了一个分类，并且定义了一个makeLayout的方法，需要传进一个block的参数，该block的作用就是设置greenView的约束。所以最外层的方法就是"></a>3.1先从外层的方法看起，首先给UIView创建了一个分类，并且定义了一个makeLayout的方法，需要传进一个block的参数，该block的作用就是设置greenView的约束。所以最外层的方法就是</h2><p>UIView+layout.h 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)makeLayout:(void(^)(LMLayout *layout))layoutBlock;</span><br></pre></td></tr></table></figure></p><p>UIView+layout.m文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)makeLayout:(void(^)(LMLayout *layout))layoutBlock&#123;</span><br><span class="line">    LMLayout *layout = [[LMLayout alloc]initWithView:self];</span><br><span class="line">    layoutBlock(layout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在以上的方法中，创建了一个LMLayout的对象，并且将当前的view作为参数去初始化LMLayout对象。接下来看看一些LMLayout的初始化方法的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithView:(UIView *)view&#123;</span><br><span class="line">    NSAssert([view superview]!=nil, @&quot;未能找到view的superView&quot;);</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _view = view;</span><br><span class="line">        view.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在初始化方法内部会判断当前设置约束的view是否有superView，并且用属性保存当前传进来的view，关闭translatesAutoresizingMaskIntoConstraints。<br>再返回到上一个方法，初始化完成之后就执行该block，将初始化好的layout对象传过去。</p><h2 id="3-2-接下来看block内部的调用"><a href="#3-2-接下来看block内部的调用" class="headerlink" title="3.2 接下来看block内部的调用"></a>3.2 接下来看block内部的调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout.width.equalTo(@(80));</span><br></pre></td></tr></table></figure><p>一层一层分析，layout.width实质上是调用了-(LMLayout*)width; 看看该方法内部的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(LMLayout*)width&#123;</span><br><span class="line">    _property = PropertyTypeWidth;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PropertyTypeWidth 是一个枚举值，表示当前设置约束的属性是width，然后返回当前layout对象。<br>既然返回了layout对象，那么同样可以通过点执行下一个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout.equalTo(@(80))</span><br></pre></td></tr></table></figure></p><p>同样看一下方法的定义和实现<br>.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(LMLayout *(^)(NSObject *object))equalTo;</span><br></pre></td></tr></table></figure></p><p>.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">-(LMLayout *(^)(NSObject *object))equalTo&#123;</span><br><span class="line">    __weak typeof(self)weakSelf = self;</span><br><span class="line">    return ^(NSObject *object)&#123;</span><br><span class="line">        //判断外部调用equalTo()这个block的时候会传什么值</span><br><span class="line">        //如果是直接设置属性的值</span><br><span class="line">        if ([object isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">            CGFloat floatValue = [(NSNumber*)object floatValue];</span><br><span class="line">            NSLayoutAttribute attribute = NSLayoutAttributeHeight;</span><br><span class="line">            switch (weakSelf.property) &#123;</span><br><span class="line">                case PropertyTypeWidth:</span><br><span class="line">                    attribute = NSLayoutAttributeWidth;</span><br><span class="line">                    break;</span><br><span class="line">                case PropertyTypeHeight:</span><br><span class="line">                    attribute = NSLayoutAttributeHeight;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    attribute = NSLayoutAttributeNotAnAttribute;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:weakSelf.view attribute:attribute relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:floatValue];</span><br><span class="line">            //检测之前是否已经设置了旧的同一属性的约束，如果是就删除，添加新的约束</span><br><span class="line">            [weakSelf checkIfExistOldLayoutWithNewLayout:constraint];</span><br><span class="line">            [weakSelf.view addConstraint:constraint];</span><br><span class="line">        &#125;</span><br><span class="line">        //如果是设置一个参照view</span><br><span class="line">        else if([object isKindOfClass:[NSDictionary class]])&#123;</span><br><span class="line">            NSDictionary *dict = (NSDictionary*)object;</span><br><span class="line">            UIView *view = (UIView *)dict[@&quot;view&quot;];</span><br><span class="line">            weakSelf.conferenceView = view;</span><br><span class="line">            weakSelf.conferProperty = [dict[@&quot;property&quot;] floatValue];</span><br><span class="line">            NSLayoutAttribute attribute = [LMLayout attributeWithProperty:weakSelf.property];</span><br><span class="line">            NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:weakSelf.view attribute:attribute relatedBy:NSLayoutRelationEqual toItem:weakSelf.conferenceView attribute:weakSelf.conferProperty multiplier:1 constant:0];</span><br><span class="line">            //检测之前是否已经设置了旧的同一属性的约束，如果是就删除，添加新的约束</span><br><span class="line">            [weakSelf checkIfExistOldLayoutWithNewLayout:constraint];</span><br><span class="line">            weakSelf.currentConstraint = constraint;</span><br><span class="line">            [weakSelf.view.superview addConstraint:constraint];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>上述方法首先返回一个返回值类型为LMLayout，参数类型型为NSObject对象的Block，为什么是NSObject对象类型，因为equalTo有可能会直接传入一个数值，也有可能会传入一个view的属性，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout.height.equalTo(@80);</span><br><span class="line">layout.left.equalTo(self.view.lm_left).offSet(20);</span><br></pre></td></tr></table></figure></p><h3 id="3-2-1-首先看传进来的是一个数值的情况"><a href="#3-2-1-首先看传进来的是一个数值的情况" class="headerlink" title="3.2.1 首先看传进来的是一个数值的情况"></a>3.2.1 首先看传进来的是一个数值的情况</h3><p>如果传进来是一个数值，那么会判断之前是否已经设置过该约束，如果已经设置过就删除该约束，重新添加新的约束。</p><h4 id="3-2-2-如果是-equalTo-self-view-lm-left-这种形式，括号内的self-view-lm-left实质上是执行了UIView的分类的"><a href="#3-2-2-如果是-equalTo-self-view-lm-left-这种形式，括号内的self-view-lm-left实质上是执行了UIView的分类的" class="headerlink" title="3.2.2 如果是.equalTo(self.view.lm_left)这种形式，括号内的self.view.lm_left实质上是执行了UIView的分类的"></a>3.2.2 如果是.equalTo(self.view.lm_left)这种形式，括号内的self.view.lm_left实质上是执行了UIView的分类的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(NSDictionary&lt;UIView *,NSNumber *&gt;*)lm_left;</span><br></pre></td></tr></table></figure><p>.m文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(NSDictionary&lt;UIView *,NSNumber *&gt;*)lm_left&#123;</span><br><span class="line">    return [self dictWithProperty:PropertyTypeLeft];</span><br><span class="line">&#125;</span><br><span class="line">- (NSDictionary&lt;UIView *,NSNumber *&gt;*)dictWithProperty:(PropertyType)type&#123;</span><br><span class="line">    NSDictionary *dict = @&#123;@&quot;view&quot;:self,@&quot;property&quot;:@([LMLayout attributeWithProperty:type])&#125;;</span><br><span class="line">    return dict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法内部会返回一个字典，字典的第一个参数表示需要参照的view，第二个参数表示的参照view的哪个属性。<br>当接收到返回的字典之后，因为之前已经获取了需要约束的view和需要约束的属性，现在也获取了参照的view和参照的属性，可以创建NSLayoutConstraint对象，并且添加约束到他们共同的superView上面。</p><h2 id="3-3-下面来关注一下offset-20"><a href="#3-3-下面来关注一下offset-20" class="headerlink" title="3.3 下面来关注一下offset(20)"></a>3.3 下面来关注一下offset(20)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout.left.equalTo(self.view.lm_left).offSet(20);</span><br></pre></td></tr></table></figure><p>.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void(^LayoutOffsetBlock)(CGFloat offset))offSet;</span><br></pre></td></tr></table></figure></p><p>.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(void(^LayoutOffsetBlock)(CGFloat offset))offSet&#123;</span><br><span class="line"> __weak typeof(self)weakSelf = self;</span><br><span class="line">    return ^(CGFloat margin)&#123;</span><br><span class="line">        NSLayoutAttribute attribute = [LMLayout attributeWithProperty:weakSelf.property];</span><br><span class="line">        NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:weakSelf.view attribute:attribute relatedBy:NSLayoutRelationEqual toItem:weakSelf.conferenceView attribute:weakSelf.conferProperty multiplier:1 constant:margin];</span><br><span class="line">        if (weakSelf.currentConstraint.firstItem == constraint.firstItem &amp;&amp; weakSelf.currentConstraint.firstAttribute == constraint.firstAttribute &amp;&amp; weakSelf.currentConstraint.secondItem == constraint.secondItem &amp;&amp; weakSelf.currentConstraint.secondAttribute == constraint.secondAttribute) &#123;</span><br><span class="line">            weakSelf.currentConstraint.constant = margin;</span><br><span class="line">            //[weakSelf.view.superview removeConstraint:weakSelf.currentConstraint];</span><br><span class="line">           // [weakSelf.view.superview addConstraint:constraint];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法内部首先会根据枚举值拿到对应的NSLayoutAttribute，然后判断是否已经设置了该约束，如果是，那么直接修改该约束的值。</p><h1 id="4-设置其他约束的方法都和上述类似。相关的源码已经上传到LMlayout，具体可以查看github"><a href="#4-设置其他约束的方法都和上述类似。相关的源码已经上传到LMlayout，具体可以查看github" class="headerlink" title="4 设置其他约束的方法都和上述类似。相关的源码已经上传到LMlayout，具体可以查看github."></a>4 设置其他约束的方法都和上述类似。相关的源码已经上传到<a href="https://github.com/codemonkeybulucck/LMLayout.git" target="_blank" rel="noopener">LMlayout</a>，具体可以查看github.</h1>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链式编程 </tag>
            
            <tag> masonry </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用xcode7创建静态库和动态库的完整过程</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8xcode7%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8xcode7%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>1、创建项目<br>     首先先创建一个简单的iOS项目用来测试SDK,创建完成项目结构如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-2d001ae1cb482cf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_2.png"></p><pre><code>点击项目名称，在右侧Target选项中点击加号，在选择面板中选择cocoa touch framework，然后点击next.然后填写SDK的名字，然后点击finish.最后targets选项的项目如下图所示：其中最下面的SDK就是我创建的库。 </code></pre><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/2269918-4d405ac4ab0736c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_6.png"></p><p>2、编写framework的代码</p><pre><code>在你的framework文件夹下面右键add file,然后开始编码，这里就不细说了，和平时写的类一样，只是一定要保证你的文件是在你创建的framework里面.然后在.h头文件中提供给外界使用的方法属性等。 </code></pre><p>3、配置项目<br>       上面我们已经创建好了项目并且逻辑代码都写好了，接下来 需要对项目做一些配置，Let’s do it.<br>        首先对framework进行一些基本的设置，根据自身需要来设置，还是在targets选选中你的framework的名字，然后在buildsetting那里找到architectures设置支持的指令集，默认是没有支持armv7s的，所以我们要手动添加,点击右边的选项，然后选择other，然后在弹出框中点击下面的加号，然后添加 armv7s 。<br>最后添加完成如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-59032cb28bc05ea5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_12.png"></p><pre><code>设置iOS deployment target ，表示最低支持iOS的系统版本，根据个人情况来选择，一般如果是动态库，那么是8.0，如果是静态库是7.0。</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2269918-d818da50d7feb629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_14.png"></p><pre><code> 3.3设置静态库支持bitcode如下图所示：设置other c flag ,在release那里添加 -fembed-bitcode 。</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2269918-b36e816bdf656190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_15.png"></p><pre><code>如果要忽略一些警告，还可以在other warning flag那里输入一些值，具体可以[看这里](http://www.cocoachina.com/ios/20141218/10678.html)。</code></pre><p>因为你正在创建framework供他人使用，最好禁掉这些功能（无效代码和debug用符号），让用户自己选择对自己的项目有利的部分使用。和之前一样，使用搜索框，改变下述设置：</p><p>Dead Code Stripping设置为NO<br>Strip Debug Symbol During Copy 全部设置为NO<br>Strip Style设置为Non-Global Symbols<br>如果使用了category ，则使用该FMWK的程序运行时会crash，此时需要在该工程中 other linker flags 添加两个参数  -ObjC -all_load<br>编译出Framework是，需要把 GenerateDebugSymbols ＝NO，否则会出现很多 warning:例如 .pcm not such file or directory</p><pre><code>设置framework为动态库或者静态库。Dynamic library为动态库，Static library为静态库。</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2269918-bc8e490d8dfce2db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_17.png"></p><pre><code>然后切换到Build Phases选项卡中，打开headers,将你要提供给外界使用的头文件暴露出来，默认该文件都是在Project里面的</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2269918-92591c752e446d3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_20.png"></p><pre><code>然后将要供外界使用的头文件拖拽到public下面。</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2269918-79313d39dd49ec9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_21.png"></p><p>   到这里framework的的设置就完成了，接下来可以设置项目来使用framework。</p><p>4、项目引用framework<br>   在左上角的导航栏那里选择刚开始创建的测试项目，然后选择edit scheme</p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-ab5090e09a8d52ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_23.png"></p><p>   在Run选项那里，点击右侧下面的加号，然后在弹出面板选择我们创建的framework,点击<br>close。<br>   然后就可以在项目中引入头文件使用里面的类。</p><p>5.关于framework打包<br>   在左上角的导航栏那里选择创建的framework,然后点击edit scheme</p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-4211e1987ad9c783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_26.png"></p><p>然后在Run选项中，将build configuration 设置为release </p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-b67e5780656efc65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_28.png"></p><p>如果build的时候选择的是模拟器，那么编译出来的framework就是可以在模拟器上运行的，但是真机不行，如果想在真机使用，build的时候必须选择真机。</p><p>可以使用 lipo -info 来查看framework支持的cpu<br>可以使用lipo -create  来合并两个framework </p><p>需要注意的是，如果是使用了合并模拟器和真机结构的静态库，上传到app么没有问题，如果是使用了合并模拟器和真机结构的冬天库，archive的时候会报错，错误信息大致是不能包含用i386或者x86-64架构的framework，所以发布的时候记得使用真机版本的framework.</p><p>以上只是个人对于framework的一些探究，如果有什么纰漏或者错误的地方，欢迎指正。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDK </tag>
            
            <tag> 动态库 </tag>
            
            <tag> 静态库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS使用AMR进行编码和解码</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%BD%BF%E7%94%A8AMR%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%BD%BF%E7%94%A8AMR%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>在上一篇文章中将采样率为16K的amr的库编译出来了，并且已经放到github上面：<br> <a href="https://github.com/codemonkeybulucck/opencore-vo-amrwbenc-iOS" target="_blank" rel="noopener">vo-amrwbenc编译</a><br>然后我做了一个如何使用amr进行编码和解码的demo,demo里面主要包含了一个8K和16K的编解码，两种编解码方式使用的是不同的静态库，具体可以下载代码来看。<br><a href="https://github.com/codemonkeybulucck/opencore-amrDemo-iOS.git" target="_blank" rel="noopener">AMR编码和解码</a></p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMR </tag>
            
            <tag> wav </tag>
            
            <tag> 音频开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用opencore_amr实现wav转amr(8khz,16khz)</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8opencore-amr%E5%AE%9E%E7%8E%B0wav%E8%BD%ACamr-8khz-16khz/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8opencore-amr%E5%AE%9E%E7%8E%B0wav%E8%BD%ACamr-8khz-16khz/</url>
      <content type="html"><![CDATA[<blockquote><p>由于公司正在做声纹方面的开发，所以需要对语音数据做压缩，目前想到了三种压缩方式，1是AMR，2是Speex,3是Opus,这里先说第一种方式，在iOS4.0之前是可以进行amr格式的录音的，后来苹果取消了这个声音格式，但是可以使用opencore-amr来将wav格式转换为amr格式。</p></blockquote><a id="more"></a><blockquote><p>目前网上的例子大多数都是8Khz采样率的wav文件转AMR,具体可以参照<a href="http://my.oschina.net/jeans/blog/69937" target="_blank" rel="noopener">iOS音频格式之AMR和WAV互转(更新支持64位)</a>，这里也要感谢这篇博文的作者黄俊鹏，他给我提供了帮助我才找到了方法。但是我们公司由于对于声音采集样本的要求比较高，所以我们要使用16Khz的采样率，那么问题就出现了，在opencore-amr中并没有提供amr-wb的encode方法，8kHZ使用的opencore-amrnb.a的静态库，其中提供了encode和decode的方法，但是对于16Khz使用的是opencore-amrwb的静态库，其中里面只提供了decode的方法，后来通过其他资料我我才明白encode在另外一个项目vo-amrwbenc里面，如果要使用的话必须要单独编译这个项目才可以，项目下载可以看<a href="https://sourceforge.net/projects/opencore-amr/files/?source=navbar" target="_blank" rel="noopener">opencore-amr</a>，所以如果需要将16Khz wav文件转为amr文件，只需要编译这个库然后使用就可以了，如果要解码那么还是需要使用原来的opencore-amr库。</p></blockquote><p> #下面就可以编译vo-amrwebenc</p><h2 id="1-首先新建一个文件夹，将下载到的vo-amrwbenc-0-1-3-tar-gz压缩包放到里面，然后进入这个文件夹，在里面创建build-sh文件-将以下脚本粘贴到文件里面"><a href="#1-首先新建一个文件夹，将下载到的vo-amrwbenc-0-1-3-tar-gz压缩包放到里面，然后进入这个文件夹，在里面创建build-sh文件-将以下脚本粘贴到文件里面" class="headerlink" title="1.首先新建一个文件夹，将下载到的vo-amrwbenc-0.1.3.tar.gz压缩包放到里面，然后进入这个文件夹，在里面创建build.sh文件,将以下脚本粘贴到文件里面"></a>1.首先新建一个文件夹，将下载到的vo-amrwbenc-0.1.3.tar.gz压缩包放到里面，然后进入这个文件夹，在里面创建build.sh文件,将以下脚本粘贴到文件里面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">set -xe</span><br><span class="line"></span><br><span class="line">VERSION=&quot;0.1.3&quot;</span><br><span class="line"></span><br><span class="line">LIBSRCNAME=&quot;vo-amrwbenc&quot;</span><br><span class="line"></span><br><span class="line">CURRENTPATH=`pwd`</span><br><span class="line"></span><br><span class="line">mkdir -p &quot;$&#123;CURRENTPATH&#125;/src&quot;</span><br><span class="line"></span><br><span class="line">tar zxvf $&#123;LIBSRCNAME&#125;-$&#123;VERSION&#125;.tar.gz -C &quot;$&#123;CURRENTPATH&#125;/src&quot;</span><br><span class="line"></span><br><span class="line">cd &quot;$&#123;CURRENTPATH&#125;/src/$&#123;LIBSRCNAME&#125;-$&#123;VERSION&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 设置环境变量并创建lib-ios文件夹，后续生成的.a类库都会放在这个文件夹里边</span><br><span class="line"></span><br><span class="line">DEST=&quot;$&#123;CURRENTPATH&#125;/lib-ios&quot;</span><br><span class="line"></span><br><span class="line">mkdir -p &quot;$&#123;DEST&#125;&quot;</span><br><span class="line"></span><br><span class="line">ARCHS=&quot;armv7 armv7s arm64 i386 x86_64&quot;</span><br><span class="line"></span><br><span class="line">LIBS=&quot;libvo-amrwbenc.a&quot;</span><br><span class="line"></span><br><span class="line">for arch in $ARCHS; do</span><br><span class="line"></span><br><span class="line">case $arch in arm*)</span><br><span class="line"></span><br><span class="line">IOSV=&quot;-miphoneos-version-min=7.0&quot;</span><br><span class="line"></span><br><span class="line">if [ $arch == &quot;arm64&quot; ]</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">IOSV=&quot;-miphoneos-version-min=7.0&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;Building for iOS $arch ****************&quot;</span><br><span class="line"></span><br><span class="line"># 编译 $arch 环境的类库（amr类型类型）</span><br><span class="line"></span><br><span class="line">SDKROOT=&quot;$(xcrun --sdk iphoneos --show-sdk-path)&quot;</span><br><span class="line"></span><br><span class="line">CC=&quot;$(xcrun --sdk iphoneos -f clang)&quot;</span><br><span class="line"></span><br><span class="line">CXX=&quot;$(xcrun --sdk iphoneos -f clang++)&quot;</span><br><span class="line"></span><br><span class="line">CPP=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;</span><br><span class="line"></span><br><span class="line">CFLAGS=&quot;-isysroot $SDKROOT -arch $arch $IOSV -isystem $SDKROOT/usr/include -fembed-bitcode&quot;</span><br><span class="line"></span><br><span class="line">CXXFLAGS=$CFLAGS</span><br><span class="line"></span><br><span class="line">CPPFLAGS=$CFLAGS</span><br><span class="line"></span><br><span class="line">export CC CXX CFLAGS CXXFLAGS CPPFLAGS</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line"></span><br><span class="line">--host=arm-apple-darwin \</span><br><span class="line"></span><br><span class="line">--prefix=$DEST \</span><br><span class="line"></span><br><span class="line">--disable-shared --enable-static</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">*)</span><br><span class="line"></span><br><span class="line">IOSV=&quot;-mios-simulator-version-min=7.0&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;Building for iOS $arch*****************&quot;</span><br><span class="line"></span><br><span class="line">SDKROOT=`xcodebuild -version -sdk iphonesimulator Path`</span><br><span class="line"></span><br><span class="line">CC=&quot;$(xcrun -sdk iphoneos -f clang)&quot;</span><br><span class="line"></span><br><span class="line">CXX=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;</span><br><span class="line"></span><br><span class="line">CPP=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;</span><br><span class="line"></span><br><span class="line">CFLAGS=&quot;-isysroot $SDKROOT -arch $arch $IOSV -isystem $SDKROOT/usr/include -fembed-bitcode&quot;</span><br><span class="line"></span><br><span class="line">CXXFLAGS=$CFLAGS</span><br><span class="line"></span><br><span class="line">CPPFLAGS=$CFLAGS</span><br><span class="line"></span><br><span class="line">export CC CXX CFLAGS CXXFLAGS CPPFLAGS</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line"></span><br><span class="line">--prefix=$DEST \</span><br><span class="line"></span><br><span class="line">--disable-shared</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">make &gt; /dev/null</span><br><span class="line"></span><br><span class="line">make install     </span><br><span class="line"></span><br><span class="line">make clean   </span><br><span class="line"></span><br><span class="line">for i in $LIBS; do</span><br><span class="line"></span><br><span class="line">mv $DEST/lib/$i $DEST/lib/$i.$arch</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for i in $LIBS; do</span><br><span class="line"></span><br><span class="line">input=&quot;&quot;</span><br><span class="line"></span><br><span class="line">for arch in $ARCHS; do</span><br><span class="line"></span><br><span class="line">input=&quot;$input $DEST/lib/$i.$arch&quot;</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">lipo -create -output $DEST/lib/$i $input</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>##2.修改build.sh的权限，打开终端，cd到新建的文件夹，使用命令 chmod  777 build.sh 修改权限。</p><p>##3.修改完成之后在终端执行 ./build.sh 就会在vo-amrwbenc里面生成一个lib-ios文件夹，里面就包含了libvo-amrwbenc.a的静态库和enc_if_h的头文件。</p><p>最后我已经将编译好的项目放到github上面</p><p><a href="https://github.com/codemonkeybulucck/opencore-vo-amrwbenc-iOS" target="_blank" rel="noopener">vo-amrwbenc编译</a></p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMR </tag>
            
            <tag> wav </tag>
            
            <tag> 音频开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用hexo在github上搭建自己的博客</title>
      <link href="/2018/07/25/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/%E4%BD%BF%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/07/25/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/%E4%BD%BF%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><blockquote><p>hexo是node.js提供的一个强大的，并且简单快速搭建自己博客的工具，通过该工具可以快速的搭建起自己的博客，该工具还提供了一系列的主题，可以快捷的设置不同主题。通过修改几个命令就可以将搭建好的博客部署到github上。<br>下面将会讲解如何1.通过hexo搭建自己的博客 2.如何设置博客的主题 3.如何应用到github 4.域名关联，通过自己的域名访问博客</p></blockquote><a id="more"></a><h2 id="0x02-准备工作"><a href="#0x02-准备工作" class="headerlink" title="0x02 准备工作"></a>0x02 准备工作</h2><blockquote><p>在开始工作之前你需要做一些准备工作</p></blockquote><ul><li>创建一个github账号，如果没有的话</li><li>安装node.js</li><li>安装npm</li></ul><h2 id="0x03-LET’S-DO-IT"><a href="#0x03-LET’S-DO-IT" class="headerlink" title="0x03 LET’S DO IT"></a>0x03 LET’S DO IT</h2><p>1、 首先在登录你的github账号，并且创建一个仓库，这个仓库的名字一定要按照<code>特定的格式</code>来写：也就是你的 <code>用户名.github.io</code>，如下图所示：<br><img src="http://pcd17v2u0.bkt.clouddn.com/15324821682415.jpg" alt=""><br>由于我之前已经创建过相同命名的仓库，所以会提示我已经重复了，以上的截图只是用于做仓库命名的示例，切记仓库的名字一定是 <code>用户名.github.io</code></p><p>2、 如果github上面没有配置SSH的话需要在本地生成一个公钥，然后配置到github上面。（如果已经配置的可以直接看第三步）<br>     使用以下命令创建一对公私秘钥</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; //创建秘钥，执行该命令后一直回车即可</span><br><span class="line">$ cat ~/.ssh/id_rsa.pub  //创建完成后查看创建好的公钥</span><br></pre></td></tr></table></figure></code></pre><p>   将上面创建好的公钥复制，然后登录github, 按照Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key的步骤，粘贴公钥即可。</p><p>3、 安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><p>4、 初始化目录在本地创建一个文件夹，可以随便起一个名字， 然后进入到该文件夹里面，通过hexo init初始化，初始化完成后会在该文件夹里面生成一些文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:~ lemon$ mkdir hexo</span><br><span class="line">Lemons-MacBookPro:~ lemon$ cd hexo/</span><br><span class="line">Lemons-MacBookPro:hexo lemon$ hexo init</span><br></pre></td></tr></table></figure><p>生成的目录如下所示：<br><img src="http://pcd17v2u0.bkt.clouddn.com/15324833176604.jpg" alt=""></p><p>5、 修改 _config.yml: 配置文件，可以在里面配置博客的名字，描述，主题，部署到哪里等等，下面来看一下里面主要需要修改的地方。<br>设置博客网站的标题，副标题，描述，作者的名字，语言，时区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  # Site</span><br><span class="line">title: Lemon&apos;s blog</span><br><span class="line">subtitle: Talk is cheap show me the code</span><br><span class="line">description: iOS Developer | 拥抱变化 | 🍋😊</span><br><span class="line">keywords: </span><br><span class="line">author: lemon</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure><p>需要部署到哪个平台,你需要修改的地方是repo，将仓库的地址换成在第一步创建的仓库地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:codemonkeybulucck/codemonkeybulucck.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>6、在本地浏览器查看博客的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate # 生成，可以用简写 hexo g</span><br><span class="line">$ hexo server # 启动服务，可以用简写 hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">WARN  ========================= ATTENTION! ==========================</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">WARN   NexT repository is moving here: https://github.com/theme-next</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">WARN   It&apos;s rebase to v6.0.0 and future maintenance will resume there</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>这样就会将博客部署到本地，在浏览器打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可访问</p><p>7、在第六步中我们看到的生成默认主题的博客，我们也许想换成更加符合我们审美的主题。 我们可以在 <a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">hexo有哪些好看的主题</a>这里找到我们自己喜欢的主题，下面以 hexo-theme-next 为例。 还是在我们的博客目录，下载主题到该目录下的theme文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><p>下载完成之后，打开_config.yml文件修改以下地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>将原来的默认的主题改为next，然后执行hexo server 来重新生成本地博客，这个时候在浏览器查看会发现主题和之前的不一样了。你还可以在theme-&gt;next-&gt;_config.yml文件夹里面修改布局，可以设置下面四个中任意的一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure><p>8、 到此为止我们已经搭建好博客并且设置了相应的主题，下面我们来试一下写一篇博客。博客的类型是markdown格式，可以下载一个Mweb来提前写好文章然后复制到source-&gt;_posts文件夹里面，也通过通过 hexo new post “博客名字”来生成一个markdown类型的博客</p><p>9、上传到github，由于我们在第5点已经设置了github的地址，因此我们直使用 <code>hexo deploy</code>来上传即可。<br>如果发现执行以上命令后有如下错误<br><code>Deployer not found: github 或者 Deployer not found: git</code><br>则需要先安装一个插件</p><p><code>npm install hexo-deployer-git --save</code><br>安装完该插件之后继续执行 <code>hexo deploy</code> 即可通过 <code>你的用户名.github.io</code>来访问你的博客。下面是我的博客 <a href="http://codemonkeybulucck.github.io" target="_blank" rel="noopener">codemonkeybulucck</a></p><p>10、绑定域名，如果没有域名的可以到<a href="https://wanwang.aliyun.com/?utm_content=se_1000094076" target="_blank" rel="noopener">阿里万网</a> 购买一个域名，<br>购买完成后到控制台找到对应的域名，添加解析，域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问<br>按照我下面的设置即可<br><img src="http://pcd17v2u0.bkt.clouddn.com/15324859351285.jpg" alt=""></p><p>设置完成之后还不可以立刻使用域名访问，需要到本地的博客的目录下的source文件夹里面创建一个CNAME文件，里面填写购买的域名<br>然后重新 <code>hexo deploy</code>之后就可以通过域名来访问你的博客了。</p><h2 id="0x04-以上，希望能帮助到你。"><a href="#0x04-以上，希望能帮助到你。" class="headerlink" title="0x04 以上，希望能帮助到你。"></a>0x04 以上，希望能帮助到你。</h2>]]></content>
      
      <categories>
          
          <category> 其他技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/24/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/hello-world/"/>
      <url>/2018/07/24/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
