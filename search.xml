<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图文混排的四种方案]]></title>
    <url>%2F2018%2F08%2F15%2FiOS%20%E5%BC%80%E5%8F%91%2F%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[图文混排有多种方式可以实现，下面我会用四种不同的方式来实现以下界面的效果，并且说明他们的优缺点。 NSAttributedString NSAttributedString提供了自由并且多样式的富文本设置，图文混排的实现是通过插入NSTestAttachment来实现。 talk is cheap ，here is the code 123456789101112131415161718192021222324252627282930313233343536373839//调用NSString *originStr = @&quot; Hi ALL,这是我的博客：lemon2well.top，欢迎来到我的博客，环欢迎评论留言一起交流。&quot;; NSString *targetStr = @&quot;lemon2well.top&quot;; NSString *imageName = @&quot;trumpet&quot;; self.label.attributedText = [self attribuStringWithString:originStr targetString:targetStr image:imageName];//方法- (NSAttributedString*)attribuStringWithString:(NSString*)string targetString:(NSString *)target image:(NSString*)imageName&#123; NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc]initWithString:string attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;]; NSRange linkRange = [string rangeOfString:target]; if (linkRange.length != 0) &#123; //添加可点击链接 [attributedStr addAttribute:NSLinkAttributeName value:[NSURL URLWithString:@&quot;lemon2well.top&quot;] range:linkRange]; [attributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:linkRange]; //添加下划线 [attributedStr addAttribute:NSUnderlineStyleAttributeName value:@1 range:linkRange]; &#125; //添加图片 NSTextAttachment *attachment = [[NSTextAttachment alloc]init]; attachment.image = [UIImage imageNamed:imageName]; attachment.bounds = CGRectMake(0, 0, 20 ,20); NSAttributedString *imageStr = [NSAttributedString attributedStringWithAttachment:attachment]; //插入图片 [attributedStr insertAttributedString:imageStr atIndex:0]; // 段落样式 NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init]; // 行间距 [style setLineSpacing:3]; // 段落间距 [style setParagraphSpacing:10]; // 首行缩进 [style setFirstLineHeadIndent:25]; [attributedStr addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, string.length-1)]; return attributedStr;&#125; 以下是NSAttributedString的属性 123456789101112131415161718192021// NSFontAttributeName 设置字体属性，默认值：字体：Helvetica(Neue) 字号：12// NSForegroundColorAttributeNam 设置字体颜色，取值为 UIColor对象，默认值为黑色// NSBackgroundColorAttributeName 设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色// NSLigatureAttributeName 设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符// NSKernAttributeName 设定字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄// NSStrikethroughStyleAttributeName 设置删除线，取值为 NSNumber 对象（整数）// NSStrikethroughColorAttributeName 设置删除线颜色，取值为 UIColor 对象，默认值为黑色// NSUnderlineStyleAttributeName 设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似// NSUnderlineColorAttributeName 设置下划线颜色，取值为 UIColor 对象，默认值为黑色// NSStrokeWidthAttributeName 设置笔画宽度，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果// NSStrokeColorAttributeName 填充部分颜色，不是字体颜色，取值为 UIColor 对象// NSShadowAttributeName 设置阴影属性，取值为 NSShadow 对象// NSTextEffectAttributeName 设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用：// NSBaselineOffsetAttributeName 设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏// NSObliquenessAttributeName 设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾// NSExpansionAttributeName 设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本// NSWritingDirectionAttributeName 设置文字书写方向，从左向右书写或者从右向左书写// NSVerticalGlyphFormAttributeName 设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本// NSLinkAttributeName 设置链接属性，点击后调用浏览器打开指定URL地址// NSAttachmentAttributeName 设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排// NSParagraphStyleAttributeName 设置文本段落排版格式，取值为 NSParagraphStyle 对象 NSParagraphStyle的属性 1234567891011121314NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init]; paragraphStyle.lineSpacing = 10;// 字体的行间距 paragraphStyle.firstLineHeadIndent = 20.0f;//首行缩进 paragraphStyle.alignment = NSTextAlignmentJustified;//（两端对齐的）文本对齐方式：（左，中，右，两端对齐，自然） paragraphStyle.lineBreakMode = NSLineBreakByTruncatingTail;//结尾部分的内容以……方式省略 ( &quot;...wxyz&quot; ,&quot;abcd...&quot; ,&quot;ab...yz&quot;) paragraphStyle.headIndent = 20;//整体缩进(首行除外) paragraphStyle.tailIndent = 20;// paragraphStyle.minimumLineHeight = 10;//最低行高 paragraphStyle.maximumLineHeight = 20;//最大行高 paragraphStyle.paragraphSpacing = 15;//段与段之间的间距 paragraphStyle.paragraphSpacingBefore = 22.0f;//段首行空白空间/* Distance between the bottom of the previous paragraph (or the end of its paragraphSpacing, if any) and the top of this paragraph. */ paragraphStyle.baseWritingDirection = NSWritingDirectionLeftToRight;//从左到右的书写方向（一共➡️三种） paragraphStyle.lineHeightMultiple = 15;/* Natural line height is multiplied by this factor (if positive) before being constrained by minimum and maximum line height. */ paragraphStyle.hyphenationFactor = 1;//连字属性 在iOS，唯一支持的值分别为0和1 TextView + UIImageview 以上的效果同样可以使用UITextView + UIImageView来实现，该方法主要利用了textview的textContainer.exclusionPaths属性 // Default value : empty array An array of UIBezierPath representing the exclusion paths inside the receiver’s bounding rect.@property (copy, NS_NONATOMIC_IOSONLY) NSArray *exclusionPaths NS_AVAILABLE(10_11, 7_0); 按照文档的说明我们可以提供一个元素为UIBezierPath的数组，这样文字的描绘就会避开这些路径。从而实现图文混排的效果。不过这种方式最适合用于文字环绕的效果，所有的文字把图片包围住。 here is the code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 调用 UITextView *textView = [[UITextView alloc]init]; textView.frame = CGRectMake(20, 200, 335, 150); textView.attributedText = [self textViewAttributestring]; [textView sizeToFit]; [self.view addSubview:textView]; self.textView = textView; UIImageView *imageView = [[UIImageView alloc]init]; imageView.frame = CGRectMake(45, 210, 20, 20); imageView.image = [UIImage imageNamed:@&quot;trumpet&quot;]; [self.view addSubview:imageView]; self.imageView = imageView; textView.textContainer.exclusionPaths = @[[self translatedBezierPath]]; //方法：- (UIBezierPath *)translatedBezierPath&#123; //计算出imageView相对于textView的相对坐标 CGRect imageRect = [self.textView convertRect:self.imageView.frame fromView:self.view]; UIBezierPath *bezierPath = [UIBezierPath bezierPathWithRect:CGRectMake(imageRect.origin.x, imageRect.origin.y-10, imageRect.size.width, imageRect.size.height)]; return bezierPath;&#125;- (NSAttributedString*)textViewAttributestring&#123; NSString *originStr = @&quot; Hi ALL,这是我的博客：lemon2well.top，欢迎来到我的博客，环欢迎评论留言一起交流。&quot;; NSString *targetStr = @&quot;lemon2well.top&quot;; NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc]initWithString:originStr attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;]; NSRange linkRange = [originStr rangeOfString:targetStr]; if (linkRange.length != 0) &#123; //添加可点击链接 [attributedStr addAttribute:NSLinkAttributeName value:[NSURL URLWithString:targetStr] range:linkRange]; [attributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:linkRange]; //添加下划线 [attributedStr addAttribute:NSUnderlineStyleAttributeName value:@1 range:linkRange]; &#125; // 段落样式 NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init]; // 行间距 [style setLineSpacing:3]; // 段落间距 [style setParagraphSpacing:10]; // 首行缩进 [style setFirstLineHeadIndent:25]; [attributedStr addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, originStr.length-1)]; return attributedStr;&#125; CoreTextcoreText给我的感觉就是太难用了，但是可创造性又很高，因为CoreText是属于比较底层的框架，所以基本上都是使用的C的方法，CoreText可以实现很复杂的图文混排而且渲染速度更快。 CoreText来实现图文混排实际上分为以下的几步: 获得上下文，翻转坐标系 -&gt; 创建NSAttributeString -&gt; 创建空白占位图片，创建代理 -&gt; 实现代理 -&gt; 创建CTFrameRef,CTFrameDraw绘制 -&gt; 计算图片坐标，CGContextDrawImage绘制 -&gt; 释放资源 CFAttributedStringRef ：属性字符串，用于存储需要绘制的文字字符和字符属性CTFramesetterRef：通过CFAttributedStringRef进行初始化，作为CTFrame对象的生产工厂，负责根据path创建对应的CTFrameCTFrame：用于绘制文字的类，可以通过CTFrameDraw函数，直接将文字绘制到context上CTLine：在CTFrame内部是由多个CTLine来组成的，每个CTLine代表一行CTRun：每个CTLine又是由多个CTRun组成的，每个CTRun代表一组显示风格一致的文本实际上CoreText是不直接支持绘制图片的，但是我们可以先在需要显示图片的地方用一个特殊的空白占位符代替，同时设置该字体的CTRunDelegate信息为要显示的图片的宽度和高度，这样绘制文字的时候就会先把图片的位置留出来，再在drawRect方法里面用CGContextDrawImage绘制图片。 Here is the code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107-(void)drawRect:(CGRect)rect&#123; [super drawRect:rect]; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetTextMatrix(context, CGAffineTransformIdentity); CGContextTranslateCTM(context, 0, self.bounds.size.height); CGContextScaleCTM(context, 1.0, -1.0); NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot; Hi ALL,这是我的博客：lemon2well.top，欢迎来到我的博客，环欢迎评论留言一起交流。&quot; attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;]; NSString *targetStr = @&quot;lemon2well.top&quot;; NSRange linkRange = [attributeStr.string rangeOfString:targetStr]; if (linkRange.length != 0) &#123; //添加可点击链接 [attributeStr addAttribute:NSLinkAttributeName value:[NSURL URLWithString:targetStr] range:linkRange]; [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:linkRange]; //添加下划线 [attributeStr addAttribute:NSUnderlineStyleAttributeName value:@1 range:linkRange]; &#125; // 段落样式 NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init]; // 行间距 [style setLineSpacing:3]; // 段落间距 [style setParagraphSpacing:10]; // 首行缩进 [style setFirstLineHeadIndent:25]; [attributeStr addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, attributeStr.length-1)]; CTRunDelegateCallbacks callBacks; memset(&amp;callBacks,0,sizeof(CTRunDelegateCallbacks)); callBacks.version = kCTRunDelegateVersion1; callBacks.getAscent = ascentCallBacks; callBacks.getDescent = descentCallBacks; callBacks.getWidth = widthCallBacks; NSDictionary * dicPic = @&#123;@&quot;height&quot;:@16,@&quot;width&quot;:@16&#125;; CTRunDelegateRef delegate = CTRunDelegateCreate(&amp; callBacks, (__bridge void *)dicPic); unichar placeHolder = 0xFFFC; NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1]; NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr]; CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate); CFRelease(delegate); [attributeStr insertAttributedString:placeHolderAttrStr atIndex:0]; CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr); CGMutablePathRef path = CGPathCreateMutable(); CGPathAddRect(path, NULL, self.bounds); NSInteger length = attributeStr.length; CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, length), path, NULL); CTFrameDraw(frame, context); UIImage * image = [UIImage imageNamed:@&quot;trumpet&quot;]; CGRect imgFrm = [self calculateImageRectWithFrame:frame]; CGContextDrawImage(context,imgFrm, image.CGImage); CFRelease(frame); CFRelease(path); CFRelease(frameSetter);&#125;static CGFloat ascentCallBacks(void * ref)&#123; return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;height&quot;] floatValue];&#125;static CGFloat descentCallBacks(void * ref)&#123; return 0;&#125;static CGFloat widthCallBacks(void * ref)&#123; return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;width&quot;] floatValue];&#125;-(CGRect)calculateImageRectWithFrame:(CTFrameRef)frame&#123; NSArray * arrLines = (NSArray *)CTFrameGetLines(frame); NSInteger count = [arrLines count]; CGPoint points[count]; CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points); for (int i = 0; i &lt; count; i ++) &#123; CTLineRef line = (__bridge CTLineRef)arrLines[i]; NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line); for (int j = 0; j &lt; arrGlyphRun.count; j ++) &#123; CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j]; NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run); CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName]; if (delegate == nil) &#123; continue; &#125; NSDictionary * dic = CTRunDelegateGetRefCon(delegate); if (![dic isKindOfClass:[NSDictionary class]]) &#123; continue; &#125; CGPoint point = points[i]; CGFloat ascent; CGFloat descent; CGRect boundsRun; boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL); boundsRun.size.height = ascent + descent; CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL); boundsRun.origin.x = point.x + xOffset; boundsRun.origin.y = point.y - descent; CGPathRef path = CTFrameGetPath(frame); CGRect colRect = CGPathGetBoundingBox(path); CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y); return imageBounds; &#125; &#125; return CGRectZero;&#125; YYTextYYTextYYText是大神郭曜源开发的一个强大的展示和编辑富文本的第三方工具，里面提供了丰富的与富文本开发相关的方法，具体的可以到github里面看。YYText是基于CoreText向上封装了一层，所以对开发者更加友好，如果在项目中运用到大量的富文本的地方建议可以用YYText。 here is the code 12345678910111213141516171819202122232425262728293031YYLabel *label = [[YYLabel alloc]init]; label.numberOfLines = 0 ; label.frame = CGRectMake(0, 200, 375, 200); [self.view addSubview:label]; NSString *headStr = @&quot;Hi ALL,这是我的博客：&quot;; NSString *linkStr = @&quot;lemon2well.top&quot;; NSString *lastStr = @&quot;，欢迎来到我的博客，环欢迎评论留言一起交流。&quot;; UIImage *image = [UIImage imageNamed:@&quot;trumpet&quot;]; NSMutableAttributedString *attrText = [NSMutableAttributedString new]; NSAttributedString *headAttr = [[NSAttributedString alloc] initWithString:headStr attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;]; NSAttributedString *lastAttr = [[NSAttributedString alloc] initWithString:lastStr attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;]; NSMutableAttributedString *linkAttr = [[NSMutableAttributedString alloc] initWithString:linkStr]; linkAttr.yy_font = [UIFont systemFontOfSize:20]; linkAttr.yy_underlineStyle = NSUnderlineStyleSingle; [linkAttr yy_setTextHighlightRange:NSMakeRange(0, linkStr.length) color:[UIColor blueColor] backgroundColor:nil tapAction:^(UIView * _Nonnull containerView, NSAttributedString * _Nonnull text, NSRange range, CGRect rect) &#123; NSLog(@&quot;link = %@&quot;,text); &#125;]; NSMutableAttributedString *imageAttr = [NSMutableAttributedString yy_attachmentStringWithContent:image contentMode:UIViewContentModeCenter attachmentSize:CGSizeMake(32, 32) alignToFont:[UIFont systemFontOfSize:20] alignment:YYTextVerticalAlignmentCenter]; [attrText appendAttributedString:imageAttr]; [attrText appendAttributedString:headAttr]; [attrText appendAttributedString:linkAttr]; [attrText appendAttributedString:lastAttr]; label.attributedText = attrText; 总结：总的来说，以上说的四种都各有优劣，但是他们都用了NSAttributedString来实现富文本。 如果在项目中用到富文本的地方不多，出于APP体积考虑没必要引入一个第三方， 可以考虑使用第一和第二种方案，如果是图文环绕这种，可以使用UITextView+UIImageview的方案，如果是小的表情图文混排可以使用NSAttributedString+label即可。 如果在项目中多处用到富文本的展示和编辑，建议使用YYText，因为它对于开发者更加友好，并且也是基于CoreText来渲染，不过有一点就是目前YYText已经有一年没维护了，之前他生病了，现在正在家里修养，希望他快点好起来，祝好。 突然有感本来这篇文章到这里就应该完了，不过刚刚去看了一下YYKit的作者的博客，突然有点伤感，没想到他生病这么严重，看他的文字感觉他是一个对待生活也很细腻的人，这也说得通为什么他可以用业余的时间写出了YYKIT这么强大的工具，因为他对待技术也是很细腻。 真的很佩服这样的人，你可以感受到他的真诚，我虽然没和他聊过天，没见过他真人，不过他一定会是一个让别人感受到交流沟通起来让你没有防御的一个人。现在这个社会因为各种各样变态的人以及事，总会让人无论何时何地总会身上架着一层防御装，更可怕的是还有那种表面善内里恶的人，多可怕，如果是危害别人的人我一点都不心疼。 最后希望大家一定要注意自己的身体，祝大家都好。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发细节之 hash 与 isEqual 方法]]></title>
    <url>%2F2018%2F08%2F14%2FiOS%20%E5%BC%80%E5%8F%91%2F%E5%BC%80%E5%8F%91%E7%BB%86%E8%8A%82%E4%B9%8B-hash-%E4%B8%8E-isEqual-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[isEuqal 与 == 的区别相信大家都知道在OC中有两种比较是否相等的方法，第一种是直接用==符号比较，第二种是使用isEqual来比较，它们的区别如下： == 如果是用于基本数据类型的比较，那么直接比较数值，isEqual只能用于OC对象比较 == 如果是用于OC对象比较，那么是判断他们是不是同一个对象，也就是指针所指向的地址是否一致。而isEqual则是比较两个对象是否相同。 接下来用一个颜色的示例来看看： 12345UIColor *color1 = [UIColor colorWithRed:120/255.0 green:120/255.0 blue:120/255.0 alpha:1];UIColor *color2 = [UIColor colorWithRed:120/255.0 green:120/255.0 blue:120/255.0 alpha:1];NSLog(@&quot;color1.address = %p\ncolor2.address = %p&quot;,color1,color2);NSLog(@&quot;color1 == color2 ? %@ &quot;,color1 == color2 ? @&quot;是&quot; : @&quot;否&quot;);NSLog(@&quot;color1 isEqual color2 ? %@ &quot;,[color1 isEqual:color2] ? @&quot;是&quot; : @&quot;否&quot;); 结果输出： 1234color1.address = 0x60400046af40color2.address = 0x60400046b280color1 == color2 ? 否color1 isEqual color2 ? 是 通过上面的例子我们可以看出，color1和color2是两个不同的对象，所以使用==来比较的时候他们不相等。但是color1和color2颜色的值都是一样的，所以使用isEuqal来比较的时候他们是相等的。 isEuqal 用于自定义对象的比较刚刚我们是使用系统的UIColor的对象来比较，如果是我们是自定义的对象，如果需要判断两个对象是否相等的时候，使用isEqual方法来比较是否还起作用呢？ 看看以下代码，我们有一个LMPerson类，里面有两个属性，一个name，一个age，我们创建两个不同的对象，然后给他们赋予同样的name和age，看看使用isEuqal来比较是否相等。 12345LMPerson *person1 = [LMPerson personWithName:@&quot;lemon&quot; age:18]; LMPerson *person2 = [LMPerson personWithName:@&quot;lemon&quot; age:18]; NSLog(@&quot;person1.address = %p\nperson2.address = %p&quot;,person1,person2); NSLog(@&quot;person1 == person2 ? %@ &quot;,person1==person2?@&quot;是&quot;:@&quot;否&quot;); NSLog(@&quot;person1 isEqual person2 ? %@ &quot;,[person1 isEqual:person2]?@&quot;是&quot;:@&quot;否&quot;); 结果如下： 1234person1.address = 0x60400022b500person2.address = 0x60400022b200person1 == person2 ? 否person1 isEqual person2 ? 否 通过上面的结果可以看出，当isEqual是用于我们自定义对象的比较的时候，即使我们赋予两个对象属性相同的值，但是返回的却是NO。这是为什么呢？ 这是因为UIColor，NSArray,NSdictonary 系统已经帮我们实现了对应的isEqual或者isEqualTo的方法，所以我们如果要用于自定义对象比较，那么也需要实现对应的isEqual方法，接下来我们给LMPerson添加以下实现方法 1234567891011121314- (BOOL)isEqual:(id)object&#123; if (self == object) &#123; return YES; &#125; if (![object isKindOfClass:LMPerson.class]) &#123; return NO; &#125; LMPerson *person2 = (LMPerson*)object; BOOL isSameName = (!self.name &amp;&amp; !person2.name) || [self.name isEqualToString:person2.name]; BOOL isSameAge = self.age == person2.age ; return isSameName &amp;&amp; isSameAge;&#125; 测试结果如下： 1234person1.address = 0x60000022bac0person2.address = 0x60000022c460person1 == person2 ? 否person1 isEqual person2 ? 是 综上，如果我们要比较两个自定义对象是否相等的时候我们需要重写isEqual方法，给该方法提供一个实现。 什么是hash方法这个要从hashTable说起，因为hashTabe是无序的集合，并且查找的时间复杂度是O(1)，数组是O(array_lenth)，为什么hashTable可以做到O(1)呢，因为当一个元素加到hashTable里面的时候，会有一个默认的hash值，用于标记元素在table中的位置，后面如果需要查找该元素，通过hash值可以直接找到该元素。 那么问题来了，这个hash值是怎样得来的呢？ 这个hash值其实就是通过- (NSUInteger)hash方法提供的，并且系统默认的实现就是返回该对象的地址。下面我们来验证这个说法： 我们增加以下方法，并且打印出hash的值。 1234567891011//LMPerson.m- (NSUInteger)getSuperHash&#123; NSUInteger superHash = [super hash]; return superHash;&#125;//ViewController LMPerson *person1 = [LMPerson personWithName:@&quot;lemon&quot; age:18]; LMPerson *person2 = [LMPerson personWithName:@&quot;lemon&quot; age:18]; NSLog(@&quot;person1.address = %ld\nperson2.address = %ld&quot;,(NSUInteger)person1,(NSUInteger)person2); NSLog(@&quot;person1.hash = %ld\nperson2.hash = %ld&quot;,[person1 getSuperHash],[person2 getSuperHash]); 测试结果如下： 1234person1.address = 105553118496736person2.address = 105553116524864person1.hash = 105553118496736person2.hash = 105553116524864 通过结果我们可以知道，其实系统默认的hash方法就是返回对象地址的十进制。 什么时候会调用hash 方法这里我们直接说结论，如果一个集合中不能出现重复的元素那么就会调用hash方法来判断两个元素是否相等。什么意思呢？ NSMutableArray和NSArray是允许添加重复元素的，所以将一个元素放到该容器中的时候是不会调用hash方法，像NSSet，NSMutableSet元素不能重复，在添加和删除的时候会调用hash方法。当一个元素作为NSDictonary的key的时候，因为key也不能重复，所以也会调用hash方法。大家可以通过将上述创建的两个person对象分别放到不同的集合中进行验证。 值得注意的是，就算hash方法相等也不能判断两个元素就一定是相等，还会调用isEqual来进行判断。也就是说，会优先判断hash是否相等，如果hash不相等那么这两个元素一定不相等，如果hash相等，那么就调用isEqual判断两个元素是否相等，如果返回NO，那么两个元素也不相等， 如果返回YES那么两个元素相等。 也就是说当我们把自定义对象加到NSSet中的或者作为NSDictonary的key的时候 会同时调用hash方法和isEqual方法来判断两个元素是否相等，因此我们需要重写isEqual方法和hash方法。 hash 的正确使用姿势我们在上面已经验证过如果我们使用系统默认的hash方法来比较两个自定义对象是否相等是不正确的了，那么正确的使用姿势是什么呢？ 在Equality这篇文章中，matt大神给了方法，也就是对属性的hash进行异或运算。在LMPerson.m中 123- (NSUInteger)hash&#123; return ([self.name hash] ^ [[NSNumber numberWithInteger:self.age] hash]);&#125; 下面我们编写以下代码来测试一下相同的元素是否还能加到hashTable里面 12345LMPerson *person1 = [LMPerson personWithName:@&quot;lemon&quot; age:18]; LMPerson *person2 = [LMPerson personWithName:@&quot;lemon&quot; age:18]; LMPerson *person3 = [LMPerson personWithName:@&quot;lemon&quot; age:19]; NSSet *set = [NSSet setWithObjects:person1,person2, person3,nil]; NSLog(@&quot;set.count = %ld&quot;,[set count]); 测试结果： 12018-08-14 11:08:13.250550+0800 testImageSourceCode[47478:7219161] set.count = 2 可以看到我们往hashTable里面添加了三个元素，但是第一和第二个元素是相同的，所以最后加到集合里面的只有两个元素，证明hash方法起作用了。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>isEuqal</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说HTTP与HTTPS]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF%2F%E7%BB%86%E8%AF%B4HTTP%E4%B8%8EHTTPS%2F</url>
    <content type="text"><![CDATA[前言网上已经有很多关于HTTP与HTTPS的文章，为什么我还要写这篇文章呢，源于昨天有个iOS开发同学昨天在群里面提了一个问题，如果一个人下载了一个APP，该APP与服务器是HTTPS连接，他不会信任任何来源于不明身份的证书，然后连上了我的WIFI，我有没有办法去破解里面的通信内容? 接下来我们就带着这个疑问去寻找答案，并且给出我的答案。 什么是HTTP HTTP(HyperText Transfer Protocol)超文本传输协议，HTTP是七层网络模型中作用在应用层的协议。 HTTP的缺点： 窃听风险（eavesdropping）：第三方可以获知通信内容。 篡改风险（tampering）：第三方可以修改通信内容。 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 因为HTTP是明文传输内容的，所以只要攻击者通过劫持你的WIFI或者你连上了不安全的WIFI那么你所有的传输内容他都可以拿到，接下来就可以篡改里面的数据。基于以上的缺点就有了HTTPS，待会我们再来说这个事儿。 HTTP的工作流程：相信大家都听说过TCP三次握手，HTTP就是通过TCP三次握手建立连接，值得一提的是HTTP/1.0版本是默认没有复用TCP连接的，每次发送数据都要建立一个连接(需要使用keep-alive来建立长连接)，这样导致了耗时以及占用资源非常严重，后来发布了HTTP/1.1，同一个TCP通道可以复用发送多个请求，但是在该通道里面所有的请求都是按照顺序来发送的发送的，容易导致阻塞。HTTP/2在1.1的基础上改进了，不止复用同一个TCP通道并且可以并发的处理多个请求。 TCP三次握手，依照惯例，先发一个图片，看图说话 下面来解释一下上面三次握手的作用： 第一次握手：客户端发送将SYN标志位设置为1，并且随机产生一个序列号值seq=J，发送给数据包给服务端后，自身状态变为SYN_SENT 第二次握手：服务端接收到数据包之后，将发送标志位SYN设置为1，ACK应答需要为J+1表，并且再发送一个随机序列号值seq=K然后发送到客户端 第三次握手：客户端检查ACK是否为J+1，如果是的话发送一个ACK包，ACK=k+!，服务端收到之后确定ack是否等于K+1，是的话连接建立 我们先来解释一下为什么需要三次握手：第一次握手确认客户端是具有发送消息能力的，发送消息之后客户端出于SYN_SENT状态，第二次握手服务器确定了自己有接收消息的能力，但是还不知道有没有发送消息的能力，此时服务器出于SYN_RECV的状态，也就是半连接的状态，第三次握手确定了服务器有发送消息的能力，因为客户端收到了他的消息并且回应了。此时客户端和服务端都处于establish状态，连接已经建立，可以开始收发消息。 基于HTTP的确定，后面衍生出来了HTTPS，那接下来我们来讲讲HTTPS以及他们的区别 什么是HTTPS HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）顾名思义就是在HTTP的基础上加了SSL/TLS，以此来保证数据传输的安全性。 HTTPS的优点HTTPS 协议旨在解决以上三个风险，因此它可以： 保证所有信息加密传输，无法被第三方窃取。 为信息添加校验机制，如果被第三方恶意破坏，可以检测出来。 配备身份证书，防止第三方伪装参与通信。 SSL/TLS SSL(Secure Sockets Layer)/TLS(transport Layer Security)安全套接层是保证HTTPS安全的协议，这个协议主要的思想是通过公钥加解密来实现数据传输安全。 那么我们就面临着两个问题.1.如何保证公钥不被篡改 我们通过权威机构申请证书，将自己的公钥包装到证书里面，只要证书是可信的，那么公钥就是可信的。 2.每次都生成公钥，消耗的时间太长，如何减少消耗。 使用对称加密来替换非对称加密，每一次对话，客户端和和服务端都生成一个对话秘钥，而这个对称秘钥使用服务端的公私钥来进行加解密，这样就减少了加密运算的消耗时间。 SSL/TLS 握手的流程： 首先客户端发起请求，这个时候客户端会向服务端提供一些信息，包括支持的加密的算法，支持协议的版本TLS,一个随机数（用于待会生成对称秘钥），支持的压缩算法 服务端收到请求之后，向客户端发出相应，该响应也包括一些信息，确认使用的加密算法，一个服务端生成的随机数（用于待会生成秘钥）,支持的协议的版本TLS，还有一个最重要的数字证书，该数字证书包含了服务器的域名，还有服务端的公钥，以及经过加密后的摘要，该摘要是通过一定的算法对域名以及公钥进行计算得来。然后使用CA的私钥对摘要进行加密， 客户端收到数据之后首先会验证该数字证书是不是权威机构申请的证书，或者证书中的域名与实际域名是否一致，证书是否已经过期，如果都不符合的话那么就会提示是否信任该未知来源证书警告。这里会验证证书是否被篡改，因为本地系统会内置权威机构的公钥，所以可以使 用公钥对解密出证书里面的摘要，然后通过特定的算法对域名以及公钥进行计算得到一个本地摘要，再和服务端传过来的摘要进行对比是否一致，以此来判断证书是否被篡改。如果校验了证书是没有问题，客户端会生成一个随机数，并且使用服务器的公钥进行加密，并且发送编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 服务端获取客户端的数据，然后使用自己的私钥机密客户端发过来的随机数。至此，一共有三个随机数。 客户端和服务端通过之前协议好的加密算法，使用前面生成的三个随机数生成一个真正的对称秘钥，该对称秘钥用于加密传输数据。 简单点来说以上步骤就是： 客户端发送请求 服务端返回证书，该证书包含服务端的公钥 客户端验证证书，并且生成对称秘钥，并且使用服务端的公钥加密该对称秘钥 服务端用私钥解密客户端的对称秘钥 发送内容通过对称秘钥来加密 总结一下 HTTPS 协议是如何避免前文所说的三大风险的：先用非对称加密传输密码，然后用这个密码对称加密数据，使得第三方无法获得通信内容发送方将数据的哈希结果写到数据中，接收方解密后对比数据的哈希结果，如果不一致则说明被修改。由于传输数据加密，第三方无法修改哈希结果。由权威机构颁发证书，再加上证书校验机制，避免第三方伪装参与通信。 答案在我们抛砖引玉说了这么多HTTP与HTTPS的区别之后，我们得到了答案。 如果一个人下载了一个APP，该APP与服务器是HTTPS连接，他不会信任任何来源于不明身份的证书，然后连上了我的WIFI，我有没有办法去破解里面的通信内容 答案就是不行 我们想到的可以破解里面的通信内容也许就是希望能做一个中间人拦截，在服务端向客户端发送证书的时候拦截该证书，并且伪造一个和服务端域名相同并且替换将里面的公钥替换成自己的公钥，并且用自己的私钥进行签名。客户端收到伪造的证书之后，如果客户端的系统中有我们的公钥，那么就可以验证通过该中间人的证书，然后获取得到公钥，然后用该公钥对对称秘钥加密发送给服务端，此时中间件又可以拦截，并且使用自己的私钥解密出对称秘钥，然后中间人通过服务端的公钥对该秘钥进行加密，然后发送给服务端，这样中间人就拿到了对称秘钥信息，所以也可以窃取到里面的通信内容。 但是………. 前面的题目说了一个前提，不会信任任何来源于不明身份的证书，也就是说在中间人拦截了服务端的证书并且将伪造的证书发送给客户端之后，客户端并不会通过验证该证书，然后连接就到此中断了。。。。 附加：HTTPS与HTTPS的区别 HTTP是明文传输，HTTPS是加密传输 HTTP只有TCP三次握手，HTTPS是TCP三次握手+SSL/TLS HTTP是使用80端口，HTTPS是使用443端口 HTTPS比HTTPS更加耗时 HTTPS需要到CA购买证书，需要一定的费用 参考文章1 SSL/TLS协议运行机制的概述 图解SSL/TLS协议 深入理解HTTPS]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
        <tag>SSL/TLS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文数]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%2F%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。示例 1: 12输入: 121输出: true 示例 2: 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 思路：根据定义如果我们要找出一个数是否是回文数我们其实只需要将这个数分成平均分成两个部分，然后将后半部分翻转，只要翻转后的后半部分等于前半部分，就代表这个数是回文数。我们拿1221来举例，假设我们拿到后半段是21然后将21翻转就是12了，和前半段比较相等就代表是回文数。那么我们第一个问题，如何将21翻转，首先我们将1221%10 得到的就是第一个数1，然后用这第一个数 1 10 得到翻转后的正确位置。第二个数我们依然是122%10，然后得到第二个数，用第一个数加上第二个数就得到了12.第二个问题就是我们如何将这个数分成两部分。当原始数/10小于翻转数10的时候就代表已经完成了一半的翻转。 不过依然有两点需要注意，第一点是如果这个原始的数是负数的话我们需要返回，如果这个数是以0结尾的数，那么只有0才满足回文数，其他数都不满足回文数，我们直接返回false。第二点是如果这个数的位数是基数，例如12321，那么循环完成之后原始数编程12，翻转数是123，这个时候我们用123/10得到12再和原始数12比较，忽略中间那一位数 以下是代码： 123456789101112fileprivate func solution(_ num:Int)-&gt;Bool&#123; if num&lt;0 || (num % 10 == 0 &amp;&amp; num != 0)&#123; return false &#125; var originNum = num var reverserNum = 0 while originNum &gt; reverserNum &#123; reverserNum = reverserNum * 10 + originNum % 10 originNum = originNum / 10 &#125; return originNum == reverserNum || originNum == reverserNum / 10 &#125;]]></content>
      <categories>
        <category>常见算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[持续集成之Jenkins构建项目并上传到蒲公英]]></title>
    <url>%2F2018%2F08%2F08%2FiOS%20%E5%BC%80%E5%8F%91%2F%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%92%B2%E5%85%AC%E8%8B%B1%2F</url>
    <content type="text"><![CDATA[在第一篇Jenkins的搭建中我们已经把本地jenkins环境都搭建好了，接下来我们通过jenkins构建一个ipa并且上传到蒲公英。 创建任务1.首先选择左侧的新建任务，然后下面是构建该工程的基本信息 填写源码地址 下面填写github或者gitLab的源码的地址，并且需要配置对应的Credentials，这里相当是授权。等到构建的时候jenkins会从对应的git上面拉去代码开始构建。 填完源码的网址之后需要填写git的账号密码或者输入对应的私钥。点击Add然后会出现下面的界面 如果你的git已经配置了ssh那么可以选择SSH username and private key， 然后到你的/Users/用户名/.ssh/id_rsa 将这个私钥文件里面的所有内容复制到privatekey (enter directly)上面去。否则可以按照上图那样，选择username with password，然后输入用户名和密码 设置触发器（非必要） 构建触发器是与测试相关的操作，这里可以根据需求选择构建的触发时刻，例如选择第二个就是当代码仓库有push事件的时候，就会触发构建操作，然后构建一个版本并且通知测试去操作。因为我们是手动构建，所以这里先不管这个。 设置签名和证书 接下我们需要设置签名文件和证书。首先保存我们原先的设置，然后回到首页，选择系统管理-&gt;Keychains and Provisioning Profiles Management 点击选取文件，然后选择login.keychain文件和 provisioning file 上传。 填写本机密码，输入描述，然后选择Add Code Signing Identity 输入签名文件的名称，这里的名称可以到钥匙串找到对应的证书然后选择显示简介然后复制头部的文字。 这个Keychain在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下 上面的配置完成之后，回到任务的配置里面，选择对应的keyChain和provisioning file 构建命令 上面已经将所有的设置都配置好了，接下来需要选择构建的方式，你可以选择通过xcode来构建，但是这里我们选择shell 并且也推荐通过shell来构建。选择执行shell，然后输入下面的代码，里面有些地方需要改成你自己的，根据实际情况改就可以了，不过一定要注意一点，jenkins那个编辑框极其不好用，我因为不小心输入了一个空格字符然后一直报 command not found ，搞到我一直以为是jenkins配置环境的问题。如果中间有构建错误，点击构建那个红点然后可以查看具体的控制台信息，根据错误提示来修改就好了 1234567891011121314151617181920212223242526272829303132333435363738# 工程名，记得改成你自己APP_NAME=&quot;TestUMCOpen&quot;# 证书CODE_SIGN_DISTRIBUTION=&quot;iPhone Distribution: XXXXXXXXXX&quot;# info.plist路径project_infoplist_path=&quot;./$&#123;APP_NAME&#125;/Info.plist&quot;#取版本号bundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)#取build值bundleVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)DATE=&quot;$(date +%Y%m%d)&quot;IPAFOLDER=&quot;$&#123;APP_NAME&#125;_V$&#123;bundleShortVersion&#125;_$&#123;DATE&#125;&quot;#要上传的ipa文件路径ARCHIVE_PATH=&quot;$&#123;HOME&#125;/Desktop/archive&quot;IPA_PATH=&quot;$ARCHIVE_PATH/$&#123;IPAFOLDER&#125;/$&#123;APP_NAME&#125;.ipa&quot;PLIST_PATH=&quot;$ARCHIVE_PATH/ADHocExportOptions.plist&quot;echo $&#123;IPA_PATH&#125;echo $&#123;PLIST_PATH&#125;#下面两行是没有Cocopods的用法# 清除上次构建xcodebuild clean -project &quot;$&#123;APP_NAME&#125;.xcodeproj&quot; -scheme $&#123;APP_NAME&#125; -configuration &apos;Release&apos;# 构建xcarchive文件xcodebuild archive -project &quot;$&#123;APP_NAME&#125;.xcodeproj&quot; -scheme $&#123;APP_NAME&#125; -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot;#下面两行是有cocopods的用法# xcodebuild clean -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme $&#123;APP_NAME&#125; -configuration &apos;Release&apos;# xcodebuild archive -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme $&#123;APP_NAME&#125; -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot;# 导出ipaxcodebuild -exportArchive -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot; -exportPath &quot;$ARCHIVE_PATH/$IPAFOLDER&quot; -exportOptionsPlist &quot;$PLIST_PATH&quot;#打开文件夹open $&#123;ARCHIVE_PATH&#125; 这里有个地方需要注意一下，在xcode9之后，需要提供一个信息才能打包，我们可以通过xcode打包出来ipa文件然后复制那个ExportOption.plist文件就好了以下是我的文件的内容 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;false/&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;enterprise&lt;/string&gt; &lt;key&gt;provisioningProfiles&lt;/key&gt; &lt;dict&gt; &lt;key&gt;your Bundle id&lt;/key&gt; &lt;string&gt;证书的名字&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;signingCertificate&lt;/key&gt; &lt;string&gt;iPhone Distribution&lt;/string&gt; &lt;key&gt;signingStyle&lt;/key&gt; &lt;string&gt;manual&lt;/string&gt; &lt;key&gt;stripSwiftSymbols&lt;/key&gt; &lt;true/&gt; &lt;key&gt;teamID&lt;/key&gt; &lt;string&gt;7LD5QKB26C&lt;/string&gt; &lt;key&gt;thinning&lt;/key&gt; &lt;string&gt;none&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; 如果成功之后会在我们指定的文件里面生成下面的文件，除了那个ADHocExportOption.plist是我创建的，前天的文件都是jenkins构建的。 上传ipa到蒲公英 12345678910#上传到蒲公英uKey=&quot;aec42b3cc32*******837cc7084a819c&quot;#蒲公英上的API KeyapiKey=&quot;ba4e62***************8067a87315&quot;#要上传的ipa文件路径echo $IPA_PATH #执行上传至蒲公英的命令echo &quot;++++++++++++++upload+++++++++++++&quot;curl -F &quot;file=@$&#123;IPA_PATH&#125;&quot; -F &quot;uKey=$&#123;uKey&#125;&quot; -F &quot;_api_key=$&#123;apiKey&#125;&quot; http://www.pgyer.com/apiv1/app/upload 命令行构建 至此我们已经完成手动构建项目了，接下来我们利用Jenkins命令行来完成一行命令构建版本进入系统管理然后选择Jenkins命令行，下载最新的jenkins-cli.jar 下载完成之后，如果直接运行上述命令行会提示没有权限，这个时候我们需要配置一下SSH。点击右上角的用户名，然后点击设置，找到SSH，然后将本地的公钥复制粘贴到上面，保存。 下面是完整的命令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136add-job-to-view Adds jobs to view. build Builds a job, and optionally waits until its completion. cancel-quiet-down Cancel the effect of the &quot;quiet-down&quot; command. clear-queue Clears the build queue. connect-node Reconnect to a node(s) console Retrieves console output of a build. copy-job Copies a job. create-credentials-by-xml Create Credential by XML create-credentials-domain-by-xml Create Credentials Domain by XML create-job Creates a new job by reading stdin as a configuration XML file. create-node Creates a new node by reading stdin as a XML configuration. create-view Creates a new view by reading stdin as a XML configuration. delete-builds Deletes build record(s). delete-credentials Delete a Credential delete-credentials-domain Delete a Credentials Domain delete-job Deletes job(s). delete-node Deletes node(s) delete-view Deletes view(s). disable-job 禁用任务 disconnect-node Disconnects from a node. enable-job 启用任务 get-credentials-as-xml Get a Credentials as XML (secrets redacted) get-credentials-domain-as-xml Get a Credentials Domain as XML get-job Dumps the job definition XML to stdout. get-node Dumps the node definition XML to stdout. get-view Dumps the view definition XML to stdout. groovy Executes the specified Groovy script. groovysh Runs an interactive groovy shell. help Lists all the available commands or a detailed description of single command. import-credentials-as-xml Import credentials as XML. The output of &quot;list-credentials-as-xml&quot; can be used as input here as is, the only needed change is to set the actual Secrets which are redacted in the output. install-plugin Installs a plugin either from a file, an URL, or from update center. install-tool Performs automatic tool installation, and print its location to stdout. Can be only called from inside a build. [deprecated] keep-build 永久保留这次构建。 list-changes Dumps the changelog for the specified build(s). list-credentials Lists the Credentials in a specific Store list-credentials-as-xml Export credentials as XML. The output of this command can be used as input for &quot;import-credentials-as-xml&quot; as is, the only needed change is to set the actual Secrets which are redacted in the output. list-credentials-context-resolvers List Credentials Context Resolvers list-credentials-providers List Credentials Providers list-jobs Lists all jobs in a specific view or item group. list-plugins Outputs a list of installed plugins. login Saves the current credentials to allow future commands to run without explicit credential information. [deprecated] logout Deletes the credentials stored with the login command. [deprecated] mail Reads stdin and sends that out as an e-mail. offline-node Stop using a node for performing builds temporarily, until the next &quot;online-node&quot; command. online-node Resume using a node for performing builds, to cancel out the earlier &quot;offline-node&quot; command. quiet-down Quiet down Jenkins, in preparation for a restart. Don’t start any builds. reload-configuration Discard all the loaded data in memory and reload everything from file system. Useful when you modified config files directly on disk. reload-job Reload job(s) remove-job-from-view Removes jobs from view. restart 重新启动Jenkins safe-restart 安全地重新启动Jenkins safe-shutdown Puts Jenkins into the quiet mode, wait for existing builds to be completed, and then shut down Jenkins. session-id Outputs the session ID, which changes every time Jenkins restarts. set-build-description Sets the description of a build. set-build-display-name Sets the displayName of a build. set-build-parameter Update/set the build parameter of the current build in progress. [deprecated] set-build-result Sets the result of the current build. Works only if invoked from within a build. [deprecated] set-external-build-result Set external monitor job result. shutdown 立刻关闭Jenkins update-credentials-by-xml Update Credentials by XML update-credentials-domain-by-xml Update Credentials Domain by XML update-job Updates the job definition XML from stdin. The opposite of the get-job command. update-node Updates the node definition XML from stdin. The opposite of the get-node command. update-view Updates the view definition XML from stdin. The opposite of the get-view command. version Outputs the current version. wait-node-offline Wait for a node to become offline. wait-node-online Wait for a node to become online. who-am-i Reports your credential and permissions. 我们执行命令的格式是java -jar jenkins-cli.jar -s http://localhost:8080/ -ssh -user username commandcommand 就是我们需要执行的命令，build是构建命令，下面的事情就很简单了。 java -jar jenkins-cli.jar -s http://localhost:8080/ -ssh -user username build UMC10.1.0DemoUMC10.1.0Demo是我们一开始创建任务的时候的名字，这个时候就会自动构建版本并且上传蒲公英可以将上述命令放到.command文件里面，并且增加可执行权限，这样双击这个文件的时候就会触发构建。注意里面cli.jar的路径。 上述命令指示构建一个指定版本的脚本，下面我们可以通过列举出所有的任务，然后选择其中一个任务来开始构建版本 12345678910111213141516171819202122#!/bin/bashps -fe|grep &quot;jenkins&quot; |grep -v grepif [ $? -ne 0 ]thenecho &quot;******请先使用Jenkins -h来启动jenkins**********&quot;elseecho &quot;********检测到Jenkins已经启动**********&quot;fiLOCALHOST=&quot;http://localhost:8080/&quot;CLIJAR=&quot;/Users/lemon/jenkins-cli.jar&quot;java -jar $&#123;CLIJAR&#125; -s $&#123;LOCALHOST&#125; -ssh -user admin list-jobsecho &quot;*******请输入你要构建的任务*******&quot;read BuildNamejava -jar $&#123;CLIJAR&#125; -s $&#123;LOCALHOST&#125; -ssh -user admin build $&#123;BuildName&#125;if [ $? -ne 0 ]; thenecho &quot;*******正在构建$&#123;BuildName&#125;，构建完成后会自动打开本地文件夹*******&quot;elseecho &quot;*******构建$&#123;BuildName&#125;失败，请检查是否有对应的任务*******&quot;fi 总结综上所述：总的来说在我们jenkins已经安装好的情况下，我们需要做的就是构建任务，然后填写源码地址，设置构建策略，设置签名和证书，编写构建代码（包括上传蒲公英），编写shell。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>蒲公英</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成之Jenkins搭建]]></title>
    <url>%2F2018%2F08%2F07%2FiOS%20%E5%BC%80%E5%8F%91%2F%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言对于一个APP来说，我相信我们开发最担心的就是出bug，只要是线上APP出bug，心里就慌得很，这是一件很严重的事情，还有可能让用户一气之下把你的APP删掉，从此再也不会出现在他的手机里面。 但是如果我们严格把控APP的质量，我们做到每天都构建一个版本并且测试，我们将这个APP上传到一个特定的测试系统，当有代码更新的时候或者每天设置一个时间去不断的跑测试，这样我们在开发阶段就发现很多问题。 上面我们说的就是CI(Continuous Integration)持续集成+TDD(Test Driven Development)测试驱动开发。 持续集成带来的好处持续集成带来的好处是显而易见的 减少风险。通过每天构建版本，在开发阶段就可以发现项目的缺陷，排除一些因为项目设置的低级错误而导致的bug，用同样的脚本和过程构建和测试软件，排除因代码外的其他因素。 减少重复的过程，提高效率。当项目变大之后，频繁的打包会很影响开发的效率，但是有了持续集成我们不用关心打包的过程，将重复的build,archive,code sign交给提供构建服务的机器去做，将时间放在更有意义的事情上面。 随时可部署。持续集成有一个好处就是我们每天都会做构建版本，可以交付部署上线，当我们无休止的讨论需求软件质量或者开发进度的时候，对于客户来说，不如一个可安装的软件包来得实际 持续集成之JenkinsCI包括三个基本的元素，第一个是可自动构建版本的服务，第二个是代码仓库，第三个是搭建了服务的机器。 可自动构建版本的服务目前有Jenkins和fastlane。代码仓库也就是我们平时使用的github,gitlab等等在iOS中机器必须是搭建OSX系统的机器，因为构建需要用到xcodeBuild命令，该命令由xcode提供，而xcode只能安装在OSX系统下面。 下面我们要说的就是可自动构建版本的服务，Jenkins。 Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性，构建完成之后通过脚本直接上传到分发平台或者测试平台。 Jenkins搭建jenkins有两种安装方式 一种是通过在官网下载pkg安装包的方式安装，图形化的安装界面直接跟着提示安装就好了。 第二种是通过homebrew安装，不过在安装之前我们需要检测本地环境是否已经安装了java，可以使用java -version来查看当前的java版本，如果没有安装的java的话可以在这里安装java。还要检测是否已经安装了homebrew,查看本机homebrew版本’brew -v’。 如果java和homebrew都已经安装好，就可以开始安装jenkins了 1brew install jenkins 当出现Jenkins is fully up and running之后，表明jenkins已经安装好了，如果没有自动打开http://localhost:8080 ，可以到网页上面自行打开该外地址。 上面给了一个地址，提示你去那里找到初始化的密码。打开/User/Shared/Jenkins/Home/secrets/initialAdminPassword复制出密码。 接下来会提示你安装一些插件，安装默认的插件即可，不过就算这里安装失败了也没关系，后面进到主界面还可以继续安装。 安装完插件之后会提示你创建一个jenkins用户。 输入这些信息之后点击save And Finish安装的过程就算完成了。接下来可以进入到jenkins主界面了。 我们主要关注一下面板左侧的选项，点击“系统管理”，然后找到“管理插件”在“可选插件”中选中“GitLab Plugin”和“Gitlab Hook Plugin”这两项，然后安装。安装Xcode插件同安装GitLab插件的步骤一样，我们依次选择系统管理-&gt;管理插件，在“可选插件”中选中“Xcode integration”安装，安装完这个插件我们还需要安装一个“Keychains and Provisioning Profiles Management”插件。这个插件用于我们设置签名和证书。 安装“Keychains and Provisioning Profiles Management”之后，我们去到系统管理-&gt;Keychains and Provisioning Profiles Management设置签名和证书。 这里需要选择 login.keychain ，在 /Users/用户名/Library/keychains/login.keychain 目录里。如果不能通过选择的话，可以把login.keychain拷贝到桌面，然后在选择上传。Code Signing Identity，可以添加多项。进入钥匙串，选择开发者证书或发布证书，拷贝完全，粘贴至Jenkins的Code Signing Identity项。 当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下 到这里Jenkins的搭建就算完成了，下一篇文章我们将会使用jenkins创建一个任务，然后构造版本并且上传蒲公英，最终的目的都是通过一个脚本来完成上述的操作。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用队列实现栈和用栈实现队列]]></title>
    <url>%2F2018%2F08%2F03%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%2F%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[用两个栈来实现队列，思路和用数组实现队列一样 12345678910111213141516171819202122232425262728293031323334353637383940//用栈实现队列struct QueueByStack&#123; var Peek: Int? &#123; mutating middleCaulate() return rightStack?.peek &#125; typealias Element = Int private var leftStack:IntergerStack? private var rightStack:IntergerStack? init() &#123; leftStack = IntergerStack() rightStack = IntergerStack() &#125; var isEmpty: Bool &#123;return leftStack!.isEmpty &amp;&amp; rightStack!.isEmpty&#125; var Size: Int &#123;return leftStack!.Size + rightStack!.Size&#125; mutating func middleCaulate()&#123; if leftStack!.isEmpty &#123; while !rightStack!.isEmpty&#123; leftStack!.push((rightStack?.pop())!) &#125; &#125; &#125; mutating func enQueue(_ newElement: Int) &#123; rightStack?.push(newElement) &#125; mutating func deQueue() -&gt; Int? &#123; middleCaulate() return leftStack?.peek &#125; &#125; 用两个队列来实现栈 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct StackByQueue &#123; private var queueA : IntergerQueue? private var queueB : IntergerQueue? init() &#123; queueA = IntergerQueue() queueB = IntergerQueue() &#125; var isEmpty: Bool&#123; get &#123; return queueA!.isEmpty &amp;&amp; queueB!.isEmpty &#125; &#125; var Size: Int &#123; get &#123; return queueA!.Size &#125; &#125; var peek: Int?&#123; mutating get &#123; transfer() let obj = queueB?.Peek swap() return obj &#125; &#125; mutating func push(_ newElement:Int)&#123; queueB?.enQueue(newElement) &#125; mutating func pop()-&gt;Int?&#123; transfer() let obj = queueB?.deQueue() swap() return obj &#125; mutating func transfer() &#123; if queueB?.Size != 1&#123; queueA?.enQueue((queueB?.deQueue())!) &#125; &#125; mutating func swap()&#123; (queueA,queueB) = (queueB,queueA) &#125;&#125;]]></content>
      <categories>
        <category>常见算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[swift实现栈和队列]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%2Fswift%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[在swift中并没有内设的栈和队列，接下来我们通过数组来实现栈和队列 栈的实现代码如下： 123456789101112131415161718192021222324252627protocol Stack &#123; associatedtype Element //是否为空 var isEmpty: Bool&#123; get &#125; //栈的大小 var Size: Int&#123; get &#125; //栈顶元素 var peek: Element? &#123; get &#125; //入栈 mutating func push(_ newElement:Element) //出栈 mutating func pop()-&gt;Element?&#125;struct IntegerStack:Stack &#123; typealias Element = Int private var stack = [Element]() var isEmpty: Bool &#123;return stack.isEmpty&#125; var Size: Int &#123;return stack.count&#125; var peek: Int? &#123;return stack.last&#125; mutating func push(_ newElement: Int) &#123; self.stack.append(newElement) &#125; func pop() -&gt; Int? &#123; return stack.last &#125;&#125; 队列的实现代码如下： 123456789101112131415161718192021222324252627protocol Queue &#123; associatedtype Element var isEmpty: Bool &#123;get&#125; var Size: Int &#123;get&#125; var Peek:Element? &#123;get&#125; mutating func enQueue(_ newElement:Element) mutating func deQueue()-&gt;Element?&#125;struct IntergerQueue:Queue &#123; typealias Element = Int private var left = [Element]() private var right = [Element]() var isEmpty: Bool &#123;return left.isEmpty &amp;&amp; right.isEmpty&#125; var Size: Int &#123;return left.count + right.count&#125; var Peek: Element? &#123;return left.isEmpty ? right.first : left.last&#125; mutating func enQueue(_ newElement: Int) &#123; right.append(newElement) &#125; mutating func deQueue() -&gt; Element? &#123; if left.isEmpty &#123; left = right.reversed() right.removeAll() &#125; return left.popLast() &#125;&#125;]]></content>
      <categories>
        <category>常见算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层设计方案以及去Model化实践]]></title>
    <url>%2F2018%2F08%2F02%2FiOS%20%E5%BC%80%E5%8F%91%2F%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E4%BB%A5%E5%8F%8A%E5%8E%BBModel%E5%8C%96%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[前言偶然在网上看到casa的网络层设计方案，在以前的iOS开发中，用的最多的就是集约型的网络请求+去Model的形式，然而在看完这篇文章之后我觉得好像发现了新大陆，原来还可以这么玩。 此网络层设计方案最大的好处就是解耦，每个API都有特定的APIManager管理，可以方便的缓存数据以及取消网络请求。 在集约型网络基础上封装了散约型的API，参数以及请求以及处理请求数据全部封装到该APIManager方法里面。 通过Delegate的方法回调，更好的方便调试以及释放对象。如果以block来调用的话首先不方便调试，其次会延长对象的生命周期，对象需要必须等到网络请求回来之后才能释放。 提供一个BaseAPIManager，然后通过IOP的方式约束子类必须要遵循APIRequestProtocol，通过实现该协议的方式来提供给API参数，这样父类就不用提供空载函数。 该父类还提供一个代理，该代理用于返回数据。 最后是去Model化的设计，APIRequestProtocol 提供了一个-(id)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer;协议方法，在该方法里面可以会传入一个遵守ReformProtocol协议的reformer，到时reformer就可以自定义处理数据的方法，返回特定的数据 ReformProtocol有一个- (id)reformDataWith:(LMBaseAPIManager*)apiManager;的协议方法，里面可以根据apiManager做判断，然后返回不同的数据，也就是说，一个reformer可以对应多个apiManager。 具体的原理和好处在case的文章里面已经说得很清楚了 项目结构： LMNetwork是具体的网络出口类，里面提供了集约化的网络请求方法，通过block返回数据。 LMBaseAPIManager是网络请求基类，里面有一个遵循了APIRequestProtocol协议的request，这个协议提供了网络请求参数的的方法和处理网络请求结果的方法。发送网络请求的时候会通过这个request获取必要的参数，以及返回数据的时候通过这个类处理数据。 该类还提供了一个遵循了APIResponseProtocol的代理对象，当网络返回数据的时候会调用该协议方法，该协议方法返回一个遵循APIRequestProtocol的request，调用方需要调用fetchDataWithReformer:方法，并且传入一个reformer，然后在该方法的实现里面就可以将apiManager传给reformer，reformer可以根据不同apiManager做不同的数据返回了。 LMBaseAPIManager还提供了两个属性，一个responseData和error，网络请求结果和错误都会放到这里面，到时将apiManager传到reformer的时候，通过这两个属性可以取出数据。 LMBaseAPIManager还可以提供一个isCache的方法，可以自己设置缓存策略。 总的来说，LMBaseAPIManager需要派生一个子类，然后子类需要实现apiRequestProtocol方法，提供网络必要的参数。调用startRequest方法之后调用LMNetwork发送网络请求。当网络请求回来之后，通过代理回调结果，并且将apiManager返回，调用方收到回调时候，传入reformer对数据进行处理。 LMReformerProtocol是一个协议，里面有一个协议方法- (id)reformDataWith:(LMBaseAPIManager*)apiManager;该方法用来处理返回数据。 LMProductionAPIManager是LMBaseAPIManagerd的派生类，里面提供了apiRequestProtocol协议方法的实现。 代码以上已经将框架介绍清楚了，下面是代码实现： 首先初始化productionAPIManager并且设计代理。 1234567- (LMProductionAPIManager *)productionAPIManager&#123; if(!_productionAPIManager)&#123; _productionAPIManager = [[LMProductionAPIManager alloc]init]; _productionAPIManager.response = self; &#125; return _productionAPIManager;&#125; 由于LMProductionAPIManager是LMBaseAPIManagerd的子类，因此会调用父类的init方法 12345678910- (instancetype)init&#123; if (self = [super init]) &#123; if ([self conformsToProtocol:@protocol(APIRequestProtocol)]) &#123; self.request = (id&lt;APIRequestProtocol&gt;)self; &#125;else&#123; NSAssert(NO, @&quot;子类必须要遵循APIRequestProtocol协议&quot;); &#125; &#125; return self;&#125; 由于子类遵循了 @interface LMProductionAPIManager: LMBaseAPIManager&lt;APIRequestProtocol&gt; APIRequestProtocol协议，因为该类内部有一个request的属性指向该对象。而该对象是遵循了上述的协议，所以要实现上述协议里面的方法，接下来看看LMProductionAPIManager里面的实现： 123456789101112131415161718192021@implementation LMProductionAPIManager- (NSString *)apiRequestName&#123; return @&quot;http://120.197.235.101:8080/apk/iosPagingQuery?pageNo=1&quot;;&#125;- (NSString *)apiRequestMethod&#123; return GET;&#125;- (NSDictionary *)apiRequestParameters&#123; return nil;&#125;- (id)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer&#123; if (reformer == nil) &#123; return self.responseData; &#125;else&#123; return [reformer reformDataWith:self]; &#125;&#125; 该对象内部提供了url以及get方法和参数，还提供处理返回数据的实现。 接下来调用 [self.productionAPIManager startRequest];方法，看看该方法内部会做什么： 12345678910111213 - (void)startRequest&#123; [[LMNetwork sharedInstance]requestMethod:[self.request apiRequestMethod] url:[self.request apiRequestName] parameters:[self.request apiRequestParameters] finishBlock:^(id data, NSError *error) &#123; if (error) &#123; self.responseError = error; &#125; else&#123; self.responseData = data; &#125; if ([self.response respondsToSelector:@selector(apiResponseSuccess:)]) &#123; [self.response apiResponseSuccess:self.request]; &#125; &#125;];&#125; 该方法会发送网络请求并且将请求后的数据复制给当前对象的相关属性，然后通过代理回到结果，并且将当前请求对象返回。 调用方收到代理之后进行处理 12345- (void)apiResponseSuccess:(id&lt;APIRequestProtocol&gt;)request&#123; [MBProgressHUD hideHUD]; self.productionArr = [request fetchDataWithReformer:[LMProductReformer new]]; [self.tableView reloadData]; &#125; 收到回调之后首先对初始化一个LMProductionReform对象，该对象遵循了LMReformerProtocol协议，待会再来看里面的实现。 然后调用request的协议方法 fetchDataWithReformer该方法的实现在第一点已经提到了，该方法内部会看一下有没有传reformer进来，如果没有的话直接返回未经处理的对象，如果有的话那就调用reformer的LMReformerProtocol协议方法。 接下来来看LMReformerProtocol方法的实现 123456789101112131415 - (id)reformDataWith:(LMBaseAPIManager *)apiManager&#123; //这里根据不同的APIManager返回相应的数据 if ([apiManager isKindOfClass: [LMProductionAPIManager class]]) &#123; NSDictionary *dict = apiManager.responseData; NSArray *list = dict[@&quot;list&quot;]; NSMutableArray *mArr = [NSMutableArray arrayWithCapacity:list.count]; for (NSDictionary *dict in list) &#123; NSDictionary *infoDict = @&#123;kLMProductionVer:dict[@&quot;ver&quot;],kLMProductionVerDesc:dict[@&quot;verDesc&quot;]&#125;; [mArr addObject:infoDict]; &#125; return mArr; &#125;else&#123; return nil; &#125;&#125; reform在这里根据不同的APIManager进行不同的解析，返回不同的数据。 到这里，整个网络和去model的设计就完成了。每个API都应该对应一个APIManager，但是可以使用同一个reformer，然后reformer对apimanager做判断从而返回不同的数据。 值得注意的是：由于我们用字典的形式来存储数据，所以肯定会有hardcode，我们可以定义一个头文件了里面包含所有我们用到的字符串常量，然后在reformer的实现文件里面给这些常量赋值。如在LMProductReformKeys.h中 12extern NSString *const kLMProductionVer;extern NSString *const kLMProductionVerDesc; 在LMProductReformer.m中 12NSString * const kLMProductionVer = @&quot;productionVer&quot;;NSString * const kLMProductionVerDesc = @&quot;productionVerDesc&quot;; 这样只要引入LMProductReformer.h都可以使用该常量。 完整的demo 以上。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>去model</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快行指针]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%2F%E5%BF%AB%E8%A1%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[快行指针的定义就是有两个指针访问链表，但是一个指针的速度比另外一个快，或者说一个指针在前，一个在后。 根据这个特性我们可以用来检测一个链表中是否有环。 假设：一个指针的速度是另外一个指针的两倍，它们同时开始访问同一个链表，如果链表有环的情况下，那么快行指针总会追上慢行指针，也就是总有一个时刻快行指针和慢行指针指向同一个节点，当慢行指针跑一圈的时候，快行指针此时刚好跑了两圈。以下是具体算法： 12345678910111213141516171819202122232425262728293031323334class ListNode:Equatable &#123;//遵守Equatable协议 static func == (lhs: ListNode, rhs: ListNode) -&gt; Bool &#123; if lhs.val == rhs.val &amp;&amp; lhs.next == rhs.next&#123; return true &#125;else&#123; return false &#125; &#125; public var val: Int public var next: ListNode? public init(_ val: Int) &#123; self.val = val self.next = nil &#125; &#125;class quickSolution &#123; func checkCycle(_ l1:ListNode?)-&gt;Bool&#123; guard let l1 = l1 else&#123; return false &#125; var slowNode:ListNode? = l1,fastNode:ListNode? = l1 while fastNode != nil &amp;&amp; fastNode?.next != nil &#123; slowNode = slowNode?.next fastNode = fastNode?.next!.next if slowNode == fastNode &#123; return true &#125; &#125; return false &#125;&#125; 另外，我们依然可以用这个方法来解决另外一个问题。删除链表中的第n个节点，例如：1-&gt;3-&gt;6-&gt;5-&gt;2 ，这里要删除倒数第2个节点。那么删除后的链表为： 1-&gt;3-&gt;6-&gt;2。 思路：假设快行指针从一开始就比慢行指针快n个节点，然后他们以相同的速度前进，当快行指针走到链表的最后一个节点的时候，慢行指针的当前节点的下一个节点就是我们要删除的节点。 代码如下： 123456789101112131415161718192021222324252627class DeleteSolution &#123; func deleteNode(_ l1:ListNode?,n:Int)-&gt;ListNode?&#123; guard let l1 = l1 else&#123; return nil &#125; let dummy = ListNode(0) dummy.next = l1 var slowNode:ListNode? = dummy var fastNode:ListNode? = dummy //设置快行指针比慢行指针快n个节点 for _ in 0 ..&lt; n &#123; if fastNode == nil &#123; break &#125; fastNode = fastNode?.next &#125; //同时移动两个指针 while fastNode != nil &amp;&amp; fastNode?.next != nil &#123; slowNode = slowNode?.next fastNode = fastNode?.next &#125; //删除需要删除的节点 slowNode?.next = slowNode?.next?.next return dummy.next &#125;&#125;]]></content>
      <categories>
        <category>常见算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dummy节点和尾巴插法]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%2Fdummy%E8%8A%82%E7%82%B9%E5%92%8C%E5%B0%BE%E5%B7%B4%E6%8F%92%E6%B3%95%2F</url>
    <content type="text"><![CDATA[给出一个链表和一个数X，要求将链表中所有小于X的值放到左边，等于或者大于X的值放到右边，并且原链表的节点顺序不变。 示例：假设： 1-&gt;7-&gt;3-&gt;5-&gt;2-&gt;8-&gt;4，给定x=4那么变换后的节点为： 1-&gt;3-&gt;2-&gt;7-&gt;5-&gt;8-&gt;4 思路：我们先把题目简单化，我们可以先找出链表中小于X的节点放到一个新的链表里面然后再找出等于或者大于X的节点放到另外一个条链表最后将第一条链表的next指向第二条链表的头结点，这样就完成了题目的要求。 代码如下： 123456789101112131415161718192021222324252627282930class ListNode &#123; public var val: Int public var next: ListNode? public init(_ val: Int) &#123; self.val = val self.next = nil &#125; &#125;class NewSoluction &#123; func getNewList(_ l1:ListNode?,x:Int)-&gt;ListNode?&#123; let headDummy = ListNode(0), tailDummy = ListNode(0) var head = headDummy,tail = tailDummy var node = l1 while node != nil &#123; if node!.val &lt; x &#123; head.next = node! head = node! &#125;else&#123; tail.next = node! tail = node!; &#125; node = node!.next &#125; tail.next = nil; //头链加上尾链 head.next = tailDummy.next return headDummy.next &#125;&#125; 注意：tail.next = nil 是为了防止形成环，因为tail.next = node ! ,tail = node这一句实际上是形成了环，所以需要将tail.next置空来打破环]]></content>
      <categories>
        <category>常见算法</category>
      </categories>
      <tags>
        <tag>链表结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 组件化实践《二》基于现有项目拆分组件化实践]]></title>
    <url>%2F2018%2F07%2F31%2FiOS%20%E5%BC%80%E5%8F%91%2F%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%BA%8C%E3%80%8B-%E5%9F%BA%E4%BA%8E%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[0x01 前言 在第一篇介绍中已经介绍了如果发布一个私有pod，下面将会介绍如何基于一个现有的项目拆分成组件化形式的项目。假设我们现有的项目是有一个AViewController,还有一个BViewController，目前的功能是点击rootViewController页面的按钮会push到AviewController，然后点击AviewController的一个按钮会跳转到BViewController。这里是未拆分的demo 0x02 拆分组件 现在我们要拆分AViewController和BViewController,将他们拆分成两个组件，并且按照Target-Action的形式提供对外的接口，通过中间件去调用Target对应的Action，在最上层是中间件的分类，给调用方提供具体且便利的方法和接口。 0x02.1 分析如何拆分AViewController 首先AViewController，现在AViewController需要外部传一个NSString类型的参数进去，然后返回一个AViewController的对象。这个时候应该创建一个Target_AViewController的类，然后对外一个Action_fectchAViewController:的方法，这个方法需要接收一个字典类型的参数，到时我们会从这个字典中取出key为navTitle的值来作为AViewController的参数。以下是该方法的实现： 123456 - (UIViewController*)Action_fetchAViewController:(NSDictionary*)params&#123; AViewController *aViewControlelr = [[AViewController alloc]init]; NSString *title = params[@&quot;navTitle&quot;]; aViewControlelr.navTitle = title; return aViewControlelr;&#125; 然后我们要创建CTMediator的分类CTMediator+ModuleAActions，这个分类方法对外提供了一个fetchAViewController的方法，到时调用方调用此方法即可获取到一个AViewController的实例，而不用自己去初始化AViewController。 那么上面那个分类具体做了什么操作呢，该方法会传一个“AViewController”和“fetchAViewController”来表明需要调用Target_AViewController的Action_fetchAViewller方法，也就是我们刚刚提供的Target_Action。本来调用方是不用通过类别来调用组件Target_Action的，因为可以通过CTMediator的perform Target: action: params:来直接调用。但是那样非常不友好以及不统一。加上了该分类之后，可以做更多的容错处理以及有一个容易的入口。 所以在后面做成pod的时候，category是一个pod，它只依赖于CTMediator，调用方法是通过CTMediator通过runtime来找到Target_Action来调用。所以另外一个pod就是AViewController+Target_AViewController。 12345678 - (UIViewController*)fetchAViewController&#123; UIViewController *vc = [self performTarget:@&quot;AViewController&quot; action:@&quot;fetchAViewController&quot; params:@&#123;@&quot;navTitle&quot;:@&quot;This is A ViewController&quot;&#125; shouldCacheTarget:NO]; if ([vc isKindOfClass:[UIViewController class]]) &#123; return vc; &#125;else&#123; return [[UIViewController alloc]init]; &#125;&#125; 以上提到的pod：CategoryAViewControllerAviewControllerPodCTMediactor 0x02.2 创建BViewController的category和Target_Action的pod1、为什么需要先创建BViewController组件，因为AViewController会依赖于BViewController，所以我们先创建BViewController组件。 2、首先我们先创建BViewController私有pod，按照我的组件化实践《一》创建好BViewController的pod，这个pod不用依赖于任何其他组件，所以应该没啥困难。 3、接下来我们需要创建BViewControllerCategory，这里有一点要注意的是在podspec文件的最下面需要加入s.dependency &#39;CTMediator&#39;，因为里面需要用到CTMediator的perform方法去调用到对应的组件。因为CTMediator已经发布到cocoapods所以可以直接用，如果这里的依赖是你自己改动之后的私有Mediator，记得在pod spec lint 的时候要加上--sources=yourgithub/spec,master将源改成你自己的私有索引库的地址，不然默认是从公有索引库里面找不到对应的Mediator。待会在AViewController调用B的时候会用到这个命令。 0x02.3 创建AViewController的category和Target_Action的pod1、方法同上，首先创建AViewController的Category组件，这里只需要注意在podspec文件的最下面需要加入s.dependency &#39;CTMediator&#39;。2、 然后我们创建AViewController私有pod，由于在AViewController里面我们有个按钮点击之后会push到BViewController，那必然要引入BViewController，但是在组件中不会直接引入BViewController，我们通过引入BViewControllerCategory来让程序编译的时候不要报错就行。podspec文件要加入s.dependency &#39;BCategory&#39;。 3、 验证，因为第二部中我们的私有工程依赖了另外一个私有工程，这个时候的pod spec lint和 pod repo push命令都要加上 --source说明 注意：组件间的调用依然是利用Target对应的分类来调用。记住分类是统一的入口，组件里面的代码不会依赖于另外一个组件，而是依赖于对应的分类组件或者CTMediator，然后所有依赖的pod都要写到主工程的podfile里面 0x03 引用组件我们将AViewController和BViewController拆分后，我们创建一个demo来测试一下刚刚拆分的组件。创建一个OC项目，在项目的跟目录下执行pod init，然后在podfile文件里面写入以下内容： 123456789101112source &apos;https://github.com/codemonkeybulucck/LMSpec&apos;source &apos;https://github.com/CocoaPods/Specs.git&apos;target &apos;moduleTest&apos; do # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks # use_frameworks! pod &apos;ACategory&apos; pod &apos;AViewController&apos;,&apos;~&gt;0.1.1&apos; pod &apos;BViewController&apos; # Pods for moduleTestend 完成后执行 pod install，成功之后再#import &quot;CTMediator+ModuleAActions.h&quot; 然后调用方式就变成了UIViewController *vc = [[CTMediator sharedInstance] fetchAViewController]; 0x04 总结组件化最核心的思想就是解耦，将庞大的项目抽丝剥茧，分离成互相独立的一个一个模块，每个模块都是可复用的。上述的方案其实已经做到了解耦，调用者只需要用到中间件的分类的方法接口而不需要引入实际的组件的类。但是在分类里面有一个弊端就是：动态调用方法的时候需要硬编码也就是，这样容错率就很低，不过幸好这个东西是在分类中，在开发的过程中就可以发现的问题。另外一个方面也不是所有的项目都适合用组件化，只有当项目规模扩大到一定的程度，并且人员众多的情况下用组件化的便捷性才体现出来。所以很多时候我们讨论架构或者讨论一种新的技术，并不是它就是最好的，没有什么东西是最好的，只有最合适的，因地制宜。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>cocoapods</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无重复字符的最长子串]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%2F%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[无重复字符的最长子串给定一个字符串，找出不含有重复字符的最长子串的长度。 示例： 给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。 给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。 给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列 而不是子串。 leetcode链接 解答思路： 首先从头开始遍历字符串，并且将已经遍历过的字符串放到一个数组里面 但是放到数组里面的前提是当前遍历的字符并不存在在数组当中，也就是如果当前遍历的字符不在数组中，那么就将字符放到数组中，开始下一次遍历 如果当前当前的字符在数组中，那么找到该字符在数组中的下标，删除数组中从下标为0到该字符下标区间的元素，然后将当前字符放到数组里面开始下一次遍历。 每遍历一次，都要判断上一次的最长字符串maxCount是否小于当前数组的元素的数量，如果是，那么就更新maxCount。 下面是代码实现： 12345678910111213141516171819fileprivate func _maxLongString(s:String!)-&gt;Int&#123; if s.count == 0 &#123; return 0 &#125; var subArr = [CChar]() var maxCount = 0; var array = s.cString(using:.utf8)! array.removeLast() //由于字符串会有一个结束符，所以需要删掉最后的结束符 for str in array&#123; if subArr.contains(str) &#123; let index:Int = subArr.index(of: str)! let empty = 0..&lt;index+1 subArr.removeSubrange(empty) &#125; subArr.append(str) maxCount = max(maxCount, subArr.count) &#125; return maxCount &#125;]]></content>
      <categories>
        <category>常见算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[非空链表相加]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%2F%E9%9D%9E%E7%A9%BA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 思路： 只要两个非空链表中的其中一个链表不为空的时候就循环便利两个链表 如果其中一个链表为空而另外一个链表不为空，那么为空的那个链表的值就为0 用一个carry位来表示是否有进位，0代表无进位，1代表有进位，因为链表中都是个位数，所以最大进位也只能为1，初始化进位为0 用x,y来表示当前两个链表的值，sum = x+y+carry为新链表的值，但是有可能有进位，所以新的carry = sum / 10,当前节点位的值为sum = sum %10。 创建一个新节点，将上述中sum的值赋给新节点，然后将新链表当前节点的next指向新节点，然后将当前节点指向到新节点 两个链表的当前节点都要指向下一个节点 当遍历完成之后，还需要判断一下carry的值是不是大于0，如果大于0则代表还需要创建一个节点，并且将新链表的节点的next指向该节点 以下是代码实现： 123456789101112131415161718192021222324252627282930313233343536373839class ListNode &#123; public var val: Int public var next: ListNode? public init(_ val: Int) &#123; self.val = val self.next = nil &#125; &#125;class Solution &#123; func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123; let resultNode = ListNode(0) var currentNode = resultNode var p = l1 var q = l2 var carry = 0 //表示进位 while p != nil || q != nil &#123; //获取当前的值 var x = 0,y = 0; if let p = p &#123; x = p.val &#125; if let q = q &#123; y = q.val &#125; let sum = x + y + carry carry = sum / 10 let newSum = sum % 10; currentNode.next = ListNode(newSum) currentNode = currentNode.next! p = p?.next q = q?.next &#125; if carry &gt; 0 &#123; currentNode.next = ListNode(carry) &#125; return resultNode.next &#125;&#125;]]></content>
      <categories>
        <category>常见算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 组件化实践《一》创建私有pod]]></title>
    <url>%2F2018%2F07%2F30%2FiOS%20%E5%BC%80%E5%8F%91%2F%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%B8%80%E3%80%8B%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89pod%2F</url>
    <content type="text"><![CDATA[0x01 前言本次组件化实践的方式来自于casaty组件化方案，该方案是基于target-action模式和Mediator模式，通过Mediator利用runtime的机制来调用对应的target-action。并且在上层通过category的方式暴露对外调用的接口，这样调用者在调用的时候就知道需要传递哪些参数。 具体的调用方式就是： 实际上是可以不使用category的形式而是直接调用CTMediactor的- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget 方法直接调用对应target的action，但是那样对于调用方来说极其不友好，最直观的感受就是不知道params应该传哪些参数。 利用catogory的方式暴露方法的好处在于1、一个组件对应一个category，每个category提供了组件所有的调用方法，调用方直接调用，可以直观的看到需要传递哪些参数。2、提供统一的调用入口，所有的组件的被调用都是通过category3、可以做异常处理，将参数的校验提前，并且可以做请求转发。 0x02 组件化实践在简单的介绍了组件化的实际逻辑之后下面开始真正的开始动手实现组件化实践流程。 一个私有pod的创建具体分为以下几步： 创建工程 创建私有库，修改podSpec文件，将本地代码库和远程代码库关联起来，上传代码到远程仓库。 创建远程索引库和本地索引库，也就是用于放置podspec的地方，每个podspec文件可以索引到我们远程不同的代码私有库 本地测试podspec文件是否可用 向索引库Spec Repo中提交podspec 测试Spec Repo中的的 podspec 是否可用 1、 首先到github里面创建一个空的工程，例如我要创建一个FirstViewController 2、 创建私有库，终端运行pod lib create FirstViewController 123456789101112131415161718192021222324252627282930313233343536373839Lemons-MacBookPro:Module lemon$ pod lib create FirstViewControllerCloning `https://github.com/CocoaPods/pod-template.git` into `FirstViewController`.Configuring FirstViewController template.------------------------------To get you started we need to ask a few questions, this should only take a minute.If this is your first time we recommend running through with the guide: - https://guides.cocoapods.org/making/using-pod-lib-create.html ( hold cmd and click links to open in a browser. )What platform do you want to use?? [ iOS / macOS ] &gt; iOS //pod平台What language do you want to use?? [ Swift / ObjC ] &gt; ObjC //pod语言Would you like to include a demo application with your library? [ Yes / No ] &gt; No //是否需要提供demoWhich testing frameworks will you use? [ Specta / Kiwi / None ] &gt; None //测试框架Would you like to do view based testing? [ Yes / No ] &gt; No //是否需要测试视图What is your class prefix? &gt; LM //demo类前缀Running pod install on your new library.Analyzing dependenciesFetching podspec for `FirstViewController` from `../`Downloading dependenciesInstalling FirstViewController (0.1.0)Generating Pods projectIntegrating client project 上述命令执行完成之后会本地帮我们生成一个pod的模板文件，我们在这里首先需要改动的就是FirstViewController.podspec文件，用xcode打开该文件。目前我们需要注意下面几处地方： s.version = &#39;1.0.0&#39; //pod的版本，后面将podSpec文件提交到私有repo的时候会验证远程的仓库中是否已经存在对应的tag，所以这个要与后面提交代码的时候的tag相同,我们先修改为1.0.0，可以按照你们自己的标准修改。 s.homepage = &#39;https://github.com/codemonkeybulucck/FirstViewController&#39; //homepage这里填写在第一步中再github创建的远程仓库的地址即可。 s.source = { :git =&gt; &#39;https://github.com/codemonkeybulucck/FirstViewController.git&#39;, :tag =&gt; s.version.to_s } //这里填写远程仓库的地址，记得后面要加上.git的后缀 s.ios.deployment_target = &#39;8.0&#39; //该pod的最低运行环境 s.source_files = &#39;FirstViewController/Classes/**/*&#39; //pod中源代码的路径，后面会将实际的代码放在Classes文件夹下面 一些其他设置的说明： s.summary = ‘A short description of FirstViewController.’ //pod的简述 s.description = &lt;&lt;-DESC //具体描述 s.license = { :type =&gt; ‘MIT’, :file =&gt; ‘LICENSE’ } //许可证 s.author = { &#39;545390087@qq.com‘ =&gt; &#39;codebulucck@163.com‘ } //作者信息 s.dependency ‘AFNetworking’, ‘~&gt; 2.3’ //依赖库，如果该pod依赖其他pod，可以在此处加上。 完成podspec文件修改之后我们可以将对应的组件代码放到Classes文件夹路径下面。下面将本地代码库和远程代码库关联起来，然后将本地代码推送到远程仓库。 123456789101112131415161718192021222324252627282930313233343536373839Lemons-MacBookPro:FirstViewController lemon$ git remote add origin https://github.com/codemonkeybulucck/FirstViewController.gitLemons-MacBookPro:FirstViewController lemon$ git add .Lemons-MacBookPro:FirstViewController lemon$ git commit -m &quot;初始化&quot;[master 8ac032c] 初始化 25 files changed, 1209 insertions(+) create mode 100644 Example/FirstViewController.xcworkspace/contents.xcworkspacedata create mode 100644 Example/FirstViewController.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist create mode 100644 Example/Podfile.lock create mode 100644 Example/Pods/Local Podspecs/FirstViewController.podspec.json create mode 100644 Example/Pods/Manifest.lock create mode 100644 Example/Pods/Pods.xcodeproj/project.pbxproj create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-dummy.m create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-prefix.pch create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-umbrella.h create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController.modulemap create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController.xcconfig create mode 100644 Example/Pods/Target Support Files/FirstViewController/Info.plist create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Info.plist create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-acknowledgements.markdown create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-acknowledgements.plist create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-dummy.m create mode 100755 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-frameworks.sh create mode 100755 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-resources.sh create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-umbrella.h create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.debug.xcconfig create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.modulemap create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.release.xcconfig create mode 100644 FirstViewController/Classes/FirstViewController.h create mode 100644 FirstViewController/Classes/FirstViewController.m delete mode 100644 FirstViewController/Classes/ReplaceMe.mLemons-MacBookPro:FirstViewController lemon$ git push origin masterCounting objects: 62, done.Delta compression using up to 4 threads.Compressing objects: 100% (55/55), done.Writing objects: 100% (62/62), 23.04 KiB | 2.56 MiB/s, done.Total 62 (delta 10), reused 0 (delta 0)remote: Resolving deltas: 100% (10/10), done.To https://github.com/codemonkeybulucck/FirstViewController.git * [new branch] master -&gt; master 3、 创建远程索引库和本地索引库，同样在github创建一个新的仓库，仓库的名字叫做LMSpec，这个仓库是pod的索引库，也就是后面如果要引用组件pod的话只要引入这个LMSpec就能从里面找到对应的组件。 创建完远程仓库之后我们创建一个本地索引库，并且将本地索引库和远程仓库连接起来。 pod repo add LMSpec https://github.com/codemonkeybulucck/LMSpec.git 执行完这条命令之后，去到 ~/.cocoapods/repo路径下就能看到有一个master和LMSpec，master是公有cocoapod的索引库，LMSpec就是我们自己新建的索引库。到此我们已经创建好代码库以及索引库了。 4、本地测试podspec文件是否可用 本地测试podspec文件是否可用。 1234567Lemons-MacBookPro:FirstViewController lemon$ pod lib lint -&gt; FirstViewController (1.0.0) - WARN | summary: The summary is not meaningful.[!] FirstViewController did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it).You can use the `--no-clean` option to inspect any issue. 上述验证表明我们本地验证已经没有错误了，但是有一个警告，我们可以使用pod lib lint --allow-warnings来忽略警告。如果我们使用pod spec lint来验证的话，记得要先本地代码库打tag然后将tag推动到远程仓库才能通过验证，因为该命令是同时验证本地和远程仓库，因为我们还没有打tag推送到远程仓库，所以我们先用pod lib lint来验证。 5、 向索引库Spec Repo中提交podspec 在第四步中我们已经验证我们的podspec文件没有问题了，但是我们现在还不能推送到索引库，因为我们还没有打tag，这个tag应该是与podspec文件里面的version一致，不一致的话远程验证的时候是通不过验证的。 1234567Lemons-MacBookPro:FirstViewController lemon$ git tag -a 1.0.0 -m &quot;第一个版本pod&quot;Lemons-MacBookPro:FirstViewController lemon$ git push origin master 1.0.0Counting objects: 1, done.Writing objects: 100% (1/1), 183 bytes | 183.00 KiB/s, done.Total 1 (delta 0), reused 0 (delta 0)To https://github.com/codemonkeybulucck/FirstViewController.git * [new tag] 1.0.0 -&gt; 1.0.0 完成上述步骤后我们需要将podspec提交到索引库中。 123456789101112131415Lemons-MacBookPro:FirstViewController lemon$ pod repo push LMSpec FirstViewController.podspec --allow-warningsValidating spec -&gt; FirstViewController (1.0.0) - WARN | summary: The summary is not meaningful.Updating the `LMSpec&apos; repoAlready up to date.Adding the spec to the `LMSpec&apos; repo - [Add] FirstViewController (1.0.0)Pushing the `LMSpec&apos; repo 至此为止我们已经将podspec文件推送到本地LMSpec和远程LMSpec里面了，可以到 ~/.cocoapods/repo/LMSpec文件夹下看有没有对应FirstViewControll文件夹。该文件夹下会有一个1.0.0的文件夹，也就是我们刚刚打的tag的数值。后续如果修改代码需要重新打tag,然后到时这里也会出现新的版本的代码。注 如果该私有库里面引用了其他的私有库，也就是podspec文件中s.dependency引用了其他私有库的信息，需要指定私有库的位置，那么推送命令将变为 pod repo push LMSpec FirstViewController.podspec --allow-warnings --sources=https://github.com/codemonkeybulucck/LMSpec,master 6、 测试Spec Repo中的的 podspec 是否可用创建一个ModuleTest的工程，进入到工程里面先执行 pod init ，然后编辑podfile文件 12345678910source &apos;https://github.com/codemonkeybulucck/LMSpec&apos;source &apos;https://github.com/CocoaPods/Specs.git&apos;target &apos;moduleTest&apos; do # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks # use_frameworks! pod &apos;FirstViewController&apos; # Pods for moduleTestend 执行pod install如果没出错就代表私有库已经添加成功。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2018%2F07%2F29%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[两数之和给定一个数组和一个目标数，判断数组中是否有两个数的和等于该目标数，如果存在则输出它们在数组中的序号。 解法1：第一眼看到上述题目我们第一时间的反应应该是通过两个循环遍历来找出它们的序号。第一个循环找出一个数X，然后用目标数减去该数值X得到第二个数Y，然后第二次循环找出有没有与Y相等的数值。这样时间的复杂度是O(n²)。 解法2：我们可以通过使用字典的的方式，数值作为字典的key，数组下标作为字典的value。我们可以在第一次便利的时候，用目标数减去循环得到的数X，然后得到目标数Y，然后判断字典中有没有以Y作为key的value。如果有的话，那么此次循环的i就是第一个数值的下标，以Y作为key那个value就是第二个数值的下标。如果不存在则将该次循环的下标和数值保存到字典里面。继续下一次遍历。以下是Swift代码示例： 123456789101112fileprivate func _sum(_ array:[Int],targetNum:Int)-&gt;[Int]&#123; var dict = [Int:Int]() for(i,num) in array.enumerated()&#123; let secondNum = targetNum - num if let secondIndex = dict[secondNum]&#123; return [i,secondIndex] &#125;else&#123; dict[num] = i &#125; &#125; return [0,0] &#125;]]></content>
      <categories>
        <category>常见算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符串反转算法]]></title>
    <url>%2F2018%2F07%2F29%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串反转给定一个字符串，要求按照其按照单词的顺序进行反转即： oc is the best language反转后的字符串应该为： language is the bast oc 思路：我们首先可以对给定的字符串进行普通的反转，然后将反转后的字符串进行切割成单词只有再反转会正常的单词。swift实现如下： 12345678910111213141516171819fileprivate func _reverseWold(_ s: String?)-&gt;String?&#123; //首先先对整体字符串反转 guard let s = s else &#123; return nil &#125; let rs = String(s.reversed()) //对反转后的字符串在切割成单词反转 var result = String() let array = rs.split(separator: &quot; &quot;) for (i,word) in array.enumerated()&#123; let rw = String(word.reversed()) if i != array.count-1&#123; result.append(rw+&quot; &quot;) &#125;else&#123; result.append(rw) &#125; &#125; return result; &#125;]]></content>
      <categories>
        <category>常见算法</category>
      </categories>
      <tags>
        <tag>字符串反转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS防止被逆向调试]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E5%BC%80%E5%8F%91%2FiOS%E9%98%B2%E6%AD%A2%E8%A2%AB%E9%80%86%E5%90%91%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[0x01 反调试主要分为两种，第一种阻止调试器附加，第二种是检测是否有调试器存在 0x02第一种方法： 0x01 ptrace ptrace是系统用来对运行中的进程进行调试和跟踪的工具，通过ptrace，可以对另一个进程实现调试跟踪。但是里面提供了一个非常有用的参数，就是PT_DENY_ATTACH，const值是31，这个参数用户告诉系统阻止调试器附加。在main.m里面加入以下代码： 1234567891011121314151617181920#import &lt;UIKit/UIKit.h&gt;#import &quot;AppDelegate.h&quot;#import &lt;dlfcn.h&gt;#import &lt;sys/types.h&gt;typedef int (*ptrace_ptr_t)(int _request,pid_t pid,caddr_t _addr,int _data);#ifndef PT_DENY_ATTACH#define PT_DENY_ATTACH 31#endifint main(int argc, char * argv[]) &#123; @autoreleasepool &#123; // ptrace(PT_DENY_ATTACH,0,0,0); //系统函数并没有暴露出此方法所以不能直接通过此方式调用 void *handle = dlopen(0, RTLD_NOW|RTLD_GLOBAL); ptrace_ptr_t ptrace_ptr = (ptrace_ptr_t)dlsym(handle, &quot;ptrace&quot;); ptrace_ptr(PT_DENY_ATTACH,0,0,0); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 在上面的代码中，本来是直接调用上面被注释的那一行代码就可以了，不过由于不是公开的函数所以没法直接调用。所以我们通过dlopen的方式，当path 参数为0是,他会自动查找 $LD_LIBRARY_PATH,$DYLD_LIBRARY_PATH, $DYLD_FALLBACK_LIBRARY_PATH 和 当前工作目录中的动态链接库，通过句柄找到对应的ptarce对应的地址，然后传入PT_DENY_ATTACH。 0x02 syscall 另外一种方式可以使用syscall的方式来调用ptrace，syscall是系统提供的一个系统调用函数，因为上面的调用方式会容易被反反调试，通过NSFindSymbol找到_ptrace然后hook对应的函数，所以可以最好是通过syscall来反调试在Kernel Syscalls里面找到ptrace对应的const。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$ joker -u ~/Documents/projects/iOS.6.0.iPod4.kernel This is an ARM binary. Applying iOS kernel signaturesEntry point is 0x80085084....This appears to be XNU 2107.2.33Syscall names are @2a70f0Sysent offset in file/memory (for patching purposes): 0x2ef0c0/0x802f00c0Suppressing enosys (0x800b3429) T = Thumb1. exit 801d4a74 T2. fork 801d7980 T3. read 801eb584 T4. write 801eb958 T5. open 800b13a4 T6. close 801ccab4 T7. wait4 801d56bc T9. link 800b18e8 T10. unlink 800b1ff0 T12. chdir 800b0c60 T13. fchdir 800b0af0 T14. mknod 800b14bc T15. chmod 800b2b40 T16. chown 800b2c9c T18. getfsstat 800b088c T20. getpid 801dc20c T23. setuid 801dc4c0 T24. getuid 801dc290 T25. geteuid 801dc2a0 T26. ptrace 801e812c T27. recvmsg 8020a8fc T28. sendmsg 8020a444 T29. recvfrom 8020a528 T30. accept 80209dfc T31. getpeername 8020abc8 T32. getsockname 8020ab18 T33. access 800b24ac T34. chflags 800b2928 T35. fchflags 800b29f0 T36. sync 800b0320 T37. kill 801dfdcc T39. getppid 801dc214 T41. dup 801cab04 T42. pipe 801edbe4 T43. getegid 801dc318 T46. sigaction 801deee8 T47. getgid 801dc308 T48. sigprocmask 801df42c T49. getlogin 801dd0e8 T50. setlogin 801dd160 T51. acct 801c54ec T52. sigpending 801df5d0 T 注意一下代码中的26就是ptrace的const。综上所述：调用syscall(26,31,0,0,0)就可以达到反调试的目的。 0x03 sysctl 可以通过sysctl查看内核进程状态标志位，如果一个进程在调试状态，会有一个标志位（info.kp_proc.p_flag）来标识当前是否正在调试。代码如下： 1234567891011121314151617BOOL existDebugger()&#123; int name[4];//指定查询信息的数组 struct kinfo_proc info;//查询的返回结果 size_t info_size = sizeof(info); info.kp_proc.p_flag = 0; name[0] = CTL_KERN; name[1] = KERN_PROC; name[2] = KERN_PROC_PID; name[3] = getpid(); if (sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0) == -1) &#123; NSLog(@&quot;sysctl error ...&quot;); return NO; &#125; return ((info.kp_proc.p_flag &amp; P_TRACED) != 0); &#125; 可以定时执行以上代码，当检测到程序正在被调试，可以调用exit(0)来让程序奔溃或者做其他的操作 0x04 syscall可以通过软中断实现从用户态切换到系统内核态的转换，同时可以通过arm 汇编实现以上功能。通过asm volatile内联汇编，实际上也是调用了ptrace。代码如下： 1234567891011121314151617181920#ifdef __arm__ asm volatile( &quot;mov r0,#31\n&quot; &quot;mov r1,#0\n&quot; &quot;mov r2,#0\n&quot; &quot;mov r12,#26\n&quot; &quot;svc #80\n&quot; );#endif#ifdef __arm64__ asm volatile( &quot;mov x0,#26\n&quot; &quot;mov x1,#31\n&quot; &quot;mov x2,#0\n&quot; &quot;mov x3,#0\n&quot; &quot;mov x16,#0\n&quot; &quot;svc #128\n&quot; );#endif]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>反调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS字符串加密以及静态混淆]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E5%BC%80%E5%8F%91%2FiOS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E6%B7%B7%E6%B7%86%2F</url>
    <content type="text"><![CDATA[0x01 字符串加密 0x01在开发中我们总是会用到加解密，有些同学可能不注意会直接把对称加密的key直接写到程序中，这样使用Hopper或者IDA静态分析的时候是可以直接看到加密的key，这样容易被别人破解，所以需要采用一些方法对文件里面的key进行加密，使得在静态分析阶段无法直接获取加密的key，增加逆向难度。 0x02在这里我们可以使用异或计算方法对某一个key进行加密，异或的原理是如果二进制位相同则为0，不相同则为1，如果a^b = c,那么b^c=a。 代码参考如下： 123456789101112131415161718192021#define XOR_KEY 0xBBvoid xorString(unsigned char *str, unsigned char key)&#123; unsigned char *p = str; while( ((*p) ^= key) != &apos;\0&apos;) p++;&#125;- (void)testFunction&#123; unsigned char str[] = &#123;(XOR_KEY ^ &apos;e&apos;), (XOR_KEY ^ &apos;n&apos;), (XOR_KEY ^ &apos;k&apos;), (XOR_KEY ^ &apos;e&apos;), (XOR_KEY ^ &apos;y&apos;), (XOR_KEY ^ &apos;\0&apos;)&#125;; xorString(str, XOR_KEY); static unsigned char result[6]; memcpy(result, str, 6); NSLog(@&quot;%s&quot;,result); //output: enkey&#125; 0x03如果在工程中需要加密的字符串很多，这个时候就要遍历文件进行加密，这个时候如果手动查找的话那工作量就会很大，还好Clang可以帮助我们完成这个事情。iOS中有一个libClang提供了Clang的C接口，用于源代码转换成抽象语法树，并对抽象语法树进行便利和分析。具体的操作思路可以看iOS加固浅谈之字符串加密 0x02 类和方法加密 0x01如果对程序的安全要求更高一点，可以对程序中所有的类和方法进行混淆，也就是用一些乱序无意义的字符串来对程序的类和方法进行替换。但是这个方法有一个弊端，至于什么弊端会在0x04说明 0x02第一种混淆方法是宏定义，通过增加一个pch文件，在pch文件中将类名和方法名定义成一些无意义的字符串，然后配置prefix Header的路径为pch的路径，这样在静态分析的时候看到的就是乱序的字符串。以下为PCH的内容 123456789101112131415#ifndef PrefixHeader_pch#define PrefixHeader_pch// Classes#ifndef TestClass#define TestClass l4prfxSkn#endif// Methods#ifndef testClasssMehtod#define testClasssMehtod l9b0e29rLKJNqI23#endif // testClasssMehtod#ifndef testInstanceMethod#define testInstanceMethod e0lvc2hezXEA2jIBNw#endif // testInstanceMethod#endif /* PrefixHeader_pch */ 下面是testClass.h 1234567#import &lt;Foundation/Foundation.h&gt;@interface TestClass : NSObject@property (nonatomic,copy) NSString *name;- (void)testInstanceMethod;+ (void)testClasssMehtod;@end 静态分析截图 通过上面我们已经可以看到静态分析之后完全看不出上面是哪个类调用了哪个方法。 0x03和字符串加密一样，一个项目中肯定有很多类和很多方法，如果我们手动去宏定义的话那这是一个巨大的工作量，不过还好Github已经有现成的项目来帮我们生成宏定义。ios-class-guard这个项目可以把所有使用系统库符号的dump下来并过滤掉，只生成用户需要混淆的符号。然后将生成的符号添加到pch文件里面即可 0x04上面无序随机字符串加密的弊端就是在提交到AppStore审核的时候，苹果会认为你的APP可能会存在隐藏的功能然后拒接你的上架。另外一种解决方法就是将上线无序随机字符串换成有意义的单词，使得方法名看起来是有意义的，但是它的意义却不是该方法真正的作用。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLDB解密framework]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E9%80%86%E5%90%91%2FLLDB%E8%A7%A3%E5%AF%86framework%2F</url>
    <content type="text"><![CDATA[除了使用dumpdecrypted去解密APP和framework的内容以外，也可以使用LLDB直接从内存中dump出解密后的模块。 0x1获取framework文件，查看文件对应的偏移以下是要执行的命令以及解释： 1234567lemons-iPhone5S:~ root# ps aux | grep WeChat //查看Wechat的沙盒目录mobile 2636 0.0 2.7 1019472 27476 ?? Ss 9:14AM 0:15.37 /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app/WeChatroot 3316 0.0 0.0 525920 224 s001 R+ 4:52PM 0:00.01 grep WeChatlemons-iPhone5S:~ root# /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app-sh: /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app: is a directorylemons-iPhone5S:~ root# cd /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app找到对应的MMCommon.framework，将MMCommon.framework复制到mac 0x2在mac查看MMCommon.framework的加密偏移 123cd MMCommon.frameworkotool -hf MMCommon //查看MMcommon的文件头部的基础信息otool -arch arm64 -l MMCommon | grep crypt //获取64位机器加密数据信息 0x3使用LLDB附加越狱机器，查看MMcommon进程的偏移image list MMCommon通过如下命令dump出解密后的二进制数据memory read –force –outfile ~/Desktop/outputStream –binary –count 3928342 16384+0x00000000384829894 3928342 是在上述otool -arch 命令中获取到的cryptsize的值，表明当加密数据的的大小 16384 是在上述otool -arch命令汇总获取到的cryptoff的值，代表加密的数据在MMCommon中偏移 0x00000000384829894 是在上述image list MMCommon中的模块基地址 上述命令执行完成之后会在桌面生成一个outputStream文件 0x4修复文件，因为dump出来的文件都没有mach-O文件头，所以需要把dump出来的数据放回原来的framework里面，替换原来加密的数据 dd seek=2384834 bs=1 conv=notrunc if=/Users/lemon/Desktop/outputSteam of=./MMCommon lipo MMCommon -thin arm64 -output MMCommon_arm64 2384834是上述otool -hf的时候architecture 1中的offset的值加上16384（加密数据偏移的值），两者相加，得到了写入的加密数据在文件中的偏移值。 替换之后，使用lipo 从FAT文件中提取arm64架构的文件。将MMcommon_arm64拖到MachOView中，修改cryptid为00000000。]]></content>
      <categories>
        <category>iOS 逆向</category>
      </categories>
      <tags>
        <tag>LLDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dumpdecrypted介绍及其使用]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E9%80%86%E5%90%91%2Fdumpdecrypted%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.介绍 dumpdecrypted 是一个开源的工具，它会注入可执行文件中，动态的从内存中dump解密后的内容。 ##2.原始版dumpdecrypted使用 ###2.1下载以及编译dumpdecrypted 从github下载源代码并且编译： 12345678MacBookPro:dumpdecrypted lemon$ git clone https://github.com/stefanesser/dumpdecrypted.gitCloning into &apos;dumpdecrypted&apos;...remote: Counting objects: 31, done.remote: Total 31 (delta 0), reused 0 (delta 0), pack-reused 31Unpacking objects: 100% (31/31), done.MacBookPro:dumpdecrypted lemon$ cd dumpdecrypted/MacBookPro:dumpdecrypted lemon$ make`xcrun --sdk iphoneos --find gcc` -Os -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -c -o dumpdecrypted.o dumpdecrypted.c 2.2 用PS命令定位待解密的可执行文件12345MacBookPro:~ lemon$ ssh 5slemons-iPhone5S:~ root# ps -e | grep /var 481 ?? 0:05.44 /usr/libexec/pkd -d/var/db/PlugInKit-Annotations 6707 ?? 0:06.07 /var/containers/Bundle/Application/4503A878-7B82-46C3-B938-8D8719A6D78E/Friday.app/Friday 6715 ttys000 0:00.01 grep /var 2.3 获取目标APP的document目录123lemons-iPhone5S:~ root# cat /var/containers/Bundle/Application/4503A878-7B82-46C3-B938-8D8719A6D78E/Friday.app/Info.plist | grep CFBundleIdentifier -A 1 &lt;key&gt;CFBundleIdentifier&lt;/key&gt; &lt;string&gt;com.xtuone.Friday&lt;/string&gt; 2.4 将dylib复制到document目录2.4.1 通过私有api获取目标app的document目录 新建一个xcode项目，将以下代码复制到APPDelegate的application:didfinishLaunchingWithOptions:下，然后运行项目，就可以在控制器输出document的目录 123NSString *bundleId = @&quot;com.xtuone.Friday&quot;; NSURL *url = [[NSClassFromString(@&quot;LSApplicationProxy&quot;) performSelector:@selector(applicationProxyForIdentifier:) withObject:bundleId]performSelector:@selector(dataContainerURL)]; NSLog(@&quot;%@&quot;,[url.absoluteString stringByAppendingString:@&quot;/Documents&quot;]); 通过以上代码获得的document目录是：/var/mobile/Containers/Data/Application/06B16FDB-4EA1-4093-A729-613111061798/Documents ####2.4.2 通过cycript获取目标app的document目录 123456lemons-iPhone5S:~ root# cycript -p 6707cy# [[NSBundle mainBundle]bundleIdentifier]@&quot;com.xtuone.Friday&quot;cy# NSHomeDirectory()@&quot;/var/mobile/Containers/Data/Application/06B16FDB-4EA1-4093-A729-613111061798&quot;cy# 2.4.3 复制dumpdecrypted.dylib到上述的document路径中1scp -P 2222 dumpdecrypted.dylib root@localhost:/var/mobile/Containers/Data/Application/06B16FDB-4EA1-4093-A729-613111061798/Documents 2.5 解密 通过DYLD_INSERT_LIBRARIES注入解密 3 通过frida-ios-dump 来给应用脱壳4 Clutch clutch同样是一个开源解密工具，与dumpdecrypted不同的是，Clutch会生成一个新的进程，然后暂停进程并且dump内存来生成新的ipa。 4.1 下载并编译Clutch git clone https://github.com/KJCracks/Clutch下载完成之后用xcode打开工程，设置Debug生成所有的架构，设置Build Active Architecture 为 NO ，选择真机设备 command+B 编译。编译完成之后在本地的Build文件夹里面会有一个Clutch的命令行文件 4.2 将文件复制到设备中 使用如下命令，把生成的Build/Clutch复制到设备/usr/bin目录下，并且设置可执行权限。scp -P 2222 root@localhost:/usr/binssh 5schmod +x /usr/bin/Cluch 4.3 Clutch解密 SSH到越狱设备，使用Clutch -i 运行获取目标target的BundleID使用Clutch -b target.BundleID来解密 123456789101112131415lemons-iPhone5S:~ root# Clutch -b com.xtuone.Friday2018-06-21 16:46:11.732 Clutch[6958:1126993] command: Only dump binary files from specified bundleIDZipping Friday.appDumping &lt;FridayExtensionOC&gt; (arm64)Patched cryptid (64bit segment)Writing new checksum2018-06-21 16:46:12.872 clutch[6960:1127016] command: Only dump binary files from specified bundleIDFailed to dump framework (null) :(Dumping &lt;Friday&gt; (arm64)Patched cryptid (64bit segment)Writing new checksumZipping lame.frameworkZipping FridayExtensionOC.appexDONE: /private/var/mobile/Documents/Dumped/com.xtuone.Friday-iOS8.0-(Clutch-(null)).ipaFinished dumping com.xtuone.Friday in 20.8 seconds 5 总结给应用砸壳实际上有两种方法，一种是基于DYLD_INSERT_LIBRARIES环境变量将动态库注入到目标进程，然后dump内存。另外一种是通过posix_spawnp创建一个进程，然后dump内存。]]></content>
      <categories>
        <category>iOS 逆向</category>
      </categories>
      <tags>
        <tag>dumpdecrypted</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 逆向常用工具]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E9%80%86%E5%90%91%2FiOS-%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[mac工具效率工具 iTerm2 代替默认的Terminal，提供了很多高级设置，例如自动补全，高亮等等 oh-my-zsh 自定义主题，git显示，Tab补全等 Go2Shell 从finder中打开终端并且自动切换到当前目录 Alfred 工作流软件，快速打开软件，添加自己的工作流。参见bestswifter的博客 实用工具 Homebrew MacOS的包管理器，快速安装各种工作 libimobiledevice 提供了很多能与iOS交付的工具，例如端口映射查看日志，安装程序 逆向工具 jtool 查看文件的结构，代码签名 capstone 多平台，多架构支持的反汇编框架 keystone 将汇编指令转换成Hex机器码 redare2 一款开放源代码的逆向工程平台 mobiledevice 安装app或者ipa包 iFunBox 查看越狱设备的文件目录 dumpdecrypted dumpdecrypted 是一个开源的砸壳工具，它会注入可执行文件，动态的从内存中dump出解密后的内容。使用教程请看这里 class-dump class-dump 是一个用于从可执行文件中获取类，方法和属性的工具，上述源代码在导出ARMV7架构的时候会出问题，原因是在读取类没有分64和32位系统进行不同的操作，最新的fix bug的源码在AloneMonkey/Class-dump Reveal Reveal 是一个用户动态查看APP UI层级架构的工具，可以在开发过程中动态调试修改程序的样式，也可以注入第三方APP以查看应用的界面结构。有两种方式可以使用Reveal，第一种是正向开发的时候通过pod的方式加入Reveal 123target &apos;RevealAPP&apos; do pod &apos;Reveal-SDK&apos;, :configurations=&gt; [&apos;Debug&apos;]end 第二种方式是越狱设备注入Raveal,可以调试所有的APP，在越狱设备，可以将RevealServer重命名为libReveal.dylib，以及新建libReveal.plist文件，里面输入需要调试的APP的BundleID 1234567&#123; Filter = &#123; Bundles = ( &quot;com.lemon.example&quot;, ); &#125;;&#125; 将以上两个文件复制到越狱设备的 /Library/MobileSubstrate/DynamicLibraries/目录下，这样可以通过Cydia Substrate的MobileLoader在程序运行的时候通过dyld_insert_libraries命令将自己加载到目标APP的Document目录下，然后查找上述路径的所有的plist，找到对应的Bundleid之后，通过dlopen()函数将动态库注入到APP中 越狱设备工具 cydia cydia是一个可以让用户在越狱设备上面安装各种插件的软件管理器，相当于越狱设备的APPStore SSH SSH是一种网络协议，用于计算机之前的加密登录，他存在多种实现，因为不同系统使用的越狱工具不一样，所以需要根据iOS的版本来进行设置。iOS8 &amp; iOS9 ，可以通过安装OpenSSH来登录，安装方法：1.在cydia中搜索OpenSSH并且安装，安装完成之后打开Wifi设置界面，打开当前连接的wifi，获取ip地址(假设是192.168.2.21)，然后打开终端，输入以下命令后回车： ssh root@192.168.2.21 2.稍等片刻之后输入yes并且回车，然后输入默认密码alpine完成登录。（当远程主机的公钥被接受以后，他会保存到mac的$HOME/.ssh/known_hosts文件中，再次连接这台主机时，系统就会认出他的公钥已经保存到本地，从而跳过警告部分，直接提示用户输入密码。）iOS10.0 &amp; iOS10.2 ，越狱工具yalu内置了一个相对轻量级的工具dropbear，供用户直接使用。安装方法：1.在cydia中搜索MTerminal和adv-cmds，然后运行ps aux | grep dropbear 命令。如果有输出内容，则代表默认支持usb连接，如果这是要连接，在mac上转发端口即可登录，命令如下：iproxy 22 2222ssh root@localhost -p 2222如果要通过wifi连接，需要在终端设备执行一下命令/usr/local/bin/dropbear -F -R -p 22然后在mac上直接SSH登录ssh root@192.168.2.21 iFile 查看越狱设备的文件目录 cydia substrate cydia substrate是一个框架，允许第三方开发者在越狱系统方法里面打一下运行时补丁和扩展一些方法，是开发越狱插件的基石。cydia substrate主要包含三个模块，分别是MobileHooker,MObileLoader,Safe mode。MobileHooker 用于替换系统或者应用的方法，它提供了MSHookMessageEX 来hook OC的函数，MSHookFunction来hook C函数。MobileLoader 用于将第三方动态库加载到目标应用里面。首先它会通过dyld_insert_libraries将自己加载到目标程序里面，然后通过查找/Library/MobileSubstrate/DynamicLibraries/目录下的所有plist文件，如果plist文件里面包含有当前应用的BundleID，那么就会通过dlopen()函数打开对应的dylib文件。safe mode 当插件加载导致了系统奔溃时，mobilesafety会捕捉到这个异常并且让设备进入安全模式。找到最近安装的导致奔溃的插件并且卸载即可退出安全模式。 adv-cmds 提供ps命令 appsync 让系统不再校验应用的签名 scp 对于iOS10以后的版本，使用yalu越狱之后就没有scp这个工具了，可以在网上找到scp的源代码使用iFunBox复制到设备的/usr/bin目录下，然后通过ssh访问该目录，执行以下命令：cd /usr/binldid -S scpchmod 777 scp chisel 提供便利的LLDB调试命令安装教程 brew install chisel 如果不存在~/.lldbinit文件那就创建一个文件，并且将以下代码放到该文件中#~/.lldbinit…command script import /usr/local/opt/chisel/libexec/fblldb.py 重启Xcode或者在LLDB中输入 command source ~/.lldbinit命令在加载脚本。 安全工具 ios-class-guard 该工具是从class-dump fork出来的，用于dump出APP中的类和方法并且生成混淆代码，将生成的混淆的宏定义添加到项目的pch文件中，达到混淆所有的类和方法的作用]]></content>
      <categories>
        <category>iOS 逆向</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS 逆向常用命令]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E9%80%86%E5%90%91%2FiOS-%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 查看信息相关 查看越狱设备所有的APP的BundleID （前提需要安装frida-iOS-dump） MacBookPro:frida-ios-dump-master lemon$ ./dump.py -l 查看设备UDID (前提需要安装ideviceinstall) MacBookPro:~ lemon$ idevice_id -l 查看iPA是否已经砸壳 (如果返回cryptid=0代表已砸壳，否则代表未砸壳) MacBookPro:~ lemon$ otool -l target.app/target | grep cryptid 查看设备日志 MacBookPro:~ lemon$ idevicesyslog -u deviceudid 给特定的设备安装程序 MacBookPro:~ lemon$ ideviceinstaller -i target.ipa -u deviceudid 砸壳 (使用frida) MacBookPro:frida-ios-dump-master lemon$ ./dump.py BundleID class-dump头文件 MacBookPro:~ lemon$ class-dump -s -S -H target.app/target -o /path/to/save/header 查看动态库架构 lipo -info ssh ssh root@deviceip 查找进程 ps aux | grep /Appps -e | grep /Applications 查找文件 grep -r Header /System/Library/ 分离fat binary lipo -thin armv7 WeChat.decrypted -output WeChat_armv7.decryptedlipo -thin arm64 xxx.decryptec -output xxx.arm64.decrypted 2. LLDB 打印UI结构 po [[[UIWindow keyWindow] rootViewController] _printHierarchy] (iOS 8)po [[UIWindow keyWindow] recursiveDescription] 打印调用栈信息 bt (backtrace)bt all (all threads) objc_msgSend参数打印 po $xo p (char*)$x1 p (SEL)$x1 返回地址 p/x $lr 增加断点 b -a ox00002224 列举模块 image lisg -o -f lldb基础指令 cnnibr listbr delbr disbr en 远程调试 debugserver *:1234 -a pid debugserver -x backboard *:1234 /var/mobile/Containers/Bundle/Application/9DB7CE45-3B4C-42A3-9D4D-49A3A5122903/AlipayWallet.app/AlipayWallet 远程连接 proces connect connect://192.168.2.154:1234 lldb expr例子 (lldb) expr char $str = (char )malloc(8) (lldb) expr (void)strcpy($str, “munkeys”) (lldb) expr $str[1] = ‘o’ (char) $0 = ‘o’ (lldb) p $str (char *) $str = 0x00007fd04a900040 “monkeys” (lldb) x/4c $str (lldb) x/1w $str + 3 (lldb) expr (void)free($str) (lldb) expr id $myView = (id)0x7f82b1d01fd0 (lldb) expr (void)[$myView setBackgroundColor:[UIColor blueColor]] (lldb) expr (void)[CATransaction flush] (lldb) po [$myButton allTargets] (lldb) p (ptrdiff_t)ivar_getOffset((struct Ivar *)class_getInstanceVariable([MyView class], “_layer”)) 给断点增加命令 123456(lldb) br command add 1Enter your debugger command(s). Type &apos;DONE&apos; to end.&gt; register read $rdi &gt; c &gt; DONE(lldb) 修改寄存器的值 register write x0 1 3. Cycript 查看当前界面的元素层级结构 cy# [[UIApp keyWindow]recursiveDescription].toString() 查看当前keywindow的根控制器的所有subView cy# [[[UIApp keyWindow] rootViewController] _printHierarchy].toString() 输出简单的视图信息 cy# [[UIApp keyWindow] _autolayoutTrace].toString() 查看一个实例的所有ivar cy# [choose(SBApplication)[0] _ivarDescription].toString() 查看一个class的对象方法和类方法 cy# [choose(SBApplicationController)[0] _methodDescription].toString() 访问对象和实例 12345678cy# [#0xb226710 url]@&quot;ww4fd1rfRDShBo_4K6rqfwAAACMAAQED&quot;cy# c = #0x1752d8c0cy#&quot;&lt;FavAudioPlayerController: 0x1752d8c0; frame = (0 0; 290 60); autoresize = W; layer = &lt;CALayer: 0x172dc2b0&gt;&gt;&quot;cy# c-&gt;m_audioInfocy#&quot;&lt;FavAudioInfo: 0x172b2a30&gt;&quot;cy# c-&gt;m_audioInfo.m_nsAudioPath 4. ARM5. 工具 dumpdecrypted theos usbmuxd frida-ios-dump class-dummp MonkeyDev]]></content>
      <categories>
        <category>iOS 逆向</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[通过theos提供的logify来为类的所有方法添加追踪日志]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E9%80%86%E5%90%91%2F%E9%80%9A%E8%BF%87theos%E6%8F%90%E4%BE%9B%E7%9A%84logify%E6%9D%A5%E4%B8%BA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E8%BF%BD%E8%B8%AA%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[1.简介###logify是THEOS自带的为代码添加Log的工具，可以使用该工具给指定的类添加Log代码并且生成一个新的Tweak.xm文件 2.用法2.1 准备工作2.1.1 安装Theos 首先需要安装Theos，安装完成之后会默认安装此工具。 2.1.2 将APP脱壳，有两种方式可以获得脱壳的APP2.1.2.1 无越狱机通过PP助手去越狱市场下载脱壳的ipa，有时下载下来的也不一定是脱壳后的，你可以通过在终端执行以下命令 1otool -l target.app/target | grep crypt 如果输出 123cryptoff 16384cryptsize 58753024cryptid 0 //0 代表已经砸壳，1代表未砸壳 2.1.2.2 有越狱机 你需要一台越狱机器，安装完整版之后通过工具来脱壳，这个时候你也有两个方法获得脱壳应用。方法一：你可以使用dumpdecrypted工具来砸壳。方式二：你也可以使用庆总开源的工具frida-iOS-dump一条命令行进行砸壳。 2.1.3 class-dump 出头文件通过以上的方式得到砸壳后的应用之后，需要利用clas-dump工具dump出头文件。具体的用法如下 1class-dump -s -S -H target.app/target -o /path/to/save/header 2.1.4 使用logify工具生成Tweak.xm文件该文件里面会hook该头文件对应的类，并且会在代码里面加上Log打印用法如下： 1logify.pl HookHeader.h的全路径 &gt;Tweak.xm 如果要跟踪多个头文件，则继续转换： 1logify.pl 其它头文件 &gt;&gt; Tweak.xm 注意中间是 &gt;&gt; 2.1.5 使用nic.pl命令来生成Theos工程，选择Teak工具。2.1.6 创建完Tweak工程之后，将在2.1.4中生成的Tweak.xm替换掉工程中的Teak.xm.不过此时还需要对该文件做一些修改a.去掉.cxx_destruct 方法 b.将HBLogDebug 改为NSLog 然后修改makefile文件，在最上面那一行增加THEOS_DEVICE_IP = 你的设备的IP 2.1.7 使用一下make package install 生成deb包，并且安装到越狱设备上。 2.1.8 运行目标APP，观察日志。 有两种方法可以观察日志，第一种是通过xcode-&gt;window-&gt;Device and simulators-&gt;view device logs 。 第二种是通过idevicesyslog -u udid 来查看特定设备的日志。这种方式需要安装libimobiledevice]]></content>
      <categories>
        <category>iOS 逆向</category>
      </categories>
      <tags>
        <tag>logify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导出iOS真机缓存的dyld_shared_cache_arm64文件]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E9%80%86%E5%90%91%2F%E5%AF%BC%E5%87%BAiOS%E7%9C%9F%E6%9C%BA%E7%BC%93%E5%AD%98%E7%9A%84dyld-shared-cache-arm64%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1前言在iOS系统中，存在着这么一个文件夹，/System/Library/Caches/com.apple.dyld，这个文件夹里面放着的是什么文件呢，在我的iphone5s中，两个文件dyld_shared_cache_armv7s和dyly_shared_arm64，这两个文件分别代表两个arm架构，一个是armv7s一个是arm64。 顾名思义，这两个都是缓存文件，里面放着的都是各种系统所可能用到的动态库。如Foundation.framework,Security.framework等等。在/System/Library/Frameworks/这个路径下面所有的动态库只放了一些配置文件，而真正的执行文件就在上面说的缓存文件里面。因为几乎所有的iOS程序都会用到系统库，当程序运行的时候会使用dyld(位于/usr/lib/dylb)程序进行连接，另一方面，由于每个iOS程序都会连接很多的动态库，如果需要一个一个连接会很耗时，如果把它们放在一个地方打包好，等到运行的时候全部连接岂不美滋滋，基于这些原因，就有了dyld_shared_cache_armv7s和dyld_shared_cache_armv64两个缓存文件（有些设备有可能还会有dyld_shared_cache_armv7）。 2工具上面我已经解释了为什么会存在这两个文件以及这两个文件的作用，在iOS逆向中，我们常常需要查看某一个系统类的实现，这个时候就要去对应的系统库里面查看，这些系统库就放在对应的缓存文件里面了。但是这些文件是经过处理的，不可以直接查看，所以需要用到一些工具来查看。这里介绍两个工具，一个是dyld_decache[v0.1c] 另外一个是dsc_extractor，编译方法 。这两个工具的不同之处是，第一个工具是不可以用来解析arm64指令集的缓存文件的，而dsc_extractor是可以用来解析arm64指令集的缓存文件的，现在基本上大家用的都是arm64位指令集的设备了。（iPhone5s以上都是arm64位结构） 3还原通过2中的dyld_decache[v0.1c]工具和dsc_extractor我们可以还原出dyld_shared_cache_armX缓存文件中隐藏的framework。下面是语法 #####3.1 dsc_extractorusage: dsc_extractor 1usage: dsc_extractor 你要解析的arm64的缓存文件路径 保存的路径 解析过程中会出现类似于0/969 1/969 2/969 3/969 4/969 5/969 ….. 这样的文字。 3.2 dyld_decache[v0.1c]dyld_decache[v0.1c] -o 要保存的路径 你要解析的缓存文件路径 解析完成后会出现两个文件加，一个是system,另外一个usr，如无意外，所有的动态库都会在里面，接下来尽情的蹂躏他们吧。不过记得在开始这一切之前，要将iphone里面的dyld_shared_cache_arm64文件拷贝一份到OSX上面去操作。]]></content>
      <categories>
        <category>iOS 逆向</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dsc_extractor的编译和使用]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E9%80%86%E5%90%91%2Fdsc-extractor%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1前言在iOS逆向中，我们常常需要对dyld_shared_cache_armX类型的文件进行还原，第一个我们经常使用的是dyld_decache工具，但是这个工具并不能用从来还原dyld_shared_cache_arm64文件，也就是64位指令集架构的缓存文件，这个时候dsc_extractor就为你续命了。 2编译打开终端依次执行以下命令： 1cd ~ 1mkdir dsc_extractor 1cd dsc_extractor 1wget http://opensource.apple.com/tarballs/dyld/dyld-210.2.3.tar.gz 1tar xvf dyld-210.2.3.tar.gz 1cd dyld-210.2.3/launch-cache/ 1touch dsc_extractor.patch 通过上面的操作，我们下载下来了touch dsc_extractor的源码并且解压出来，并在其中创建了一个touch dsc_extractor.patch的空文件，接下来把以下内容复制到该文件里面去。 12345678910111213141516171819202122232425262728293031323334--- dyld-210.2.3/launch-cache/dsc_extractor.cpp 2012-05-21 02:35:15.000000000 -0400+++ dyld-210.2.3/launch-cache/dsc_extractor.cpp 2013-07-26 16:05:03.000000000 -0400@@ -37,6 +37,7 @@ #include &lt;mach-o/arch.h&gt; #include &lt;mach-o/loader.h&gt; #include &lt;Availability.h&gt;+#include &lt;dlfcn.h&gt; #define NO_ULEB #include &quot;Architectures.hpp&quot;@@ -456,7 +457,7 @@ &#125; -#if 1+/* #if 1 */ typedef int (*extractor_proc)(const char* shared_cache_file_path, const char* extraction_root_path, void (^progress)(unsigned current, unsigned total));@@ -468,7 +469,7 @@ return 1; &#125; - void* handle = dlopen(&quot;/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle&quot;, RTLD_LAZY);+ void* handle = dlopen(&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle&quot;, RTLD_LAZY); if ( handle == NULL ) &#123; fprintf(stderr, &quot;dsc_extractor.bundle could not be loaded\n&quot;); return 1;@@ -484,7 +485,7 @@ fprintf(stderr, &quot;dyld_shared_cache_extract_dylibs_progress() =&gt; %d\n&quot;, result); return 0; &#125;-#endif+/* #endif */ 记住，在+/endif /后面是还有一行空行的。 然后执行一下命令： 1patch &lt; dsc_extractor.patch 执行完成该命令后，你可以在dsc_extractor.patch文件的同级目录下看到一个dsc_extractor.cpp文件，接下来打开这个文件，要修改里面的内容。如下：原处：230行 const char* afterSlash = &amp;dirs[1];修改成： char* afterSlash = &amp;dirs[1]; 去除const原处：460行 #if 0修改成： #if 1原处：488行 / #endif /修改成： #endif 放开注释 修改完成后，回到终端，运行 1clang++ -o dsc_extractor dsc_extractor.cpp dsc_iterator.cpp 到了这里，dsc_extractor终于编译完成了，你可以在同级目录下看到dsc_extractor的执行文件。你可以把它复制到任何地方然后使用。 3使用编译dsc_extractor成功后，用iFunBox将iOS 里面的/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64复制到OSX的任何位置，然后在终端运行 dsc_extractor完成路径 arm64缓存文件路径 要保存文件的路径 然后终端显示0/10041/10042/10043/10044/10045/10046/10047/1004这样的文本的时候就成功了]]></content>
      <categories>
        <category>iOS 逆向</category>
      </categories>
      <tags>
        <tag>dsc-extractor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 基础汇编知识]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E5%BC%80%E5%8F%91%2FiOS-%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1 寄存器 内存 栈在高级语言里面，操作对象是变量，在ARM汇编里面，操作对象是寄存器（register），内存和栈(stack) 2 数据操作指令1op &#123;cond&#125;&#123;s&#125; Rd, Rn, Op2 其中，cond和s是两个可选后缀，cond用来指定指令op在什么条件下执行，共有下面17种条件。 指令 说明 EQ 结果为0, Equal to 0 NE 结果不为0，Not Equal to 0 CS 有进位或者借位 Carry Set HS 同CS,unsigned Higher or same CC 没有进位或者借位 Carry clear LO 同CC unsigned Lower MI 结果小于0 ， Minus PL 结果大于0 ， Plus VS 溢出， oVerflow set VC 无溢出 ， oVerflow clear HI 无符号比较大于 ，unsigned higher LS 无符号比较小于，unsigned lower or same GE 有符号比较大于等于 ，signed greater than or Equal LT 有符号比较小于，signed less than GT 有符号比较大于，signed greater than LE 无符号比较小于等于，signed less than equal AL 无条件（Always ,默认） 例如：比较 R0,R1移动 GE R2, R1移动 LT R2, R0比较R0和R1的值，如果R0大于R1，那么R2等于R1,如果R0小于R1，那么R2等于R0。 s的作用是指定指令op是否设置flag，共有下面四种flag。 符号 说明 N（Negative） 如果结果小于0则置1，否则置0 Z (Zero) 如果结果是0则置1，否则置0 C （Carry） 对于加操作来说，如果产生进位则置1，否则置0，对于减操作来说，如果产生借位则置0，否则置1，对于有位移的非加/减操作来说，C置移出值的最后一位，对于其他的非加/减操作来说，C的值一般不变 V（Overflos） 如果操作溢出则置1，否则置0 需要注意的是，Cflag表示的是无符号位运算结果是否溢出，Vflag表示的是有符号位数运算结果是否溢出。 算术操作 ADD R0, R1, R2 ; R0 = R1 + R2 ADC R0, R1, R2 ; R0 = R1 + R2 + C(arry) SUB R0, R1, R2 ; R0 = R1 - R2 SBC R0, R1, R2 ; R0 = R1 - R2 - !C RSB R0, R1, R2 ; R0 = R2 - R1 RSC R0, R1, R2 ; R0 = R2 - R1 - !C 逻辑操作 AND R0, R1, R2 ; R0 = R1 &amp; R2 //按位与 ORR R0, R1, R2 ; R0 = R1 | R2 //按位或 EOR R0, R1, R2 ; R0 = R1 ^ R2 //按位异或 BIC R0, R1, R2 ; R0 = R1 &amp;~ R2 //按位取反与 MOV R0, R2 ; R0 = R2 //赋值 MVN R0, R2 ; R0 = ~R2 //按位取反 比较操作 CMP R1, R2 ; 执行R1 - R2并依结果设置flag CMN R1, R2 ; 执行R1 + R2并依结果设置flag TST R1, R2 ; 执行R1 &amp; R2并依结果设置flag TEQ R1, R2 ; 执行R1 ^ R2并依结果设置flag 乘法操作 MUL R4, R3, R2 ; R4 = R3 * R2 MLA R4, R3, R2, R1 ; R4 = R3 * R2 + R1 乘法操作的操作数必须来自寄存器 ###3 内存操作指令内存操作指令的基本格式是：1op&#123;cond&#125;&#123;type&#125; Rn, [Rn,?Op2] 其中Rn是基址寄存器，用户存放基地址 cond的作用于数据操作指令相同，都是用来指定op是在什么条件下执行 type指定指令op操作的数据类型，共有四种 指令 说明 B(unsigned Byte) 无符号byte，执行时扩展到32bit,以0填充 SB(Signed Byte) 有符号byte，仅用于LDR指令，执行时扩展到32bit，以符号位填充 H (signed Halfword) 无符号halfword,执行时扩展到32bitj,以0填充 SH （signed halfword） 有符号halfword 仅用于LDR指令，执行时扩展到32bit,以符号位填充 如果不指定byte，则默认的数据类型是wordARM内存操作基础指令只有两个： LDR (LoaD Register)将数据从内存中读出来，存到寄存器中。以及STR(STore Register)将寄存器的数据读出来，存到内存中。两个指令的使用情况如下： LDR-LDR Rt, [Rn {,#offset}] ; Rt = *(Rn {+ offset}),{}代表可选 LDR Rt, [Rn, #offset]! ; Rt = *(Rn + offset); Rn= Rn + offset LDR Rt, [Rn], #offset ; Rt = *Rn; Rn = Rn +offset STR- STR Rt, [Rn {, #offset}] ; *(Rn {+ offset}) = Rt STR Rt, [Rn, #offset]! ; *(Rn {+ offset}) = Rt; Rn= Rn + offset STR Rt, [Rn], #offset ; *Rn = Rt; Rn = Rn +offset 此外， LDR和STR的变种LDRD和STRD还可以操作双字（ Doubleword），即一次性操作2个寄存器，其基本格式如下：op{cond} Rt, Rt2, [Rn {, #offset}] 用法及原型类似，如下：STRD R4, R5, [R9,#offset] ； *(R9+offset) = R4 , *(R9+offset+R4) = R5 LDRD R4, R5, [R9,#offset] ; R4 = *(R9 + offset);R5 = *(R9 + offset + 4) 除了LDR和STR外，还可以通过LDM（ LoaDMultiple）和STM（ STore Multiple）进行块传输，一次性操作多个寄存器。块传输指令的基本格式是： 1op&#123;cond&#125;&#123;mode&#125; Rd&#123;!&#125;, reglist 其中Rd是基址寄存器，可选的“!”指定Rd变化后的值是否写回Rd； reglist是一系列寄存器，用大括号括起来，它们之间可以用“,”分隔，也可以用“-”表示一个范围，比如， {R4–R6,R8}表示寄存器R4、 R5、R6、 R8；这些寄存器的顺序是按照自身的编号由小到大排列的，与大括号内的排列顺序无关。需要特别注意的是， LDM和STM的操作方向与LDR和STR完全相反： LDM是把从Rd开始，地址连续的内存数据存入reglist中， STM是把reglist中的值存入从Rd开始，地址连续的内存中。 “cond”的作用与数据操作指令相同。 “mode”指定Rd值的4种变化规律，如下所示： IA（ Increment After）每次传输后增加Rd的值； IB（ Increment Before）每次传输前增加Rd的值； DA（ Decrement After）每次传输后减少Rd的值； DB（ Decrement Before）每次传输前减少Rd的值 示例： 假设R0的值为5 执行以下命令后， R4、 R5、 R6的值分别变成：foo():LDMIA R0, {R4 – R6} ; R4 = 5, R5 = 6,R6 = 7LDMIB R0, {R4 – R6} ; R4 = 6, R5 = 7,R6 = 8LDMDA R0, {R4 – R6} ; R4 = 5, R5 = 4,R6 = 3LDMDB R0, {R4 – R6} ; R4 = 4, R5 = 3,R6 = 2 4 分支指令分支指令可以分为无条件分支和条件分支两种。 . 无条件分支foo():B Label ; 跳转到Label处往下执行…… ; 得不到执行Label:…… . 条件分支 条件分支的cond是依照6.2.1节提到的4种flag来判断的，它们的对应关系如下：cond flagEQ Z = 1 NE Z = 0 CS C = 1 HS C = 1 CC C = 0 LO C = 0 MI N = 1 PL N = 0 VS V = 1 VC V = 0 HI C = 1 &amp; Z = 0 LS C = 0 | Z = 1 GE N = V LT N != V GT Z = 0 &amp; N = V LE Z = 1 | N != V 在条件分支指令前会有一条数据操作指令来设置flag，分支指令根据flag的值来决定代码走向，举例如下：Label:LDR R0, [R1], #4CMP R0, 0 ; 如果R0 == 0， Z = 1；否则Z = 0BNE Label ; Z == 0则跳转]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLDB && debugserver的使用]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E9%80%86%E5%90%91%2FLLDB-debugserver%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.1 LLDB LLDB全称为low level debugger,是xcode自带的动态调试工具，可用于c,c++,objective-c，全盘支持iOS，OSX以及iOS模拟器。 LLDB有以下四个功能： 1.在特定的情况下暂停程序 2.在特定的情况下启动程序 3.在程序停止的情况下检查程序内部 4.在程序停止的情况下改动程序，观察执行过程。 LLDB是运行在OSX程序中的，可以通过特定的语句配合debugServer对iOS中的程序进行监视。 1.2 debugServer debugserver是运行在iOS程序中的，顾名思义，作为server端，它接受与来自服务端，也就是LLDB传送过来的命令，继而执行的操作。再把执行结果返回给LLDB,默认情况下， iOS并没有安装debugserver，只有在设备连接了一次xcode之后，并在window-&gt;device中添加此设备之后，debugservercai才会别安装到iOS中，默认位于Developer/usr/bin目录下。 但是默认的debugserver只用用户调试我们自己的app，如果想要调试iOS里面所有的app，还需要通过给debugserver赋予task_for_pid的权限。以下是配置task_for_pid的教程 1.debugserver瘦身，首先根据你的iOS设备确定你的手机对应的ARM，4s是armv7,5,5c是armv7s，5s以上的机型都是arm64，我的手机是5s，所以对应的arm是arm64，所以只从debugserver保留arm64的架构即可。具体步骤: 首先将未经处理的debugserver从iOS拷贝到OSX中，可以用scp命令，也可以用iFunBox。 然后利用命令 1lipo -thin arm64（这里对应你的iOS设备的结构） (未经处理的debugServer的路径) -output (新的debugserver的保存路径) 2.给debugServer添加task_for_pid权限，将以下xml保存为ent.xml。 123456789101112 &lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;&lt;key&gt;com.apple.springboard.debugapplications&lt;/key&gt;&lt;true/&gt;&lt;key&gt;get-task-allow&lt;/key&gt;&lt;true/&gt;&lt;key&gt;task_for_pid-allow&lt;/key&gt;&lt;true/&gt;&lt;key&gt;run-unsigned-code&lt;/key&gt;&lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt; 运行以下命令： 1ldid -S(ent.xml的全路径) (debugServer的全路径) 以上命令实质上是通过ldid这个签名工具，为debugserver添加task_for_pid权限，上面的命令也可以用xcode自带的codesign实现。 1codesign -s -f - --entitlements ent.plist -f debugserver 3.将添加权限后的debugserver放回去iOS复制到/usr/bin/debugserver，这样的好处是可以全局执行debugserver命令。另一个原因是因为在developer里面的是不可以写的，无法覆盖。 4.给新的debugserver添加可执行的权限 1chmod +x /usr/bin/debugserver ####1.3 debugserver使用 debugserver有两个命令。 1.启动进程,debugserver会启动进程，并且开启port端口，等待来自ip的LLDB接入。ip如果为*则代表任意ip 1debugserver backend ip:port /path/to/excutable 2.附加进程，附加进程是在进程已打开的情况下，可以执行以下命令。 1debugserver ip:port -a &quot;processname&quot; 1.4 LLDB &amp;&amp; debugserver配合使用假设我们要调试在iOS中要按下home键的处理。通过IDA我们知道按下home键的时候调用了 -[SpringBoard _menuButtonDown:] 这个方法，现在我们的需求是在menuButtonDown的方法下面打一个断点。 (1)首先利用debugserver启动进程或者附加进程。系统的SpringBoard默认是启动的，所以不需要启动进程，使用附加进程命令即可。SSH到iOS中，然后附加到SpringBoard进程(以下命令开启了1234接口并且等待来自任意ip的LLDB接入) 1234567Last login: Sun Apr 8 11:04:23 on ttys016MacBookPro:~ lemon$ ssh root@192.168.2.154lemons-iPhone5S:~ root# debugserver *:1234 -a &quot;SpringBoard&quot;debugserver-@(#)PROGRAM:debugserver PROJECT:debugserver-340.3.124 for arm64.Attaching to process SpringBoard...Listening to port 1234 for a connection from *... (2)在OSX的terminal中启动LLDB，然后连接远程1234端口 1234567891011121314MacBookPro:~ lemon$ lldb(lldb) process connect connect://192.168.2.154:1234Process 2148 stopped* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = signal SIGSTOP frame #0: 0x000000018208cfd8 libsystem_kernel.dylib`mach_msg_trap + 8libsystem_kernel.dylib`mach_msg_trap:-&gt; 0x18208cfd8 &lt;+8&gt;: ret libsystem_kernel.dylib`mach_msg_overwrite_trap: 0x18208cfdc &lt;+0&gt;: mov x16, #-0x20 0x18208cfe0 &lt;+4&gt;: svc #0x80 0x18208cfe4 &lt;+8&gt;: ret Target 0: (SpringBoard) stopped.(lldb) (3)通过以上两步我们已经可以在电脑的终端利用LLDB调试APP了。现在在终端输入 image list -o -f 可以看到当前所有iOS中启动的所有的进程模块。 12345[(lldb) image list -o -f[ 0] 0x0000000000040000 /Users/lemon/Library/Developer/Xcode/iOS DeviceSupport/9.3.1 (13E238)/Symbols/usr/lib/dyld[ 1] 0x00000000000dc000 /System/Library/CoreServices/SpringBoard.app/SpringBoard(0x00000001000dc000)[ 2] 0x0000000100988000 /Library/MobileSubstrate/MobileSubstrate.dylib(0x0000000100988000)[ 3] 0x0000000001acc000 /Users/lemon/Library/Developer/Xcode/iOS DeviceSupport/9.3.1 (13E238)/Symbols/System/Library/PrivateFrameworks/StoreServices.framework/StoreServices (4)通过3中的信息我们发现了Spring的偏移是0x00000000000dc000，接下来我们需要用ida查看menuButtonDown这个函数在模块中的地址是多少。 123456789 -[SpringBoard _menuButtonDown:]:0000000100016fe8 stp x28, x27, [sp, #0xffffffa0]! ; Objective C Implementation defined at 0x1006a4550 (instance)0000000100016fec stp x26, x25, [sp, #0x10]0000000100016ff0 stp x24, x23, [sp, #0x20]0000000100016ff4 stp x22, x21, [sp, #0x30]0000000100016ff8 stp x20, x19, [sp, #0x40]0000000100016ffc stp x29, x30, [sp, #0x50]0000000100017000 add x29, sp, #0x500000000100017004 sub sp, sp, #0x60 通过上面的信息可以看到，该函数的第一条指令的地址是0000000100016fe8，所以该函数偏移后的地址是：原地址+偏移 =》0x00000000000dc000 + 0000000100016fe8 = 0x1000F2FE8 (5)在偏移后的地址出打断点 123(lldb) br s -a 0x1000F2FE8Breakpoint 1: where = SpringBoard`_mh_execute_header + 71804, address = 0x00000001000f2fe8(lldb) (6)在打完断点之后，可以按下home键，这个时候程序就会停在断点处，可以用1.5里面的命令进行调试等等 1.5 LLDB命令解析(1) b NSog // 在函数的起始位置设置断点 (2) br s -a address //在地址处设置断点 (3) br s -a ‘address + offsetAddress’ //在地址处设置断点 (4) br dis //禁用所有的断点 (5) br dis 6 //禁用序号为6的断点 (6) br del //删除所有断点 (7) br del 6 //删除序号为6的断点 (8) br en //启用所有断点 (9) br en 6 //启用序号为6的断点 (10)br com add 1 //当序号为1的断点执行的时候，可以执行预先设置的指令。当执行了这条指令之后，llDB会要求你输入一些指令，并且以DONE结束，当程序停在序号为1的断点时，就会执行这些预先设定的指令。 (11)p $R1 //打印R1的值 (12)p/x $sp //打印SP的地址，以16进制输出 (13)x/10 $sp //打印sp的地址，以10进制输出 (14)nexti 和 stepi //nexti不进入函数体，stepi进入函数体，nexti可以简写成ni,setpi可以简写成si。 (15)register write r0 1 //用于给指定的寄存器r0赋值为1从而达到对程序进行改动的目的。]]></content>
      <categories>
        <category>iOS 逆向</category>
      </categories>
      <tags>
        <tag>LLDB</tag>
        <tag>debugserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libimobiledevice的安装和使用]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E9%80%86%E5%90%91%2Flibimobiledevice%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.介绍libimobiledevice 是一个跨平台的软件库，支持 iPhone®, iPod Touch®, iPad® and Apple TV® 等设备的通讯协议。不依赖任何已有的私有库，不需要越狱。应用软件可以通过这个开发包轻松访问设备的文件系统、获取设备信息，备份和恢复设备，管理 SpringBoard 图标，管理已安装应用，获取通讯录、日程、备注和书签等信息，使用 libgpod 同步音乐和视频。 2.安装方式12brew install -HEAD libimobiledevice #安装最新的更新，支持 iOS 10brew install ideviceinstaller # 仅在 iOS9工作 3.常用命令3.1 查看当前所连接的设备12345MacBookPro:~ lemon$ idevice_id -l # 显示当前所连接的设备[udid]，包括 usb、WiFi 连接********c06e788b2d8dc60004a7015ce5dad782********9a816a4089bd28f4f2e63c57a8138c63instruments -s devices # 列出设备包括模拟器、真机及 mac 电脑本身 3.2 安装应用1ideviceinstaller -u [udid] -i [xxx.ipa] # 给指定连接的设备安装应用 3.3 卸载应用1ideviceinstaller -u [udid] -U [bundleId] # 给指定连接的设备卸载应用 3.4 查看设备已安装的应用1234ideviceinstaller -u [udid] -l # 指定设备，查看安装的第三方应用ideviceinstaller -u [udid] -l -o list_user # 指定设备，查看安装的第三方应用ideviceinstaller -u [udid] -l -o list_system # 指定设备，查看安装的系统应用ideviceinstaller -u [udid] -l -o list_all # 指定设备，查看安装的系统应用和第三方应用 3.5 获取设备信息123456ideviceinfo -u [udid] # 指定设备，获取设备信息ideviceinfo -u [udid] -k DeviceName # 指定设备，获取设备名称：iPhone6sidevicename -u [udid] # 指定设备，获取设备名称：iPhone6sideviceinfo -u [udid] -k ProductVersion # 指定设备，获取设备版本：10.3.1ideviceinfo -u [udid] -k ProductType # 指定设备，获取设备类型：iPhone8,1ideviceinfo -u [udid] -k ProductName # 指定设备，获取设备系统名称：iPhone OS]]></content>
      <categories>
        <category>iOS 逆向</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logos基础语法]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E9%80%86%E5%90%91%2Flogos%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Logos 语法 %hook className 指定需要hook的class，必须以end结尾 如：hook了系统界面的home按钮按下方法 123456%hook SpringBoard- (void)_munuButtonDown:(id)down&#123; NSLog(@&quot;You are press the home button&quot;); %orig;//call the original _menuButton&#125;%end %log 打印日志 1%log((NSString *)@&quot;iOSRE&quot;, (NSString *)@&quot;Debug&quot;); %orig 执行原始代码，必须在%hook里面使用，如果在hook方法里面不增加这一行代码，那么原始函数不会被调用。另外还可以用该函数修改原始函数的参数。 1234567%hook SBLockScreenDateViewController//以下方法设置锁屏界面的日期的文字，改成了lemon love well- (void)setCustomSubtitleText:(id)arg1 withColor:(id)arg2&#123; %orig(@&quot;Lemon love Well&quot;,arg2);&#125;%end %group 用户将%hook分组，便于代码管理和条件初始化分组，必须以%end结尾，一个%group可以包括多个%hook，如果一个%hook不在一个%group里面，那么这个%hook属于%group_ungrouped。 1234567891011121314151617181920%group iOS7Hook %hook iOS7Class - (id)iOS7Method&#123; id result = %orig; NSLog(@&quot;This class &amp; method only exist in iOS 7.&quot;); return result; &#125; %end%end %group iOS8Hook %hook iOS8Class - (id)iOS8Method&#123; id result = %orig; NSLog(@&quot;This class &amp; method only exist in iOS 8.&quot;); return result; &#125; %end%end %init 值得注意的是，每个%group必须配合下面的%init使用才能生效，该指令用户初始化一个%group，必须在%hook里面调用或者%ctor里面调用。如果带参数，那么初始化指定的group，如果不带参数，那么初始化_ungrouped。如： 12345678910111213141516 #ifndef kCFCoreFoundationVersionNumber_iOS_8_0 #define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10 #endif %hook SpringBoard - (void)applicationDidFinishLaunching:(id)application &#123; %orig; %init; // Equals to %init(_ungrouped) if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp; kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_8_0) %init(iOS7Hook);//init iOS7Hook group if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_8_0) %init(iOS8Hook); &#125;%end %ctor，tweak的constructor，完成初始化工作，如果不显式定义，theos会自动生成一个%ctor，并在里面调用%init(_ungrouped)。如 12345678910111213141516171819//以下代码段可以生效，因为theos隐式调用了%ctor并且%init(_ungroped)%hook SpringBoard- (void)reboot&#123; NSLog(@&quot;If rebooting does not word then i screwed&quot;); %orig;//call origin method&#125;%end//以下代码段不能生效，虽然显式定义了%ctor，但是没有在里面调用%init方法%hook SpringBoard - (void)reboot&#123; NSLog(@&quot;If rebooting does not word then i screwed&quot;); %orig;//call origin method&#125;%ctor&#123; //need to call %init here.&#125;%end %new在%hook内部使用，给一个现有的class添加新的函数，功能与class_addMethod一样。 123456%hook SpringBoard%new - (void)createNewMethod&#123; NSLog(@&quot;This is a new method&quot;);&#125; %c 该指令的作用等同于NSClassFromString()或者obj_getClass()动态获取一个类的定义，在%hook或者%ctor内使用。]]></content>
      <categories>
        <category>iOS 逆向</category>
      </categories>
      <tags>
        <tag>logos</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS适配国际化(跟随系统切换和应用内切换)]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E5%BC%80%E5%8F%91%2FiOS%E9%80%82%E9%85%8D%E5%9B%BD%E9%99%85%E5%8C%96-%E8%B7%9F%E9%9A%8F%E7%B3%BB%E7%BB%9F%E5%88%87%E6%8D%A2%E5%92%8C%E5%BA%94%E7%94%A8%E5%86%85%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在开发中我们的APP可能会有海外的版本，可能APP需要匹配英语，俄语，日语等等，这个时候就要做国际化的匹配处理，但是国际化适配也分两种情况，一种是根据iPhone系统语言自动切换界面语言，另外一种是在APP内选择语言，直接刷新APP的界面。下面我会分别介绍这两种情况。Demo在这里 第一种情况，比较简单的跟随系统语言自动切换。这种情况主要使用的是系统提供给我们的一个宏12#define NSLocalizedString(key, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:nil] key的作用是去localizable.strings文件里面根据这个key去匹配文本内容，然后返回。如果用了这个宏，因为实际上调用的是 [NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:nil] 这个方法，table为nil代表默认去Localizable.strings里面找，所以当创建strings文件的时候命名必须为Localizable,如果strings命名为其他名字，那么要用 #define NSLocalizedStringFromTable(key, tbl, comment)指定table的名字为strings的文件名字。以上是基本的介绍。 下面开始说说开发步骤：1.首先需要在项目中增加需要匹配的语言 如我需要匹配的语言是简体中文和英语。2.创建Localizable.strings文件 创建完成后点击该文件，然后在右侧面板的点击Localization 选择English和Chinese，然后就会生成以下两个文件 Localizable.strings(English)代表当系统语言是中文的时候，会来到这个文件根据key匹配textLocalizable.strings(Simplified)代表当系统语言是英文的时候，会来到这个文件根据key匹配text。以下是两个文件的内容： Localizable.strings(English)12&quot;LoginButtonText&quot;=&quot;Login&quot;;&quot;LabelText&quot;=&quot;The language of System is English now&quot;; Localizable.strings(Chinese(simplified))12&quot;LoginButtonText&quot;=&quot;登陆&quot;;&quot;LabelText&quot;=&quot;现在系统的语言是中文&quot;; 3.使用NSLocalizedString(key,comment) 宏来赋值在前面已经说了这个宏的作用了，在我的demo中我给button和label设置text。12[button setTitle:NSLocalizedString(@&quot;LoginButtonText&quot;, @&quot;&quot;) forState:UIControlStateNormal]; label.text = NSLocalizedString(@&quot;LabelText&quot;, @&quot;&quot;); 最后去设置里面切换语言就能看到效果。 第二种情况，像微博或者微信可以在应用的语言设置里面直接设置本APP的语言，这种设置不会影响其他APP，只是本APP的一种行为，主要是利用NSUserDefault来保存本地自定的语言的值，如en,zh-hans等，然后通过读取这个值来加载对应的lproj文件，然后再生成对应的bundle，每个bundle下面就会放着每个table的stings文件。话不多说，以下是开发步骤：1.和第一种情况一样，首先需要在项目中增加需要匹配的语言 2.创建.strings文件，这里和第一种情况不太一样的是，这里你可以任意指定一个名字，如FirstTabBarItem.strings 来放置tabbar的第一个item的多语言文件，SecondTabBarItem.strings 来放置tabbar的第二个item的多语言文件，这里可以灵活处理。创建完strings文件之后，还是和之前一样点击Localization。然后选择你要适配的语言，生成文件。 3.第三步创建一个LocalizableHelper 的类，这个类的作用是提供一个让外界根据key和table来获取文本的宏，当设置成功之后就会发出一个通知，接受者只需要监听这个通知然后更新必要界面就可以了。具体请看demo，里面已经写了所有步骤的注释。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 国际化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS SDK利用Aggregate打包动态库和静态库]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E5%BC%80%E5%8F%91%2FiOS-SDK%E5%88%A9%E7%94%A8Aggregate%E6%89%93%E5%8C%85%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[前言：可能做SDK的iOS开发者都体验过打包动态库或者静态库的时候那些繁琐的步骤，需要分别选择真机和模拟器来编译，最后还要用命令行将他们合并起来，每次都这样打包的话特别麻烦。但是我们可以使用Aggregate的脚本来自动打包。 步骤1新建一个target,选择cross-platform的Aggregate，如下图 步骤2创建完Aggregate之后，增加一个run script，具体步骤为，选中刚刚创建的Aggregate target,然后在build phases 下面点击加号，选择 new run script phase 步骤3在图中红色框框标注的地方输入以下脚本 如果要生成.a后缀的静态库，那么使用以下脚本1234567891011121314151617181920212223242526272829303132set -e# Sets the target folders and the final framework product.# 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME# 例如: FMK_NAME=&quot;MyFramework&quot;FMK_NAME=&quot;IDMPCMCC&quot;# Install dir will be the final output to the framework.# The following line create it in the root folder of the current project.# 获取当前时间DATE=$(date +%Y%m%d-%H:%M:%S)# 定义IDMPCMCC+当前时间 命名的文件夹名字INSTALL_DIR=$&#123;HOME&#125;/Desktop/IDMPCMCC$&#123;DATE&#125;# 支持真机静态库所在的路径DEVICE_DIR=$&#123;BUILD_DIR&#125;/Release-iphoneos/# 支持模拟器静态库所在的路径SIMULATOR_DIR=$&#123;BUILD_DIR&#125;/Release-iphonesimulator/# -configuration $&#123;CONFIGURATION&#125;# Clean and Building both architectures.# 配置生成静态库一些参数xcodebuild build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot; -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphoneos clean build ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTIONxcodebuild build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot; -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphonesimulator clean build ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION# Cleaning the oldest.if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]thenrm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;fimkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.# 合并真机和模拟器架构静态库lipo -create &quot;$&#123;DEVICE_DIR&#125;/lib$&#123;FMK_NAME&#125;.a&quot; &quot;$&#123;SIMULATOR_DIR&#125;/lib$&#123;FMK_NAME&#125;.a&quot; -output &quot;$&#123;INSTALL_DIR&#125;/lib$&#123;FMK_NAME&#125;.a&quot;open &quot;$&#123;INSTALL_DIR&#125;&quot; 如果要生成.framework的静态库或者动态库的话，使用以下脚本12345678910111213141516171819202122232425262728set -e# Sets the target folders and the final framework product.# 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME# 例如: FMK_NAME=&quot;MyFramework&quot;FMK_NAME=&quot;IDMPCMCC&quot;# Install dir will be the final output to the framework.# The following line create it in the root folder of the current project.# 获取当前时间DATE=$(date +%Y%m%d-%H:%M:%S)# 定义IDMPCMCC+当前时间 命名的文件夹名字INSTALL_DIR=$&#123;HOME&#125;/Desktop/IDMPCMCC$&#123;DATE&#125;/$&#123;FMK_NAME&#125;.frameworkDEVICE_DIR=$&#123;BUILD_DIR&#125;/Release-iphoneos/$&#123;FMK_NAME&#125;.frameworkSIMULATOR_DIR=$&#123;BUILD_DIR&#125;/Release-iphonesimulator/$&#123;FMK_NAME&#125;.framework# -configuration $&#123;CONFIGURATION&#125;# Clean and Building both architectures.xcodebuild build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot; -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphoneos clean build ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTIONxcodebuild build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot; -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphonesimulator clean build ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION# Cleaning the oldest.if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]thenrm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;fimkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.lipo -create &quot;$&#123;DEVICE_DIR&#125;/$&#123;FMK_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;/$&#123;FMK_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;/$&#123;FMK_NAME&#125;&quot;open &quot;$&#123;INSTALL_DIR&#125;&quot; build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot;这一句代码是用来开启bitcode 步骤4选择创建的Aggregate运行即可。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>SDK</tag>
        <tag>Aggregate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS链式编程实(仿Masonry框架)]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E5%BC%80%E5%8F%91%2FiOS%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E-%E4%BB%BFMasonry%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[前言： 相信做过iOS开发的都知道系统给开发者提供的代码设置约束有多难用，设置一个元素的位置往往要写十多行的代码，因为NSLayoutConstraint这个类是在太难用了。所以一个简单的代码布局框架就会很受开发者欢迎。所以也有了这次实践，通过链式编程实现简单的自动布局。下面也是模仿Masonry做一套自己的自动布局框架。 1.先看看我们最终实现同样的效果的代码对比1.1使用系统代码设置约束greenView.translatesAutoresizingMaskIntoConstraints = NO; [superview addConstraints:@[ //greenView constraints [NSLayoutConstraint constraintWithItem:greenView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeTop multiplier:1.0 constant:20], [NSLayoutConstraint constraintWithItem:greenView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeLeft multiplier:1.0 constant:20], [NSLayoutConstraint constraintWithItem:greenView attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:80], [NSLayoutConstraint constraintWithItem:greenView attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:80], ]]; 1.2使用链式编程实现约束123456[greenView makeLayout:^void(LMLayout *layout) &#123; layout.width.equalTo(@(80)); layout.height.equalTo(@80); layout.left.equalTo(self.view.lm_left).offSet(20); layout.top.equalTo(self.view.lm_top).offSet(20); &#125;]; 2.以上的代码缩减了这么多主要是因为将复杂的方法调用用链式的方式实现出来了，那么什么是链式编程呢？1layout.left.equalTo(self.view.lm_left).offSet(20); 以这句代码为例，可以通过点语法一直不断的调用下一个方法，像一条链子一样，这样的方式就叫做链式编程。 那么在代码层面，如何可以实现一直不断的通过点语法调用下一个方法。实质上就是通过点语法调用方法的时候，返回一个block。而这个block必须需要包涵一个很重要的特点，这个block有返回值，这个返回值的类型是一个调用下一个方法的对象，这样下次又可以通过这个对象执行下一个方法。代码示例为：1-(LMLayout *(^)(NSObject *object))equalTo; 上述代码返回了一个(LMLayout (^)(NSObject object)block,该block返回了一个LMLayout对象，以便后面可以继续调用下一个方法，然后接受输入一个object的参数，该参数可以用来设置内部的约束的值。 3.基于以上的了解，我们开始着手写一个仿masonry的框架。以下使我们最终要实现的调用方式123456[greenView makeLayout:^void(LMLayout *layout) &#123; layout.width.equalTo(@(80)); layout.height.equalTo(@80); layout.left.equalTo(self.view.lm_left).offSet(20); layout.top.equalTo(self.view.lm_top).offSet(20); &#125;]; 3.1先从外层的方法看起，首先给UIView创建了一个分类，并且定义了一个makeLayout的方法，需要传进一个block的参数，该block的作用就是设置greenView的约束。所以最外层的方法就是UIView+layout.h 文件1- (void)makeLayout:(void(^)(LMLayout *layout))layoutBlock; UIView+layout.m文件1234- (void)makeLayout:(void(^)(LMLayout *layout))layoutBlock&#123; LMLayout *layout = [[LMLayout alloc]initWithView:self]; layoutBlock(layout);&#125; 在以上的方法中，创建了一个LMLayout的对象，并且将当前的view作为参数去初始化LMLayout对象。接下来看看一些LMLayout的初始化方法的实现。12345678- (instancetype)initWithView:(UIView *)view&#123; NSAssert([view superview]!=nil, @&quot;未能找到view的superView&quot;); if (self = [super init]) &#123; _view = view; view.translatesAutoresizingMaskIntoConstraints = NO; &#125; return self;&#125; 在初始化方法内部会判断当前设置约束的view是否有superView，并且用属性保存当前传进来的view，关闭translatesAutoresizingMaskIntoConstraints。再返回到上一个方法，初始化完成之后就执行该block，将初始化好的layout对象传过去。 3.2 接下来看block内部的调用1layout.width.equalTo(@(80)); 一层一层分析，layout.width实质上是调用了-(LMLayout*)width; 看看该方法内部的实现。1234-(LMLayout*)width&#123; _property = PropertyTypeWidth; return self;&#125; PropertyTypeWidth 是一个枚举值，表示当前设置约束的属性是width，然后返回当前layout对象。既然返回了layout对象，那么同样可以通过点执行下一个方法1layout.equalTo(@(80)) 同样看一下方法的定义和实现.h1-(LMLayout *(^)(NSObject *object))equalTo; .m12345678910111213141516171819202122232425262728293031323334353637383940-(LMLayout *(^)(NSObject *object))equalTo&#123; __weak typeof(self)weakSelf = self; return ^(NSObject *object)&#123; //判断外部调用equalTo()这个block的时候会传什么值 //如果是直接设置属性的值 if ([object isKindOfClass:[NSNumber class]]) &#123; CGFloat floatValue = [(NSNumber*)object floatValue]; NSLayoutAttribute attribute = NSLayoutAttributeHeight; switch (weakSelf.property) &#123; case PropertyTypeWidth: attribute = NSLayoutAttributeWidth; break; case PropertyTypeHeight: attribute = NSLayoutAttributeHeight; break; default: attribute = NSLayoutAttributeNotAnAttribute; break; &#125; NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:weakSelf.view attribute:attribute relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:floatValue]; //检测之前是否已经设置了旧的同一属性的约束，如果是就删除，添加新的约束 [weakSelf checkIfExistOldLayoutWithNewLayout:constraint]; [weakSelf.view addConstraint:constraint]; &#125; //如果是设置一个参照view else if([object isKindOfClass:[NSDictionary class]])&#123; NSDictionary *dict = (NSDictionary*)object; UIView *view = (UIView *)dict[@&quot;view&quot;]; weakSelf.conferenceView = view; weakSelf.conferProperty = [dict[@&quot;property&quot;] floatValue]; NSLayoutAttribute attribute = [LMLayout attributeWithProperty:weakSelf.property]; NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:weakSelf.view attribute:attribute relatedBy:NSLayoutRelationEqual toItem:weakSelf.conferenceView attribute:weakSelf.conferProperty multiplier:1 constant:0]; //检测之前是否已经设置了旧的同一属性的约束，如果是就删除，添加新的约束 [weakSelf checkIfExistOldLayoutWithNewLayout:constraint]; weakSelf.currentConstraint = constraint; [weakSelf.view.superview addConstraint:constraint]; &#125; return self; &#125;; 上述方法首先返回一个返回值类型为LMLayout，参数类型型为NSObject对象的Block，为什么是NSObject对象类型，因为equalTo有可能会直接传入一个数值，也有可能会传入一个view的属性，如：12layout.height.equalTo(@80);layout.left.equalTo(self.view.lm_left).offSet(20); 3.2.1 首先看传进来的是一个数值的情况如果传进来是一个数值，那么会判断之前是否已经设置过该约束，如果已经设置过就删除该约束，重新添加新的约束。 3.2.2 如果是.equalTo(self.view.lm_left)这种形式，括号内的self.view.lm_left实质上是执行了UIView的分类的1-(NSDictionary&lt;UIView *,NSNumber *&gt;*)lm_left; .m文件1234567-(NSDictionary&lt;UIView *,NSNumber *&gt;*)lm_left&#123; return [self dictWithProperty:PropertyTypeLeft];&#125;- (NSDictionary&lt;UIView *,NSNumber *&gt;*)dictWithProperty:(PropertyType)type&#123; NSDictionary *dict = @&#123;@&quot;view&quot;:self,@&quot;property&quot;:@([LMLayout attributeWithProperty:type])&#125;; return dict;&#125; 方法内部会返回一个字典，字典的第一个参数表示需要参照的view，第二个参数表示的参照view的哪个属性。当接收到返回的字典之后，因为之前已经获取了需要约束的view和需要约束的属性，现在也获取了参照的view和参照的属性，可以创建NSLayoutConstraint对象，并且添加约束到他们共同的superView上面。 3.3 下面来关注一下offset(20)1layout.left.equalTo(self.view.lm_left).offSet(20); .h1-(void(^LayoutOffsetBlock)(CGFloat offset))offSet; .m123456789101112-(void(^LayoutOffsetBlock)(CGFloat offset))offSet&#123; __weak typeof(self)weakSelf = self; return ^(CGFloat margin)&#123; NSLayoutAttribute attribute = [LMLayout attributeWithProperty:weakSelf.property]; NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:weakSelf.view attribute:attribute relatedBy:NSLayoutRelationEqual toItem:weakSelf.conferenceView attribute:weakSelf.conferProperty multiplier:1 constant:margin]; if (weakSelf.currentConstraint.firstItem == constraint.firstItem &amp;&amp; weakSelf.currentConstraint.firstAttribute == constraint.firstAttribute &amp;&amp; weakSelf.currentConstraint.secondItem == constraint.secondItem &amp;&amp; weakSelf.currentConstraint.secondAttribute == constraint.secondAttribute) &#123; weakSelf.currentConstraint.constant = margin; //[weakSelf.view.superview removeConstraint:weakSelf.currentConstraint]; // [weakSelf.view.superview addConstraint:constraint]; &#125; &#125;;&#125; 该方法内部首先会根据枚举值拿到对应的NSLayoutAttribute，然后判断是否已经设置了该约束，如果是，那么直接修改该约束的值。 4 设置其他约束的方法都和上述类似。相关的源码已经上传到LMlayout，具体可以查看github.]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>链式编程</tag>
        <tag>masonry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用xcode7创建静态库和动态库的完整过程]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E5%BC%80%E5%8F%91%2F%E4%BD%BF%E7%94%A8xcode7%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、创建项目 首先先创建一个简单的iOS项目用来测试SDK,创建完成项目结构如下： 点击项目名称，在右侧Target选项中点击加号，在选择面板中选择cocoa touch framework，然后点击next.然后填写SDK的名字，然后点击finish.最后targets选项的项目如下图所示：其中最下面的SDK就是我创建的库。 2、编写framework的代码 在你的framework文件夹下面右键add file,然后开始编码，这里就不细说了，和平时写的类一样，只是一定要保证你的文件是在你创建的framework里面.然后在.h头文件中提供给外界使用的方法属性等。 3、配置项目 上面我们已经创建好了项目并且逻辑代码都写好了，接下来 需要对项目做一些配置，Let’s do it. 首先对framework进行一些基本的设置，根据自身需要来设置，还是在targets选选中你的framework的名字，然后在buildsetting那里找到architectures设置支持的指令集，默认是没有支持armv7s的，所以我们要手动添加,点击右边的选项，然后选择other，然后在弹出框中点击下面的加号，然后添加 armv7s 。最后添加完成如下图所示： 设置iOS deployment target ，表示最低支持iOS的系统版本，根据个人情况来选择，一般如果是动态库，那么是8.0，如果是静态库是7.0。 3.3设置静态库支持bitcode 如下图所示：设置other c flag ,在release那里添加 -fembed-bitcode 。 如果要忽略一些警告，还可以在other warning flag那里输入一些值，具体可以[看这里](http://www.cocoachina.com/ios/20141218/10678.html)。 因为你正在创建framework供他人使用，最好禁掉这些功能（无效代码和debug用符号），让用户自己选择对自己的项目有利的部分使用。和之前一样，使用搜索框，改变下述设置： Dead Code Stripping设置为NOStrip Debug Symbol During Copy 全部设置为NOStrip Style设置为Non-Global Symbols如果使用了category ，则使用该FMWK的程序运行时会crash，此时需要在该工程中 other linker flags 添加两个参数 -ObjC -all_load编译出Framework是，需要把 GenerateDebugSymbols ＝NO，否则会出现很多 warning:例如 .pcm not such file or directory 设置framework为动态库或者静态库。Dynamic library为动态库，Static library为静态库。 然后切换到Build Phases选项卡中，打开headers,将你要提供给外界使用的头文件暴露出来，默认该文件都是在Project里面的 然后将要供外界使用的头文件拖拽到public下面。 到这里framework的的设置就完成了，接下来可以设置项目来使用framework。 4、项目引用framework 在左上角的导航栏那里选择刚开始创建的测试项目，然后选择edit scheme 在Run选项那里，点击右侧下面的加号，然后在弹出面板选择我们创建的framework,点击close。 然后就可以在项目中引入头文件使用里面的类。 5.关于framework打包 在左上角的导航栏那里选择创建的framework,然后点击edit scheme 然后在Run选项中，将build configuration 设置为release 如果build的时候选择的是模拟器，那么编译出来的framework就是可以在模拟器上运行的，但是真机不行，如果想在真机使用，build的时候必须选择真机。 可以使用 lipo -info 来查看framework支持的cpu可以使用lipo -create 来合并两个framework 需要注意的是，如果是使用了合并模拟器和真机结构的静态库，上传到app么没有问题，如果是使用了合并模拟器和真机结构的冬天库，archive的时候会报错，错误信息大致是不能包含用i386或者x86-64架构的framework，所以发布的时候记得使用真机版本的framework. 以上只是个人对于framework的一些探究，如果有什么纰漏或者错误的地方，欢迎指正。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>SDK</tag>
        <tag>动态库</tag>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS使用AMR进行编码和解码]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E5%BC%80%E5%8F%91%2FiOS%E4%BD%BF%E7%94%A8AMR%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在上一篇文章中将采样率为16K的amr的库编译出来了，并且已经放到github上面： vo-amrwbenc编译然后我做了一个如何使用amr进行编码和解码的demo,demo里面主要包含了一个8K和16K的编解码，两种编解码方式使用的是不同的静态库，具体可以下载代码来看。AMR编码和解码]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>AMR</tag>
        <tag>wav</tag>
        <tag>音频开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用opencore_amr实现wav转amr(8khz,16khz)]]></title>
    <url>%2F2018%2F07%2F25%2FiOS%20%E5%BC%80%E5%8F%91%2F%E4%BD%BF%E7%94%A8opencore-amr%E5%AE%9E%E7%8E%B0wav%E8%BD%ACamr-8khz-16khz%2F</url>
    <content type="text"><![CDATA[由于公司正在做声纹方面的开发，所以需要对语音数据做压缩，目前想到了三种压缩方式，1是AMR，2是Speex,3是Opus,这里先说第一种方式，在iOS4.0之前是可以进行amr格式的录音的，后来苹果取消了这个声音格式，但是可以使用opencore-amr来将wav格式转换为amr格式。 目前网上的例子大多数都是8Khz采样率的wav文件转AMR,具体可以参照iOS音频格式之AMR和WAV互转(更新支持64位)，这里也要感谢这篇博文的作者黄俊鹏，他给我提供了帮助我才找到了方法。但是我们公司由于对于声音采集样本的要求比较高，所以我们要使用16Khz的采样率，那么问题就出现了，在opencore-amr中并没有提供amr-wb的encode方法，8kHZ使用的opencore-amrnb.a的静态库，其中提供了encode和decode的方法，但是对于16Khz使用的是opencore-amrwb的静态库，其中里面只提供了decode的方法，后来通过其他资料我我才明白encode在另外一个项目vo-amrwbenc里面，如果要使用的话必须要单独编译这个项目才可以，项目下载可以看opencore-amr，所以如果需要将16Khz wav文件转为amr文件，只需要编译这个库然后使用就可以了，如果要解码那么还是需要使用原来的opencore-amr库。 #下面就可以编译vo-amrwebenc 1.首先新建一个文件夹，将下载到的vo-amrwbenc-0.1.3.tar.gz压缩包放到里面（有可能下载下来的不一定是这个版本，因为这个库会更新，所以下面的命令也要跟着改变VERSION为对应的下载的压缩包的版本），然后进入这个文件夹，在里面创建build.sh文件,将以下脚本粘贴到文件里面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#!/bin/shset -xe# 注意这里需要改为下载下来的压缩包的版本VERSION=&quot;0.1.3&quot;LIBSRCNAME=&quot;vo-amrwbenc&quot;CURRENTPATH=`pwd`mkdir -p &quot;$&#123;CURRENTPATH&#125;/src&quot;# 下载压缩包的后缀有可能是tar不一定是tar.gz，下面也要根据情况修改tar zxvf $&#123;LIBSRCNAME&#125;-$&#123;VERSION&#125;.tar.gz -C &quot;$&#123;CURRENTPATH&#125;/src&quot;cd &quot;$&#123;CURRENTPATH&#125;/src/$&#123;LIBSRCNAME&#125;-$&#123;VERSION&#125;&quot;# 设置环境变量并创建lib-ios文件夹，后续生成的.a类库都会放在这个文件夹里边DEST=&quot;$&#123;CURRENTPATH&#125;/lib-ios&quot;mkdir -p &quot;$&#123;DEST&#125;&quot;ARCHS=&quot;armv7 armv7s arm64 i386 x86_64&quot;LIBS=&quot;libvo-amrwbenc.a&quot;for arch in $ARCHS; docase $arch in arm*)IOSV=&quot;-miphoneos-version-min=7.0&quot;if [ $arch == &quot;arm64&quot; ]thenIOSV=&quot;-miphoneos-version-min=7.0&quot;fiecho &quot;Building for iOS $arch ****************&quot;# 编译 $arch 环境的类库（amr类型类型）SDKROOT=&quot;$(xcrun --sdk iphoneos --show-sdk-path)&quot;CC=&quot;$(xcrun --sdk iphoneos -f clang)&quot;CXX=&quot;$(xcrun --sdk iphoneos -f clang++)&quot;CPP=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;CFLAGS=&quot;-isysroot $SDKROOT -arch $arch $IOSV -isystem $SDKROOT/usr/include -fembed-bitcode&quot;CXXFLAGS=$CFLAGSCPPFLAGS=$CFLAGSexport CC CXX CFLAGS CXXFLAGS CPPFLAGS./configure \--host=arm-apple-darwin \--prefix=$DEST \--disable-shared --enable-static;;*)IOSV=&quot;-mios-simulator-version-min=7.0&quot;echo &quot;Building for iOS $arch*****************&quot;SDKROOT=`xcodebuild -version -sdk iphonesimulator Path`CC=&quot;$(xcrun -sdk iphoneos -f clang)&quot;CXX=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;CPP=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;CFLAGS=&quot;-isysroot $SDKROOT -arch $arch $IOSV -isystem $SDKROOT/usr/include -fembed-bitcode&quot;CXXFLAGS=$CFLAGSCPPFLAGS=$CFLAGSexport CC CXX CFLAGS CXXFLAGS CPPFLAGS./configure \--prefix=$DEST \--disable-shared;;esacmake &gt; /dev/nullmake install make clean for i in $LIBS; domv $DEST/lib/$i $DEST/lib/$i.$archdonedonefor i in $LIBS; doinput=&quot;&quot;for arch in $ARCHS; doinput=&quot;$input $DEST/lib/$i.$arch&quot;donelipo -create -output $DEST/lib/$i $inputdone ##2.修改build.sh的权限，打开终端，cd到新建的文件夹，使用命令 chmod 777 build.sh 修改权限。 ##3.修改完成之后在终端执行 ./build.sh 就会在vo-amrwbenc里面生成一个lib-ios文件夹，里面就包含了libvo-amrwbenc.a的静态库和enc_if_h的头文件。 最后我已经将编译好的项目放到github上面 vo-amrwbenc编译 4.更新——————-2018.8.16更新———————————————今天有收到issues说编码的效率很慢，然后需要更新open-amr的库然后重新编译，大家需要到opencore-amr下载最新的库，然后重新编译打包静态库，下面附上打包脚本，打包方法和上面一致。同时记得要改一下脚本里面压缩报的版本和压缩后缀。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/bin/shset -xe VERSION=&quot;0.1.3&quot;SDKVERSION=&quot;8.4&quot;LIBSRCNAME=&quot;opencore-amr&quot; CURRENTPATH=`pwd` mkdir -p &quot;$&#123;CURRENTPATH&#125;/src&quot;tar zxvf $&#123;LIBSRCNAME&#125;-$&#123;VERSION&#125;.tar.gz -C &quot;$&#123;CURRENTPATH&#125;/src&quot;cd &quot;$&#123;CURRENTPATH&#125;/src/$&#123;LIBSRCNAME&#125;-$&#123;VERSION&#125;&quot; DEVELOPER=`xcode-select -print-path`DEST=&quot;$&#123;CURRENTPATH&#125;/lib-ios&quot;mkdir -p &quot;$&#123;DEST&#125;&quot; ARCHS=&quot;armv7 armv7s arm64 i386 x86_64&quot;# ARCHS=&quot;armv7&quot;LIBS=&quot;libopencore-amrnb.a libopencore-amrwb.a&quot; DEVELOPER=`xcode-select -print-path` for arch in $ARCHS; docase $arch inarm*) IOSV=&quot;-miphoneos-version-min=7.0&quot;if [ $arch == &quot;arm64&quot; ]thenIOSV=&quot;-miphoneos-version-min=7.0&quot;fi echo &quot;Building for iOS $arch ****************&quot;SDKROOT=&quot;$(xcrun --sdk iphoneos --show-sdk-path)&quot;CC=&quot;$(xcrun --sdk iphoneos -f clang)&quot;CXX=&quot;$(xcrun --sdk iphoneos -f clang++)&quot;CPP=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;CFLAGS=&quot;-isysroot $SDKROOT -arch $arch $IOSV -isystem $SDKROOT/usr/include -fembed-bitcode&quot;CXXFLAGS=$CFLAGSCPPFLAGS=$CFLAGSexport CC CXX CFLAGS CXXFLAGS CPPFLAGS ./configure \--host=arm-apple-darwin \--prefix=$DEST \--disable-shared --enable-static;;*)IOSV=&quot;-mios-simulator-version-min=7.0&quot;echo &quot;Building for iOS $arch*****************&quot; SDKROOT=`xcodebuild -version -sdk iphonesimulator Path`CC=&quot;$(xcrun -sdk iphoneos -f clang)&quot;CXX=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;CPP=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;CFLAGS=&quot;-isysroot $SDKROOT -arch $arch $IOSV -isystem $SDKROOT/usr/include -fembed-bitcode&quot;CXXFLAGS=$CFLAGSCPPFLAGS=$CFLAGSexport CC CXX CFLAGS CXXFLAGS CPPFLAGS./configure \--prefix=$DEST \--disable-shared;;esacmake &gt; /dev/nullmake installmake cleanfor i in $LIBS; domv $DEST/lib/$i $DEST/lib/$i.$archdonedone for i in $LIBS; doinput=&quot;&quot;for arch in $ARCHS; doinput=&quot;$input $DEST/lib/$i.$arch&quot;donelipo -create -output $DEST/lib/$i $inputdone]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>AMR</tag>
        <tag>wav</tag>
        <tag>音频开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo在github上搭建自己的博客]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF%2F%E4%BD%BF%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[0x01 简介 hexo是node.js提供的一个强大的，并且简单快速搭建自己博客的工具，通过该工具可以快速的搭建起自己的博客，该工具还提供了一系列的主题，可以快捷的设置不同主题。通过修改几个命令就可以将搭建好的博客部署到github上。下面将会讲解如何1.通过hexo搭建自己的博客 2.如何设置博客的主题 3.如何应用到github 4.域名关联，通过自己的域名访问博客 0x02 准备工作 在开始工作之前你需要做一些准备工作 创建一个github账号，如果没有的话 安装node.js 安装npm 0x03 LET’S DO IT1、 首先在登录你的github账号，并且创建一个仓库，这个仓库的名字一定要按照特定的格式来写：也就是你的 用户名.github.io，如下图所示：由于我之前已经创建过相同命名的仓库，所以会提示我已经重复了，以上的截图只是用于做仓库命名的示例，切记仓库的名字一定是 用户名.github.io 2、 如果github上面没有配置SSH的话需要在本地生成一个公钥，然后配置到github上面。（如果已经配置的可以直接看第三步） 使用以下命令创建一对公私秘钥 12$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; //创建秘钥，执行该命令后一直回车即可$ cat ~/.ssh/id_rsa.pub //创建完成后查看创建好的公钥 将上面创建好的公钥复制，然后登录github, 按照Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key的步骤，粘贴公钥即可。 3、 安装hexo 1$ npm install -g hexo 4、 初始化目录在本地创建一个文件夹，可以随便起一个名字， 然后进入到该文件夹里面，通过hexo init初始化，初始化完成后会在该文件夹里面生成一些文件。 123Lemons-MacBookPro:~ lemon$ mkdir hexoLemons-MacBookPro:~ lemon$ cd hexo/Lemons-MacBookPro:hexo lemon$ hexo init 生成的目录如下所示： 5、 修改 _config.yml: 配置文件，可以在里面配置博客的名字，描述，主题，部署到哪里等等，下面来看一下里面主要需要修改的地方。设置博客网站的标题，副标题，描述，作者的名字，语言，时区 12345678 # Sitetitle: Lemon&apos;s blogsubtitle: Talk is cheap show me the codedescription: iOS Developer | 拥抱变化 | 🍋😊keywords: author: lemonlanguage: zh-CNtimezone: Asia/Shanghai 需要部署到哪个平台,你需要修改的地方是repo，将仓库的地址换成在第一步创建的仓库地址 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:codemonkeybulucck/codemonkeybulucck.github.io.git branch: master 6、在本地浏览器查看博客的效果 1234567891011$ hexo generate # 生成，可以用简写 hexo g$ hexo server # 启动服务，可以用简写 hexo sINFO Start processingWARN ===============================================================WARN ========================= ATTENTION! ==========================WARN ===============================================================WARN NexT repository is moving here: https://github.com/theme-nextWARN ===============================================================WARN It&apos;s rebase to v6.0.0 and future maintenance will resume thereWARN ===============================================================INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 这样就会将博客部署到本地，在浏览器打开http://localhost:4000/ 即可访问 7、在第六步中我们看到的生成默认主题的博客，我们也许想换成更加符合我们审美的主题。 我们可以在 hexo有哪些好看的主题这里找到我们自己喜欢的主题，下面以 hexo-theme-next 为例。 还是在我们的博客目录，下载主题到该目录下的theme文件夹 1$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next 下载完成之后，打开_config.yml文件修改以下地方 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 将原来的默认的主题改为next，然后执行hexo server 来重新生成本地博客，这个时候在浏览器查看会发现主题和之前的不一样了。你还可以在theme-&gt;next-&gt;_config.yml文件夹里面修改布局，可以设置下面四个中任意的一个 12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 8、 到此为止我们已经搭建好博客并且设置了相应的主题，下面我们来试一下写一篇博客。博客的类型是markdown格式，可以下载一个Mweb来提前写好文章然后复制到source-&gt;_posts文件夹里面，也通过通过 hexo new post “博客名字”来生成一个markdown类型的博客 9、上传到github，由于我们在第5点已经设置了github的地址，因此我们直使用 hexo deploy来上传即可。如果发现执行以上命令后有如下错误Deployer not found: github 或者 Deployer not found: git则需要先安装一个插件 npm install hexo-deployer-git --save安装完该插件之后继续执行 hexo deploy 即可通过 你的用户名.github.io来访问你的博客。下面是我的博客 codemonkeybulucck 10、绑定域名，如果没有域名的可以到阿里万网 购买一个域名，购买完成后到控制台找到对应的域名，添加解析，域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问按照我下面的设置即可 设置完成之后还不可以立刻使用域名访问，需要到本地的博客的目录下的source文件夹里面创建一个CNAME文件，里面填写购买的域名然后重新 hexo deploy之后就可以通过域名来访问你的博客了。 0x04 以上，希望能帮助到你。]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
