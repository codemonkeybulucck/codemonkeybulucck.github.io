<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>逆向微信根据手机号码搜索联系人获取WXID</title>
      <link href="/2019/04/02/iOS%20%E9%80%86%E5%90%91/%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E6%A0%B9%E6%8D%AE%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E6%90%9C%E7%B4%A2%E8%81%94%E7%B3%BB%E4%BA%BA%E8%8E%B7%E5%8F%96WXID/"/>
      <url>/2019/04/02/iOS%20%E9%80%86%E5%90%91/%E9%80%86%E5%90%91%E5%BE%AE%E4%BF%A1%E6%A0%B9%E6%8D%AE%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E6%90%9C%E7%B4%A2%E8%81%94%E7%B3%BB%E4%BA%BA%E8%8E%B7%E5%8F%96WXID/</url>
      <content type="html"><![CDATA[<blockquote><p>这段时间在忙着新版本SDK的开发，也在准备换工作的事情，虽然现在是“寒潮”，但是还是想走出舒适区，去感受一下春天的“寒冷”。也很久没有接触逆向方面的工作了，昨天一个大学同学问我，能不能通过一个人的手机号以及微信号找到那个人对应的wxid，其实我也不清楚，但是我们来尝试一下找一下。</p></blockquote><h3 id="1-wxid-是什么？"><a href="#1-wxid-是什么？" class="headerlink" title="1. wxid 是什么？"></a>1. wxid 是什么？</h3><p>wxid是顾名思义就是微信的ID，也就是一个手机号码刚注册的时候，微信给予用户的一个初始化ID，这个和后面的微信号其实是分开的，经过我测试，如果设置了微信号之后，可能原始的wxid就会被覆盖。但是也有一些是不会被覆盖的，这个就不清楚微信是怎么处理的了。</p><a id="more"></a><h3 id="2-开始wxid的寻找之旅"><a href="#2-开始wxid的寻找之旅" class="headerlink" title="2. 开始wxid的寻找之旅"></a>2. 开始wxid的寻找之旅</h3><h4 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h4><p>当我们通过手机号码查找一个人的时候，查找出来的界面是只会显示下面的信息，不会有wxid或者微信号这样的信息。</p><p><img src="media/15537420649103/15537427751243.jpg" alt="-w160"></p><p>但是直觉告诉我，既然已经搜出来这个人，那么这个控制器里面肯定有一个包含这个人信息的对象，看一下那个对象里面的全部信息，可能会找到我想要的。所以我们的目标就是找到这个对象的控制器，然后看看里面有没有一个类似于联系人之类的对象，然后再看一下这个对象里面的属性。Let’s do it.</p><h4 id="2-2-探究"><a href="#2-2-探究" class="headerlink" title="2.2 探究"></a>2.2 探究</h4><blockquote><p>在探究之前如果你不清楚LLDB+DebugServer的使用可以看<a href="http://lemon2well.top/2018/07/25/iOS%20逆向/LLDB-debugserver的使用/">这里</a></p></blockquote><h4 id="2-3-首先拿出我那台祖传的iPhone，连上数据线，然后SSH登陆上去："><a href="#2-3-首先拿出我那台祖传的iPhone，连上数据线，然后SSH登陆上去：" class="headerlink" title="2.3 首先拿出我那台祖传的iPhone，连上数据线，然后SSH登陆上去："></a>2.3 首先拿出我那台祖传的iPhone，连上数据线，然后SSH登陆上去：</h4><ul><li>iTerm打开一个窗口，将本地的2222端口映射到iPhone的22端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Last login: Thu Mar 28 11:20:01 on ttys003</span><br><span class="line">LemonsMcBookPro:~ lemon$ tcprelay.py -t 22:2222</span><br><span class="line">Forwarding local port 2222 to remote port 22</span><br></pre></td></tr></table></figure><ul><li>iTerm打开另外一个窗口，通过ssh连接上去</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LemonsMcBookPro:~ lemon$ ssh root@localhost -p 2222</span><br><span class="line">lemons-iPhone5S:~ root#</span><br></pre></td></tr></table></figure><h4 id="2-4-登陆上去之后，看一下当前微信的进程ID，然后通过将debugserver挂到微信上面，然后接受来自LLDB的命令，达到动态调试微信的目的。"><a href="#2-4-登陆上去之后，看一下当前微信的进程ID，然后通过将debugserver挂到微信上面，然后接受来自LLDB的命令，达到动态调试微信的目的。" class="headerlink" title="2.4 登陆上去之后，看一下当前微信的进程ID，然后通过将debugserver挂到微信上面，然后接受来自LLDB的命令，达到动态调试微信的目的。"></a>2.4 登陆上去之后，看一下当前微信的进程ID，然后通过将debugserver挂到微信上面，然后接受来自LLDB的命令，达到动态调试微信的目的。</h4><ul><li>先在手机运行微信，然后查找微信的进程ID，然后通过debugserver监听来自1234端口的消息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LemonsMcBookPro:~ lemon$ ssh root@localhost -p 2222</span><br><span class="line">lemons-iPhone5S:~ root# ps -e | grep /var</span><br><span class="line">  632 ??         0:04.03 /usr/libexec/pkd -d/var/db/PlugInKit-Annotations</span><br><span class="line"> 1902 ??         0:11.14 /var/containers/Bundle/Application/2A191819-B0B1-41DB-813A-ED369475D3B9/NewsLite.app/NewsLite</span><br><span class="line"> 1910 ??         0:02.20 /var/containers/Bundle/Application/0841859F-B658-4A66-AB81-6B51C4A04D7B/Chain.app/Chain</span><br><span class="line"> 1991 ??         0:45.40 /var/containers/Bundle/Application/81DE6416-3F32-4C7E-BD0C-ABA1585E77E2/wework.app/wework</span><br><span class="line"> 2612 ??         2:16.97 /var/containers/Bundle/Application/5FE48592-3233-47A2-B933-C2F0CF277F14/WeChat.app/WeChat</span><br><span class="line"> 2721 ??         0:31.45 /var/containers/Bundle/Application/A7E1F925-9859-4C2C-9092-C10B719E604F/AndFetion.app/AndFetion</span><br><span class="line"> 2996 ??         0:04.00 /var/containers/Bundle/Application/06B248D3-61C9-48EC-98BF-A95BEFC782BA/WhatsApp.app/WhatsApp</span><br><span class="line"> 3392 ttys000    0:00.01 grep /var</span><br><span class="line">lemons-iPhone5S:~ root# debugserver *:1234 -a 2612</span><br><span class="line">debugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-340.3.124</span><br><span class="line"> for arm64.</span><br><span class="line">Attaching to process 2612...</span><br><span class="line">Listening to port 1234 for a connection from *...</span><br></pre></td></tr></table></figure><ul><li>此时debugserver正在监听1234端口的消息。此时我们还是通过将本地的1234端口映射到iPhone的1234端口，然后连接本地的1234端口。<br>iTerm 打开一个新窗口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Last login: Thu Mar 28 11:20:24 on ttys003</span><br><span class="line">LemonsMcBookPro:~ lemon$ tcprelay.py -t 1234:1234</span><br><span class="line">Forwarding local port 1234 to remote port 1234</span><br><span class="line">Incoming connection to 1234</span><br><span class="line">Waiting for devices...</span><br></pre></td></tr></table></figure><p>  iTerm 打开一个新窗口</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Last login: Thu Mar 28 11:31:52 on ttys005</span><br><span class="line">LemonsMcBookPro:~ lemon$ lldb</span><br><span class="line">(lldb) process connect connect://localhost:1234</span><br><span class="line">Process 2612 stopped</span><br><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = signal SIGSTOP</span><br><span class="line">    frame #0: 0x00000001819b0fd8 libsystem_kernel.dylib`mach_msg_trap + 8</span><br><span class="line">libsystem_kernel.dylib`mach_msg_trap:</span><br><span class="line">-&gt;  0x1819b0fd8 &lt;+8&gt;: ret</span><br><span class="line"></span><br><span class="line">libsystem_kernel.dylib`mach_msg_overwrite_trap:</span><br><span class="line">    0x1819b0fdc &lt;+0&gt;: mov    x16, #-0x20</span><br><span class="line">    0x1819b0fe0 &lt;+4&gt;: svc    #0x80</span><br><span class="line">    0x1819b0fe4 &lt;+8&gt;: ret</span><br><span class="line">Target 0: (WeChat) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><ul><li>此时微信的进程已经停止了，并且正在等待我们的命令。我们先输入<strong>c</strong>让进程继续。(这是LLDB的基础命令，c代表continue)</li></ul><h4 id="2-5-打开目标界面，查找目标对象"><a href="#2-5-打开目标界面，查找目标对象" class="headerlink" title="2.5 打开目标界面，查找目标对象"></a>2.5 打开目标界面，查找目标对象</h4><ul><li><p>上面我们已经将LLDB挂到微信上面了，接下来我们先搜索一个手机号，然后去到添加联系人界面。<br><img src="media/15537420649103/15537443880035.jpg" alt="-w160"></p></li><li><p>我们搜索到联系人之后，我们需要找到当前界面的控制器。下面是关键命令:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(lldb) process interrupt</span><br><span class="line">(lldb) po [[[UIApplication sharedApplication]keyWindow]recursiveDescription]</span><br><span class="line">&lt;MMUILongPressImageView: 0x140982bf0; baseClass = UIImageView; frame = (3 3; 64 64); opaque = NO; layer = &lt;CALayer: 0x14338b660&gt;&gt;</span><br><span class="line">&lt;UIImageView: 0x14337eb10; frame = (0 0; 70 70); hidden = YES; userInteractionEnabled = NO; layer = &lt;CALayer: 0x14337ecc0&gt;&gt;</span><br><span class="line">&lt;MMCPLabel: 0x1433cf8f0; baseClass = UILabel; frame = (107 0; 88 27); text = &apos;默默等待&apos;; tag = 90220; gestureRecognizers = &lt;NSArray: 0x143517010&gt;; layer = &lt;_UILabelLayer: 0x1402ac6c0&gt;&gt;</span><br><span class="line">&lt;_UILabelContentLayer: 0x143398ee0&gt; (layer)</span><br><span class="line">&lt;UIView: 0x1433e1600; frame = (304 1.5; 0 24); layer = &lt;CALayer: 0x1433e1520&gt;&gt;</span><br><span class="line">(lldb) po [0x1433cf8f0 nextResponder]</span><br><span class="line">&lt;MMUIButton: 0x143581b10; baseClass = UIButton; frame = (0 0; 320 77); opaque = NO; tag = 90221; layer = &lt;CALayer: 0x14354ff50&gt;&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [0x143581b10 nextResponder]</span><br><span class="line">&lt;UIView: 0x140982a80; frame = (0 0; 320 105); layer = &lt;CALayer: 0x143541d80&gt;&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [0x140982a80 nextResponder]</span><br><span class="line">&lt;WCStoryTableView: 0x13f5f7a00; baseClass = UITableView; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x143510ee0&gt;; layer = &lt;CALayer: 0x1433f3570&gt;; contentOffset: &#123;0, -64&#125;; contentSize: &#123;320, 504&#125;&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [0x13f5f7a00 nextResponder];</span><br><span class="line">&lt;MMUIButton: 0x1426b1960; baseClass = UIButton; frame = (0 0; 320 1136); opaque = NO; autoresize = W; gestureRecognizers = &lt;NSArray: 0x14315c0c0&gt;; layer = &lt;CALayer: 0x14093f9a0&gt;&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [0x1426b1960 nextResponder]</span><br><span class="line">&lt;UIView: 0x14354d550; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x13ef32f00&gt;&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [0x1426b1960 nextResponder];</span><br><span class="line">&lt;UIView: 0x14354d550; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x13ef32f00&gt;&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [0x14354d550 nextResponder];</span><br><span class="line">&lt;ContactInfoViewController: 0x13fc0c400&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>process interrupt</strong>: 中断当前进程<br><strong>[[[UIApplication sharedApplication]keyWindow]recursiveDescription]</strong> : 答应当前界面的信息，此时会显示所有的界面的元素。</p></blockquote><p>此时我们可以根据名字“默默等待”来找到到对应的Label，然后通过这个label的找到对应ViewController。使用nextResponder一级一级的找到对应的ViewController。通过上面的信息我们可以看到当前的ViewController是ContactInfoViewController。</p><h4 id="2-6-打印对象属性。"><a href="#2-6-打印对象属性。" class="headerlink" title="2.6 打印对象属性。"></a>2.6 打印对象属性。</h4><ul><li>打印ContactInfoViewController的所有成员变量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [0x13fc0c400 _ivarDescription]</span><br><span class="line">&lt;ContactInfoViewController: 0x13fc0c400&gt;:</span><br><span class="line">in ContactInfoViewController:</span><br><span class="line">m_uiVerify (unsigned int): 0</span><br><span class="line">m_contact (CContact*): &lt;CSearchedContact: 0x1433b0550&gt;</span><br><span class="line">m_chatContact (CContact*): nil</span><br><span class="line">m_delegate (&lt;contactInfoDelegate&gt;*): nil</span><br><span class="line">m_InfoDelegate (&lt;ContactInfoViewControllerDelegate&gt;*): nil</span><br><span class="line">m_oContactInfoAssist (CBaseContactInfoAssist*): &lt;WeixinContactInfoAssist: 0x14331a240&gt;</span><br><span class="line">m_contactVerifyLogic (CContactVerifyLogic*): nil</span><br><span class="line">m_nsLocation (NSString*): nil</span><br><span class="line">m_bPopToRootWhenDelete (BOOL): &lt;00&gt;</span><br><span class="line">m_uiFromScene (unsigned int): 6</span><br><span class="line">m_wcOperateMode (int): 0</span><br><span class="line">m_popToViewControllerClassWhenDelete (Class): (null)</span><br><span class="line">m_searchScene (int): 0</span><br><span class="line">m_userData (id): nil</span><br><span class="line">m_clickHelper (FavClickStreamHelper*): &lt;FavClickStreamHelper: 0x14260e330&gt;</span><br><span class="line">m_CurrentWidth (double): 320</span><br><span class="line">m_forwardLogic (ForwardMessageLogicController*): nil</span><br><span class="line">_startTime (unsigned int): 1553744360</span><br><span class="line">m_sendVerifylogicVC (SendVerifyMsgLogicController*): nil</span><br><span class="line">_isFullScreenShowStory (BOOL): &lt;00&gt;</span><br><span class="line">_hasStoryData (BOOL): &lt;00&gt;</span><br><span class="line">_canShowStoryView (BOOL): &lt;01&gt;</span><br><span class="line">_isShowingStoryPreview (BOOL): &lt;00&gt;</span><br><span class="line">m_uiAddFriendStatScene (int): 0</span><br><span class="line">_m_qrCodeAddFriendScene (int): 0</span><br><span class="line">_searchFromIndex (unsigned int): 0</span><br><span class="line">_favId (unsigned int): 0</span><br><span class="line">_verifyUserInfoList (NSMutableDictionary*): nil</span><br><span class="line">_searchId (NSString*): nil</span><br><span class="line">_searchKeyword (NSString*): nil</span><br><span class="line">........</span><br></pre></td></tr></table></figure><blockquote><p>这个时候我们可以看到在最上面有一个<code>m_contact (CContact*): &lt;CSearchedContact: 0x1433b0550&gt;</code>我猜测这个应该是我们搜索出来的微信号信息的对象，我们可以试着打印一下这个对象看看。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [0x1433b0550 _ivarDescription]</span><br><span class="line">&lt;CSearchedContact: 0x1433b0550&gt;:</span><br><span class="line">in CSearchedContact:</span><br><span class="line">matchType (unsigned int): 2</span><br><span class="line">searchString (NSString*): @&quot;18575784615&quot;&lt;__NSCFString: 0x1435838e0&gt;</span><br><span class="line">in CContact:</span><br><span class="line">m_uiChatRoomStatus (unsigned int): 0</span><br><span class="line">m_nsChatRoomMemList (NSString*): nil</span><br><span class="line">m_nsChatRoomAdminList (NSString*): nil</span><br><span class="line">m_uiChatRoomAccessType (unsigned int): 0</span><br><span class="line">m_uiChatRoomMaxCount (unsigned int): 0</span><br><span class="line">m_uiChatRoomVersion (unsigned int): 0</span><br><span class="line">m_ChatRoomDetail (ChatRoomDetail*): nil</span><br><span class="line">m_nsChatRoomData (NSString*): nil</span><br><span class="line">m_ChatRoomData (ChatRoomData*): nil</span><br><span class="line">m_nsCountry (NSString*): @&quot;CN&quot;&lt;NSTaggedPointerString: 0xa00000000004e432&gt;</span><br><span class="line">m_nsProvince (NSString*): @&quot;Anhui&quot;&lt;NSTaggedPointerString: 0xa00006975686e415&gt;</span><br><span class="line">m_nsCity (NSString*): @&quot;Fuyang&quot;&lt;NSTaggedPointerString: 0xa00676e617975466&gt;</span><br><span class="line">m_nsSignature (NSString*): @&quot;&quot;&lt;__NSCFConstantString: 0x10adaff28&gt;</span><br><span class="line">m_uiCertificationFlag (unsigned int): 0</span><br><span class="line">m_nsCertificationInfo (NSString*): @&quot;&quot;&lt;__NSCFConstantString: 0x10adaff28&gt;</span><br><span class="line">m_nsOwner (NSString*): nil</span><br><span class="line">m_nsFBNickName (NSString*): nil</span><br><span class="line">m_nsFBID (NSString*): nil</span><br><span class="line">m_uiNeedUpdate (unsigned int): 0</span><br><span class="line">m_nsWCBGImgObjectID (NSString*): @&quot;0&quot;&lt;NSTaggedPointerString: 0xa000000000000301&gt;</span><br><span class="line">m_iWCFlag (int): 0</span><br><span class="line">m_pcWCBGImgID (NSString*): @&quot;&quot;&lt;__NSCFConstantString: 0x10adaff28&gt;</span><br><span class="line">m_nsExternalInfo (NSString*): @&quot;&quot;&lt;__NSCFConstantString: 0x10adaff28&gt;</span><br><span class="line">m_nsBrandSubscriptConfigUrl (NSString*): @&quot;&quot;&lt;__NSCFConstantString: 0x10adaff28&gt;</span><br><span class="line">m_uiBrandSubscriptionSettings (unsigned int): 0</span><br><span class="line">m_subBrandInfo (SubscriptBrandInfo*): &lt;SubscriptBrandInfo: 0x140936fe0&gt;</span><br><span class="line">m_nsBrandIconUrl (NSString*): @&quot;&quot;&lt;__NSCFConstantString: 0x10adaff28&gt;</span><br><span class="line">m_isExtInfoValid (BOOL): &lt;01&gt;</span><br><span class="line">externalInfoJSONCache (NSDictionary*): nil</span><br><span class="line">m_isShowRedDot (BOOL): &lt;00&gt;</span><br><span class="line">m_nsMobileHash (NSString*): nil</span><br><span class="line">m_nsMobileFullHash (NSString*): nil</span><br><span class="line">m_nsLinkedInID (NSString*): nil</span><br><span class="line">m_nsLinkedInName (NSString*): nil</span><br><span class="line">m_nsLinkedInPublicUrl (NSString*): nil</span><br><span class="line">m_uiDeleteFlag (unsigned int): 0</span><br><span class="line">m_nsDescription (NSString*): nil</span><br><span class="line">m_nsCardUrl (NSString*): nil</span><br><span class="line">m_nsWorkID (NSString*): nil</span><br><span class="line">m_nsLabelIDList (NSString*): nil</span><br><span class="line">m_arrPhoneItem (NSArray*): &lt;__NSArrayM: 0x1433d60a0&gt;</span><br><span class="line">m_lockForChatRoomData (NSRecursiveLock*): &lt;NSRecursiveLock: 0x1406dada0&gt;</span><br><span class="line">_appBrandInfo (CAppBrandInfo*): nil</span><br><span class="line">_m_bFromNewDB (BOOL): &lt;01&gt;</span><br><span class="line">_m_hasNewBizMsg (BOOL): &lt;00&gt;</span><br><span class="line">_m_uiLastUpdate (unsigned int): 0</span><br><span class="line">_m_uiMetaFlag (unsigned int): 0</span><br><span class="line">_m_uiDebugModeType (unsigned int): 0</span><br><span class="line">_m_uiWxAppOpt (unsigned int): 0</span><br><span class="line">_uiLastUpdateAppVersionInfoTime (unsigned int): 0</span><br><span class="line">openIMAppid (NSString*): nil</span><br><span class="line">openIMInfo (COpenIMInfo*): nil</span><br><span class="line">_m_dicWeiDianInfo (NSDictionary*): nil</span><br><span class="line">_m_nsWeiDianInfo (NSString*): nil</span><br><span class="line">in CBaseContact:</span><br><span class="line">m_nsUsrName (NSString*): @&quot;v1_81f423f663f69d690124bb98c81aade8c47642dfb41842bb2bdfd85907d912df04b2f31b8f910255577a8cde8dc835d4@stranger&quot;&lt;__NSCFString: 0x1434c5630&gt;</span><br><span class="line">m_nsEncodeUserName (NSString*): nil</span><br><span class="line">m_nsAliasName (NSString*): @&quot;yao1054057455&quot;&lt;__NSCFString: 0x1432f4c60&gt;</span><br><span class="line">m_uiConType (unsigned int): 0</span><br><span class="line">m_nsNickName (NSString*): @&quot;默默等待&quot;&lt;__NSCFString: 0x1434b18c0&gt;</span><br><span class="line">m_nsFullPY (NSString*): @&quot;wxid0rxnvbwkf1n512132&quot;&lt;__NSCFString: 0x14324d5f0&gt;</span><br><span class="line">m_nsShortPY (NSString*): @&quot;mmdd&quot;&lt;__NSCFString: 0x143526120&gt;</span><br><span class="line">m_nsRemark (NSString*): nil</span><br><span class="line">m_nsRemarkPYShort (NSString*): nil</span><br><span class="line">m_nsRemarkPYFull (NSString*): nil</span><br><span class="line">m_nsDisplayNamePY (NSString*): nil</span><br><span class="line">m_uiSex (unsigned int): 2</span><br><span class="line">m_uiType (unsigned int): 0</span><br><span class="line">m_uiChatState (unsigned int): 0</span><br><span class="line">m_dtUsrImg (NSData*): nil</span><br><span class="line">m_nsImgStatus (NSString*): @&quot;IMG_HAS&quot;&lt;__NSCFConstantString: 0x104085c48&gt;</span><br><span class="line">m_nsHDImgStatus (NSString*): nil</span><br><span class="line">m_nsHeadImgUrl (NSString*): @&quot;http://wx.qlogo.cn/mmhead/ver_1/x0enJ9WJoJ9lSdibxAk8ukuriaLjBphAFdnAfib9pLM6fZXJclib1uyenjSr3fUdVSBOAfdlAAyrs8JhSbbOatpRUTgeqO4ReTkNG9ahRpJJHms/132&quot;&lt;__NSCFString: 0x1426bc500&gt;</span><br><span class="line">m_nsHeadHDImgUrl (NSString*): @&quot;http://wx.qlogo.cn/mmhead/ver_1/x0enJ9WJoJ9lSdibxAk8ukuriaLjBphAFdnAfib9pLM6fZXJclib1uyenjSr3fUdVSBOAfdlAAyrs8JhSbbOatpRUTgeqO4ReTkNG9ahRpJJHms/0&quot;&lt;__NSCFString: 0x14354d710&gt;</span><br><span class="line">m_nsHeadHDMd5 (NSString*): nil</span><br><span class="line">m_nsDraft (NSString*): nil</span><br><span class="line">m_uiDraftTime (unsigned int): 0</span><br><span class="line">m_nsAtUserList (NSString*): nil</span><br><span class="line">m_uiQQUin (unsigned int): 0</span><br><span class="line">m_nsMobileIdentify (NSString*): nil</span><br><span class="line">m_uiFriendScene (unsigned int): 15</span><br><span class="line">m_uiImgKey (unsigned int): 0</span><br><span class="line">m_uiExtKey (unsigned int): 0</span><br><span class="line">m_uiImgKeyAtLastGet (unsigned int): 0</span><br><span class="line">m_uiExtKeyAtLastGet (unsigned int): 0</span><br><span class="line">m_hasDetectPlugin (BOOL): &lt;01&gt;</span><br><span class="line">m_isPlugin (BOOL): &lt;00&gt;</span><br><span class="line">m_hasDetectSelf (BOOL): &lt;01&gt;</span><br><span class="line">m_isSelf (BOOL): &lt;00&gt;</span><br><span class="line">m_nsAntispamTicket (NSString*): @&quot;v2_2e4d1f9deb2d50cec867afc7481db2adc7bf821f79562b66d83225ae2338039a7abd1160dcc4a7122640fb42e0784801@stranger&quot;&lt;__NSCFString: 0x143539fe0&gt;</span><br><span class="line">_externalInfoJSONCache (NSDictionary*): nil</span><br><span class="line">in NSObject:</span><br><span class="line">isa (Class): CSearchedContact (isa, 0x81a104c3d59d)</span><br></pre></td></tr></table></figure><p>结果没有让我们失望，到这里已经看到了m_nsFullPY这个属性包含的就是wxid。这次逆向很简单，都没有用到静态分析看汇编代码等方法，直接就能实现我们想做的。</p><p>最后有个小tips，一般通过wxid是加不了好友的，但是在wxid前面加几个汉字可以搜索到好友哦。</p>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS中常见的八种锁</title>
      <link href="/2018/10/31/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%AB%E7%A7%8D%E9%94%81/"/>
      <url>/2018/10/31/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%AB%E7%A7%8D%E9%94%81/</url>
      <content type="html"><![CDATA[<h2 id="为什么需要锁"><a href="#为什么需要锁" class="headerlink" title="为什么需要锁"></a>为什么需要锁</h2><p>在iOS中相信大家都用过多线程，多线程带来的好处显而易见，但是我们需要关注一下多线程有可能带来的问题。假设我们有一个这样的场景，我们有两条线程A和线程B，A线程做的事情是修改这个对象之后读取这个对象的数据，这个时候B线程可能也在修改这个对象。这个时候有两种情况（取决于B线程修改对象的时机）：</p><blockquote><ol><li>正常的情况，A线程修改对象以及读取对象之后，B线程才开始修改这个对象。</li><li>异常的情况，A线程修改对象之后，B线程立刻修改了这个帝乡，然后A线程读取对象。这个时候A线程读取到的数据就出错了。</li></ol></blockquote><p>这就是我们常说的Data race，当两个线程同时在访问修改同一个块内存的时候，就有可能得到意想不到的结果。</p><a id="more"></a><p>基于上面的前提，我们在出现了用<code>锁</code>来解决问题的方法。下面我们就来说说iOS中的锁。</p><p>在ibireme写的<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的OSSpinLock</a>中给出了常用的锁的性能如下所示：</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15407991692950.png" alt=""></p><p>在解释下面的锁之前，我们先说说两种类型的锁，一种是自旋锁，一种是互斥锁。</p><h2 id="按照功能来区分锁"><a href="#按照功能来区分锁" class="headerlink" title="按照功能来区分锁"></a>按照功能来区分锁</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><blockquote><p><code>互斥锁</code>是为了保护一个临界区或者资源不能同时被多个小城访问。当临界区加上互斥锁以后，其他的调用方不能获得锁，只有当互斥锁的持有方释放锁之后其他调用方才能获得锁。<br>如果调用方在获得锁的时候发现<code>互斥锁</code>已经被其他方持有，那么该调用方只能进入睡眠状态，这样不会占用CPU资源。但是会有时间的消耗，系统的运行时基于CPU时间调度的，每次线程可能有100ms的运行时间，频繁的CPU切换也会消耗一定的时间。</p></blockquote><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><blockquote><p><code>自旋锁</code>和互斥锁相似，但是自旋锁不会引起休眠,当自旋锁被别的线程锁定的时候，那么调用方会一直处于等待的状态，用一种生活化的例子来说就像是上厕所，当你要上厕所发现里面已经有人的时候，你就会一直等在外面，直到他出来你就立刻抢占厕所。<br>由于调用方会一直循环看该自旋锁的的保持者是否已经释放了资源，所以总的效率来说比互斥锁高。但是自旋锁只用于短时间的资源访问，如果不能短时间内获得锁，就会一直占用着CPU，造成效率低下。</p></blockquote><h2 id="常见的锁的类型"><a href="#常见的锁的类型" class="headerlink" title="常见的锁的类型"></a>常见的锁的类型</h2><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><p><code>OSSpinLock</code>是自旋锁，也正是由于它是自旋锁，所以容易发生优先级反转的问题。在ibireme的文章中已经写到，当一个低优先级线程获得锁的时候，如果此时一个高优先级的系统到来，那么会进入忙等状态，不会进入睡眠，此时会一直占用着系统CPU时间，导致低优先级的无法拿到CPU时间片，从而无法完成任务也无法释放锁。除非能保证访问锁的线程全部处于同一优先级，否则系统所有的自旋锁都会出现优先级反转的问题。现在苹果的<code>OSSpinLock</code>已经被替换成<code>os_unfair_lock</code><br><code>typedef int32_t OSSpinLock OSSPINLOCK_DEPRECATED_REPLACE_WITH(os_unfair_lock);</code></p><h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><p><code>dispatch_semaphore</code>主要提供了三个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_create(long value);//创造信号量</span><br><span class="line">dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout); //等待信号</span><br><span class="line">dispatch_semaphore_signal(dispatch_semaphore_t dsema);//发送信号</span><br></pre></td></tr></table></figure><p><code>dispatch_semaphore</code>是GCD用来同步的一种方式，<code>dispatch_semephore_create</code>方法用户创建一个<code>dispatch_semephore_t</code>类型的信号量，初始的参数必须大于0，该参数用来表示该信号量有多少个信号，简单的说也就是同事允许多少个线程访问。<br><code>dispatch_semaphore_wait()</code>方法是等待一个信号量，该方法会判断signal的信号值是否大于0，如果大于0则不会阻塞线程，消耗点一个信号值，执行后续任务。如果信号值等于0那么就和NSCondition一样，阻塞当前线程进入等待状态，如果等待时间未超过timeout并且<code>dispatch_semaphore_signal</code>释放了了一个信号值，那么就会消耗掉一个信号值并且向下执行。如果期间一直不能获得信号量并且超过超时时间，那么就会自动执行后续语句。</p><h3 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread-mutex"></a>pthread-mutex</h3><blockquote><p><code>pthread-mutex</code>是互斥锁，互斥锁与信号量的机制非常相似，不会处于忙等状态，而是会阻塞线程并休眠。</p></blockquote><p><code>pthread-mutex</code>提供了几个常用的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_init(pthread_mutex_t * __restrict, const pthread_mutexattr_t * __restrict);//初始化锁</span><br><span class="line">int pthread_mutex_lock(pthread_mutex_t *); //加锁</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t *); //解锁</span><br></pre></td></tr></table></figure><p><code>pthread_mutex_init</code>方法用来初始化一个锁，需要传入一个pthread_mutex_t的对象，并且需要设置互斥锁的类型。互斥锁有四种类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PTHREAD_MUTEX_NORMAL : 默认值普通锁，当一个线程加锁以后，其他线程进入按照优先顺序进入等待队列，并且解锁的时候按照先入先出的方式获得锁。</span><br><span class="line">PTHREAD_MUTEX_ERRORCHECK : 检错锁，当同一个线程获得同一个锁的时候，则返回EDEADLK，否则与普通锁处理一样。</span><br><span class="line">PTHREAD_MUTEX_RECURSIVE : 递归锁。这里有别于上面的检错锁，同一个线程可以递归获得锁，但是加锁和解锁必须要一一对应。</span><br><span class="line">PTHREAD_MUTEX_DEFAULT : 适应锁，等待解锁之后重新竞争，没有等待队列。</span><br></pre></td></tr></table></figure><h3 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h3><p><code>NSLock</code>遵循<code>NSLocking</code>协议，同时也是互斥锁，提供了lock和unlock方法来进行加锁和解锁。<br><code>NSLock</code>内部是封装了<code>pthread_mutext</code>，类型是<code>PTHREAD_MUTEXT_ERRORCHECK</code>，它会损失一定的性能换来错误提示。</p><h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h3><p><code>NSCondition</code>是封装了一个互斥锁和信号量，它把前者的lock以及后者的wait/signal统一到<code>NSCondition</code>对象中，是基于条件变量<code>pthread_cond_t</code>来实现的，和信号量相似，如果当前线程不满足条件，那么就会进入睡眠状态，等待其他线程释放锁或者释放信号之后，就会唤醒线程。类似于生产者和消费者模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">NSCondition *lock = [[NSCondition alloc] init];</span><br><span class="line">    NSMutableArray *array = [[NSMutableArray alloc] init];</span><br><span class="line">    //消费者</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        while (!array.count) &#123;</span><br><span class="line">            [lock wait];</span><br><span class="line">        &#125;</span><br><span class="line">        [array removeAllObjects];</span><br><span class="line">        NSLog(@&quot;array removeAllObjects&quot;);</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //生产者</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        sleep(1);//以保证让线程2的代码后执行</span><br><span class="line">        [lock lock];</span><br><span class="line">        [array addObject:@1];</span><br><span class="line">        NSLog(@&quot;array addObject:@1&quot;);</span><br><span class="line">        [lock signal];</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h3><blockquote><p><code>NSRecursiveLock</code>实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中</p></blockquote><p><code>NSRecursiveLock</code>内部是通过pthread_mutex_lock来实现的，在内部会判断锁的类型，如果是递归锁，就允许递归调用，内部仅仅是将计数器+1。当调用unlock的时候，就将计数器减1。NSRecursiveLock内部使用的pthread_mutex_t的类型是<code>PTHREAD_MUTEXT_RECURSIVE</code></p><h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><p><code>NSConditonLock</code> 是借助NSCondition，本质上是生产者-消费者模式，<code>NSConditonLock</code>内部持有了一个<code>NSCondition</code>对象和<code>_condition_value</code>属性，当调用<code>- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;</code>初始化的时候会传入一个condition参数，该参数会赋值<code>_condition_value</code>属性。</p><ul><li><p>在<code>NSConditionLock</code>r中，对应的消费者就是<code>- (void)lockWhenCondition:(NSInteger)condition;</code>方法，首先会调用[condition lock]，然后开始进入阻塞状态，如果condition=_condition_value，那么就会休眠，直到代码调用<code>- (void)unlockWithCondition:(NSInteger)condition;</code>才会唤起</p></li><li><p><code>- (void)unlockWithCondition:(NSInteger)condition;</code>就是对应的生产者方法，内部会设置condition=_contion_value，并且发送广播告诉所有的消费者，表示生产完成，然后调用[condition unlock]释放锁。</p></li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><p>@synchronized是OC层面上的锁，是所有的锁之中性能最差的。<br>@synchronized后面紧跟一个OC对象，实际上是将这个对象当做锁来使用。这是通过一个哈希表来实现的，OC在底层维护了一个互斥锁的数组，通过对象的哈希值去得到对象的互斥锁。<br>具体的实现原理可以参考萧玉大神的这篇文章: <a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">关于 @synchronized，这儿比你想知道的还要多</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的分析我们知道锁的性能由高到低分别是<br><code>OSSpinLock(已经不推荐使用)</code>-&gt;<code>dispatch_semaphore</code>-&gt;<code>pthread_mutext</code>-&gt;<code>NSLock</code>-&gt;<code>NSCondition</code>-&gt;<code>NSRecursiveLock</code>-&gt;<code>NSConditonLock</code>-&gt;<code>@synchronized</code></p><p>我们再来梳理一下它们的关系：</p><ol><li><code>dipatch_semaphore</code>是GCD同步的一种方式，通过dispatch_semaphore_t信号量来实现。<br>2.<code>pthread_mutex</code>是互斥锁，提供了四种不同类型，不会像自旋锁一样忙等，而是会进入休眠等待。<br>3.<code>NSLock</code>是封装了<code>prthread_mutex</code>，锁的类型是<code>PTHREAD_MUTEX_ERRORCHECK</code>，也就是当同一个线程获得同一个锁的时候，会返回错误。<br>4.<code>NSCondition</code>是基于条件变量<code>pthread_cond_t</code>实现的，和信号量相似，当不满足条件的时候就会进入休眠等待，知道condition对象发出signal信号，才会被唤醒执行。<br>5.<code>NSRecursiveLock</code>是递归锁，同样是封装了<code>pthread_mutex</code>来实现，但是锁的类型是<code>PTHREAD_MUTEX_RECURSIVE</code>，允许统一递归获得锁，但是要注意加锁和解锁要一一对应。<br>6.<code>NSConditionLock</code>是基于<code>NSCondition</code>实现的，同样也是生产者和消费者模式。<br>7.<code>@synchronized</code>是OC层面的锁，传入一个OC对象，通过对象的哈希值来作为标识符得到互斥锁，存入到一个数组里面。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/57f6e9f85bbb50005b126e5f" target="_blank" rel="noopener">深入理解iOS中的锁</a><br><a href="https://www.jianshu.com/p/938d68ed832c" target="_blank" rel="noopener">iOS中保证线程安全的几种方式与性能对比</a><br><a href="https://www.jianshu.com/p/ddbe44064ca4" target="_blank" rel="noopener">iOS 常见知识点（三）：Lock</a><br><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的OSSpinLock</a></p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS动手实现KVO</title>
      <link href="/2018/10/10/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0KVO/"/>
      <url>/2018/10/10/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0KVO/</url>
      <content type="html"><![CDATA[<h2 id="什么是KVO"><a href="#什么是KVO" class="headerlink" title="什么是KVO"></a>什么是KVO</h2><blockquote><p>KVO(key-value observing)是观察者模式的一种实现，通过监听对象的某一个属性，当属性的值发生改变的时候，监听者会获得通知。</p></blockquote><h2 id="KVO的使用以及缺点"><a href="#KVO的使用以及缺点" class="headerlink" title="KVO的使用以及缺点"></a>KVO的使用以及缺点</h2><p>我们来看一下是如何使用系统的KVO的。<br>系统提供了三个重要的方法，一个是设置监听，一个是监听回调，另外一个是移除监听。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0));</span><br></pre></td></tr></table></figure><p>怎么使用我就不说了，我来说说系统的KVO的缺点。</p><ol><li>当一个观察者监听了很多对象的时候，所有的回调方法都在一个地方处理，这样就要做很多的判断来根据不同的对象不同的属性来做相应的响应。</li><li>没有提供<code>@selector</code>的形式以及<code>block</code>的形式，而且还要处理父类的情况，如果父类同样也监听了对象的同一属性，你不知道父类是否对这个消息感兴趣，还要根据context来处理，这样显得很混乱。</li></ol><h2 id="KVO的实现"><a href="#KVO的实现" class="headerlink" title="KVO的实现"></a>KVO的实现</h2><p>基于以上的缺点考虑，我们想自己实现一个KVO，并且以block的形式进行回调，那么我们首先要知道KVO的实现原理。</p><p>在苹果的开发者网站上面有透露了KVO的实现，虽然没有透露内部的细节，但是我们也可以知道一个大概。</p><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling.<br>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.<br>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.<br>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p></blockquote><p>上面的话翻译过来就是KVO的实现是基于一个叫做isa-swizzling的技术，也就是改变isa的指针，我们知道每个对象都有一个isa指针指向他的类，后面调用方法的时候根据isa指针找到对应的类然后调用相应的方法。当一个对象被注册监听的时候，系统会创建一个该对象所属的类的子类，然后修改子类的setter方法，该setter方法里面会调用父类的setter实现，然后实现通知告诉观察者。最后改变该对象的isa指针，指向我们自定义的kvo类。最后当我们给一个属性赋值的时候，其实调用的setter方法应不是原来的类的setter，而是系统创建的kvo子类。</p><p>基于以上的原理，我们来开始动手实现一个通过block回调的kvo</p><h2 id="实现带有block的KVO"><a href="#实现带有block的KVO" class="headerlink" title="实现带有block的KVO"></a>实现带有block的KVO</h2><p>我们创建一个NSObject的category，然后向外面提供两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^lmObserveBlock)(id observer, NSString *key ,id oldValue, id newValue);</span><br><span class="line"></span><br><span class="line">@interface NSObject (LMKVO)</span><br><span class="line">- (void)lm_AddObserver:(id)observer</span><br><span class="line">                  key:(NSString *)key</span><br><span class="line">         observeBlock:(lmObserveBlock)block;</span><br><span class="line"></span><br><span class="line">- (void)lm_removeObserver:(id)observer</span><br><span class="line">                   key:(NSString*)key;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>我们首先来看看添加监听的方法：</p><p>下面的代码主要做了下面四件事：</p><blockquote><ol><li>判断对象的类是否存在setter方法，不存在的话则直接返回</li><li>判断对象的isa指针指向的类是否是kvo类，不是的话就通过objc_allocateClassPair()以及objc_registerClassPair()两个主要方法来注册一个kvo类，修改对象的isa指针。</li><li>判断kvo类是否已经存在setter方法，不存在的话则创建setter方法.</li><li>通过obj_getAssociatedObject以及objc_setAssociatedObject来动态给分类增加一个array的属性，通过该属性保存所有的obverve信息，以便后面属性值发生改变的时候调用。</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)lm_AddObserver:(id)observer</span><br><span class="line">                   key:(NSString *)key</span><br><span class="line">          observeBlock:(lmObserveBlock)block&#123;</span><br><span class="line">    SEL selForSetter = NSSelectorFromString([self setterName:key]);</span><br><span class="line">    Method setterMethod = class_getInstanceMethod([self class], selForSetter);</span><br><span class="line">    //lei判断如果父类不存在setter方法，那么直接返回</span><br><span class="line">    if (!setterMethod) &#123;</span><br><span class="line">        NSLog(@&quot;父类方法不存在setter&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断对象的isa指针指向的类是否是kvo，如果不是则创建该类的子类，并且将对象的isa指向该子类。</span><br><span class="line">    Class class = object_getClass(self);</span><br><span class="line">    NSString *className = NSStringFromClass(class);</span><br><span class="line">    </span><br><span class="line">    if (![className hasPrefix:LMKVOPREFIX]) &#123;</span><br><span class="line">        //创建一个新的类并且修改isa指针</span><br><span class="line">        class = [self makeNewClassWithClassName:className];</span><br><span class="line">        object_setClass(self, class);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //判断新创建的类是否已经实现了setter方法，如果没有则创建新的setter方法</span><br><span class="line">    if (![self hasSelector:selForSetter]) &#123;</span><br><span class="line">        const char *types = method_getTypeEncoding(setterMethod);</span><br><span class="line">        class_addMethod(class, selForSetter, (IMP)kvo_setter, types);</span><br><span class="line">    &#125;</span><br><span class="line">    //保存observerInfo</span><br><span class="line">    LMObserverInfo *info = [[LMObserverInfo alloc] initWithObserver:observer key:key block:block];</span><br><span class="line">    NSMutableArray *observers = objc_getAssociatedObject(self,(__bridge const void * _Nonnull)(LMKVOAssociatedObservers));</span><br><span class="line">    if (!observers) &#123;</span><br><span class="line">        observers = [NSMutableArray array];</span><br><span class="line">        objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(LMKVOAssociatedObservers), observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    if ([self containsSameObserver:observer key:key]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [observers addObject:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来看一下移除监听的方法实现：</p><p>这里就是在我们之前保存的数组中找到对应的observe和key，然后移除相应的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)lm_removeObserver:(id)observer</span><br><span class="line">                   key:(NSString*)key&#123;</span><br><span class="line">    NSMutableArray *observers = objc_getAssociatedObject(self,(__bridge const void * _Nonnull)(LMKVOAssociatedObservers));</span><br><span class="line">    LMObserverInfo *specialInfo = [self containsSameObserver:observer key:key];</span><br><span class="line">    if (specialInfo) &#123;</span><br><span class="line">        [observers removeObject:specialInfo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的逻辑很简单，看看demo就一目了然了。<br>这里是[demo][<a href="https://github.com/codemonkeybulucck/LMKVOTool]" target="_blank" rel="noopener">https://github.com/codemonkeybulucck/LMKVOTool]</a></p><p>参考：<a href="https://github.com/okcomp/ImplementKVO" target="_blank" rel="noopener">ImplementKVO</a></p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kvo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>atomic是不是线程安全的</title>
      <link href="/2018/09/30/iOS%20%E5%BC%80%E5%8F%91/atomic%E6%98%AF%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84/"/>
      <url>/2018/09/30/iOS%20%E5%BC%80%E5%8F%91/atomic%E6%98%AF%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84/</url>
      <content type="html"><![CDATA[<h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><p>我们先来看看什么叫做线程安全。</p><blockquote><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。</p></blockquote><a id="more"></a><h2 id="atomic不安全？"><a href="#atomic不安全？" class="headerlink" title="atomic不安全？"></a>atomic不安全？</h2><p>OK，接下来我们来看看一段经典的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic,copy) NSString *name;</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        @synchronized(self)&#123;</span><br><span class="line">            for (int i = 0; i&lt;100; i++) &#123;</span><br><span class="line">                self.name = @&quot;lemon&quot;;</span><br><span class="line">                NSLog(@&quot;线程A ： %@&quot;,self.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        @synchronized(self)&#123;</span><br><span class="line">            for (int i = 0; i&lt;100; i++) &#123;</span><br><span class="line">                self.name = @&quot;well&quot;;</span><br><span class="line">                NSLog(@&quot;线程B ： %@&quot;,self.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>我们定义了一个atomic的name属性，然后我们在两个线程里面分别修改了这个属性的值，按照上面的定义，我们的设想应该是：线程A后面的一定是lemon，线程B后面的一定是well，但是结果是线程A后面跟着的是lemon或者well，线程B打印的是lemon或者well。也就是说取值是不确定的，基于上面的结果，大多数人认为<strong>atomic是不安全的</strong>。But这不是这篇文章的结论。</p><h2 id="atomic-是安全的"><a href="#atomic-是安全的" class="headerlink" title="atomic 是安全的"></a>atomic 是安全的</h2><p>我们来关注一下atomic，atomic是原子属性，什么是原子属性呢？</p><p><code>狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完（理论上拥有CPU时间片无限长）。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现，但一句高级语言的代码却不是原子的，因为它最终是由多条汇编语言完成，CPU在进行时间片切换时，大多都会在某条代码的执行过程中。但在多核处理器下，则需要硬件支持</code></p><p>在<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-723</a>中我们可以看到atomic的实现，利用了TLS(Thread-Local Storage)局部线程存储实现了原子属性，这里用了最重要的两个函数:<code>pthread_setspecific</code>以及<code>pthread_getspecific</code>。也就是说atomic是安全的。</p><p>这里就有矛盾了，为什么上面说atomic是线程不安全的，这里又说是安全的，Excuse me?</p><p>或许我们换一种说法，atomic是线程安全的，但是不能保证指向的对象是线程安全的。怎么解释这句话呢？</p><p>也就是大家常说的，atomic只对getter和setter加锁，而没有办法保证对象的数据完整性。</p><blockquote><p>我们要明白一个概念，当我们访问name的时候，其实这里我们访问的有可能是name本身，也有可能是name指向的内存地址。<br>比如 <code>self.name = @&quot;lemon&quot;</code>是在访问指针本身，这个是受atomic保护的。<br>而<code>[self.name rangOfString:@&quot;lemon&quot;]</code>是在访问name指向的字符串所在的内存区域，atomic无法保证访问指向的内容的读写安全。这是不一样的概念。</p></blockquote><p>我们来看一下以下的示例来说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) NSMutableString *name;</span><br><span class="line">//注意这里用的是NSMutableString</span><br><span class="line"></span><br><span class="line"> self.name = [NSMutableString string]; //ThreadA</span><br><span class="line"> [self.name appendString:@&quot;ddd&quot;];//ThreadB</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们线程A对name做了初始化操作，然后我们线程B做了赋值操作。系统为我们分配的地址是0x192838452，然后我们需要将这个地址写到name这里，假设写到一半的时候，B开始读取name并且赋值了，这个时候拿到的可能是一个0x19283000，那这个时候就有问题了，我们拿到的地址根本不是我们想要的，最好的情况这是一个野指针不会造成任何问题，但是如果这一块区域是系统的某一个关键的地方，要是被我们不小心给改了那可能问题就有点大了。</p><p>如果在上面的示例中我们将nonatomic改成atomic，那么就能保证将0x192838452这个值写到name里面的时候不会有另外一条线程来读取它，也就能保证保证读取出来的值是正确的，而不会是其他异常的值。</p><p>所以atomic的工作就是保护name这个指针的读写操作不会同时进行。至于name指向的内容，则不在atomic保护的范围之内。所以我们其实是有点误解atomic，以为它是可以保护name指向的内存地址的内容完整性。<code>其实这并不是它的工作</code></p><h2 id="线程安全如何实现？"><a href="#线程安全如何实现？" class="headerlink" title="线程安全如何实现？"></a>线程安全如何实现？</h2><p>这里我们首先要说两个概念：</p><p>第一个是上面说的<code>原子性</code><br>第二个是<code>CPU时间片轮转算法</code>：</p><blockquote><p>现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片，如果线程在时间片结束前阻塞或结束，则CPU当即进行切换。由于线程切换需要时间，如果时间片太短，会导致大量CPU时间浪费在切换上；而如果这个时间片如果太长，会使得其它线程等待太久。</p></blockquote><p>然后我们要明确一下，哪几种情况是线程安全的：</p><ol><li>如果线程是串行访问内存，那么是线程安全的。</li><li>如果操作是原子性的，那么也是线程安全的。</li></ol><p>所以在多线程的情况下，我们只要做到原子性，那么就可以保证线程安全。那么我们如何做到原子性呢？</p><ol><li>64位系统的地址总线对于读写指令可以支持8个字节的长度，所以我们常见的char,int,long 这些比较小的数据类型，一定是原子性的，所以这些数据类型一定不会有两个线程同时读写操作。</li><li>如果是常见的对象类型，那么就需要在上层加锁来处理了，原子性其实也是可以根据对象来分为大粒度和小粒度的，也就是说我们可以通过锁把一系列的操作先执行完成，然后再释放锁。</li></ol><p>在最开始的例子中，我们可以通过@synchronized来实现。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       @synchronized(self)&#123;</span><br><span class="line">           for (int i = 0; i&lt;100; i++) &#123;</span><br><span class="line">               self.name = @&quot;lemon&quot;;</span><br><span class="line">               NSLog(@&quot;线程A ： %@&quot;,self.name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       @synchronized(self)&#123;</span><br><span class="line">           for (int i = 0; i&lt;100; i++) &#123;</span><br><span class="line">               self.name = @&quot;well&quot;;</span><br><span class="line">               NSLog(@&quot;线程B ： %@&quot;,self.name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>不过根据<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的osspinlock</a>一文中，说到，使用@synchronized的性能是最低的，所以我们获取可以考虑使用<br>dispatch_semaphore_t来处理。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>atomic是线程安全的，但是它不能保证指针指向的地址也是线程安全的。在我们一开始写的例子中，它其实是不能决定哪条线程先执行，但是它已经保证了结果一定是well或者lemon，而不是其他的字符，这就是它起的作用。至于要保证上层读写统一的话，那就是需要用锁来解决了。</p><p>最后，国庆快乐！！！</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> atomic </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS中的load和initialize方法</title>
      <link href="/2018/09/11/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E7%9A%84load%E5%92%8Cinitialize%E6%96%B9%E6%B3%95/"/>
      <url>/2018/09/11/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E7%9A%84load%E5%92%8Cinitialize%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道在NSObject中有两个初始化的方法，<code>+(void)load</code>以及<code>+ (void)initialize</code>方法，这两个方法都是由系统来自动调用，不需要我们手动来调用，我们经常会在这两个方法的内部做一些magic的事情。</p><p>下面我们首先对这两个方法做一个初步的使用，看看他们两的调用时机以及异同。</p><p><strong>当然如果已经知道了他们的异同以及调用顺序的可以直接看总结或者源码分析</strong></p><a id="more"></a><h2 id="调用时机以及调用策略"><a href="#调用时机以及调用策略" class="headerlink" title="调用时机以及调用策略"></a>调用时机以及调用策略</h2><p>我们创建一个xcode工程，然后建立了一个person类，以及一个student类，student类继承于person类，person类里面有一个sayHello的类方法，然后我们创建了一个分类，Student(Extension),我们分别在这三个类下面重写了<code>load</code>以及<code>initialize</code>方法，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//Persom.m</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@implementation Person</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;person load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    NSLog(@&quot;person initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)hello&#123;</span><br><span class="line">    NSLog(@&quot;Person say hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Student.m</span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line">@implementation Student</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;student load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    NSLog(@&quot;student initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)hello&#123;</span><br><span class="line">    NSLog(@&quot;student say hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Student+Extension.m</span><br><span class="line">#import &quot;Student+Extension.h&quot;</span><br><span class="line">@implementation Student (Extension)</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;Student Category load&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    NSLog(@&quot;Student Category initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后我们在ViewController的<code>touchBegan</code>方法里面加入<code>[Studnet hello]</code>，程序启动之后会打打印出以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-10 16:51:26.487852+0800 Runtime[38325:14188628] person load</span><br><span class="line">2018-09-10 16:51:26.489395+0800 Runtime[38325:14188628] student load</span><br><span class="line">2018-09-10 16:51:26.489825+0800 Runtime[38325:14188628] Student Category load</span><br></pre></td></tr></table></figure><blockquote><p>通过上面的打印信息我们可以看出，load方法是由系统自动执行，并且调用的顺序是父类-&gt;子类-&gt;分类。</p></blockquote><p>接下来我们点击屏幕，打印以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-10 16:53:36.481032+0800 Runtime[38325:14188628] person initialize</span><br><span class="line">2018-09-10 16:53:36.481312+0800 Runtime[38325:14188628] Student Category initialize</span><br><span class="line">2018-09-10 16:53:36.481437+0800 Runtime[38325:14188628] student say hello</span><br></pre></td></tr></table></figure><blockquote><p>通过打印信息我们知道，只有当该类第一次接收到消息的时候才会调用initialize方法，同样会优先调用父类的initialize方法，但是我们的子类同样也实现了initialize方法，这里只打印了分类的方法，会不会是分类的方法把子类的方法覆盖了？</p></blockquote><p>下面我们来验证一下，我们通过修改将分类的initialize方法注释掉，然后重新运行点击屏幕，打印信息如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-10 17:00:22.099887+0800 Runtime[39163:14201501] person initialize</span><br><span class="line">2018-09-10 17:00:22.100215+0800 Runtime[39163:14201501] student initialize</span><br><span class="line">2018-09-10 17:00:22.101254+0800 Runtime[39163:14201501] student say hello</span><br></pre></td></tr></table></figure><blockquote><p>果然验证了我们的猜想，分类的initialize确实会覆盖原类的initialize方法。但是我们还有一个疑问，如果子类也不实现initialize方法的话，这样还会调用到父类的initialize方法吗？</p></blockquote><p>接下来我们将Student类的initialize方法注释掉，看一下打印信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-10 17:02:47.361138+0800 Runtime[39388:14205240] person initialize</span><br><span class="line">2018-09-10 17:02:47.361337+0800 Runtime[39388:14205240] person initialize</span><br><span class="line">2018-09-10 17:02:47.361451+0800 Runtime[39388:14205240] student say hello</span><br></pre></td></tr></table></figure><blockquote><p>通过打印信息我们看出来了，如果子类没有实现对应的initialize方法，那么将会调用父类的initialize方法。可是为什么父类initialize方法会被调用两次呢，是不是每个子类第一次收到消息的时候都会先调用父类的initialize方法呢？</p></blockquote><p>接下来我们将ViewController的<code>TouchBegan</code>方法修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Person hello];</span><br><span class="line">[Student hello];</span><br></pre></td></tr></table></figure><p>我们来看看打印信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-09-10 17:06:34.228551+0800 Runtime[39744:14211193] person initialize</span><br><span class="line">2018-09-10 17:06:34.228788+0800 Runtime[39744:14211193] Person say hello</span><br><span class="line">2018-09-10 17:06:34.229098+0800 Runtime[39744:14211193] person initialize</span><br><span class="line">2018-09-10 17:06:34.229187+0800 Runtime[39744:14211193] student say hello</span><br></pre></td></tr></table></figure><blockquote><p>通过打印信息我们看到了当Person收到hello消息的时候，会调用自身的initialize方法，当Person的子类Student收到消息的时候，同样调用了父类的initialize方法（这个是因为之类没有实现initialize方法，刚刚已经论证。），通过和上个打印信息对比，我们发现了如果子类第一次收到消息之前，父类没有收到过消息，也就是没有调用过initialize方法，会先调用initialize初始化父类，如果父类initialize方法已经被调用过，那么就不会调用父类的initialize的方法，而且调用自身的initialize方法，如果自身的initialize方法没有实现，那么就调用父类initialize方法。</p></blockquote><p><strong>我们做了这么多的对比论证，接下来我们来总结一下我们上面得到的结论</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过代码我们可以总结出以下的信息：</p><blockquote><ul><li>调用时机<br> <code>+(void)load</code>是在类或者分类加入到Objective-C Runtime的时候调用<br> <code>+(void)initialize</code>是在类或者子类第一次收到消息的时候调用（类消息或者对象消息）</li></ul></blockquote><blockquote><ul><li>调用顺序<br>   <code>+(void)load</code>方法的调用顺序是，父类-&gt;子类-&gt;分类。<br>   <code>+(void)initialize</code>方法的顺序是，父类-&gt;子类（如果有分类，分类方法会替换子类的方法，只执行分类的实现）</li></ul></blockquote><blockquote><ul><li>调用次数<br> <code>+(void)load</code>方法只会调用一次<br> <code>+(void)initialize</code>有可能会调用多次，如果子类没有实现该方法，则子类第一次收到消息的时候会调用父类的方法。<br>  值得一提的是，如果在子类收到消息之前，父类及其其他子类没有收到过消息，那么会先调用父类的<code>initialize</code>方法再调用子类的<code>initialize</code>方法</li></ul></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>这一系列的对比实验下来我们得出了自己的论证结果，但是从实现原理上面来说我还是对它们的底层实现很感兴趣，接下来我们就来看看源码实现。</p><p>源码我这边下载的是 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-723</a>版本。</p><h2 id="void-load"><a href="#void-load" class="headerlink" title="+ (void)load"></a>+ (void)load</h2><p>我们首先来看看在load方法是在哪里调用的以及在load方法之前都做了什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//在_objc_init运行时初始化方法里面会注册load_images的回调，当有新的镜像加载到runtime时，都会通知load_images方法</span><br><span class="line">_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line">//处理由DYLD(动态链接器)映射加载的镜像里面处理load方法</span><br><span class="line">load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    // Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    // Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过上面的代码我们可以到和load有关的方法有两个，一个是prepare_load_methods以及call_load_methods。下面我们分别来看看这两个方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        if (!cls) continue;  // category for ignored weak-linked class</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过上面的代码我们可以看到，这个方法是为了做一些准备工作。首先会获取镜像里面的所有的Classlist，然后遍历该classList，调用schedule_class_load，传入每一个class。然后全部遍历完成之后会获取category，同样的遍历之后直接加入到loadable_categories列表中。<strong>这样是为了保证class的load方法在category的load方法之前调用。</strong></p></li><li><p>接下来我们来看看schedule_class_load 方法：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());  // _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    // Ensure superclass-first ordering</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该方法会获取该类的父类然后递归调用<code>schedule_class_load</code>方法，保证父类的load方法在子类的load方法之前执行。然后将class 加入到loadable_classes里面。</li></ul><p><strong>综上所述，prepare_load_methods这个方法就是将满足load方法的class和category分别存放到loadble_classs以及loadable_categories里面</strong></p><p>接下来我们来看看<code>call_load_methods</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading = NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    void *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        // 1. Repeatedly call class +loads until there aren&apos;t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. Call category +loads ONCE</span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        // 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这一步就是调用loabable_classes 以及 loadable_categories中准备好的load方法，并且class优先于category先调用。接下来我们以call_class_loads为例来看看代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    // Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes = loadable_classes;</span><br><span class="line">    int used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = 0;</span><br><span class="line">    loadable_classes_used = 0;</span><br><span class="line">    </span><br><span class="line">    // Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Destroy the detached list.</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从全局变量loadable_classes中得到所有可供调用的class，然后将变量进行清零操作，然后遍历加载所有的class,通过<code>(*load_method)(cls, SEL_load);</code>的方式调用+(void)load方法，这里是通过直接调用函数的内存地址的方式来实现调用load方法，而不是objc常见的msg_send()方法。<br><strong>所以这里就可以解释了为什么子类没有实现load方法的时候不会调用到父类的load方法，因为不是通过msg_send的方式去调用的。也就是每个类的load方法都是独立的，不会有消息的转发等情况发生，也就是利用这个特性，我们可以在这里做<a href="https://nshipster.com/method-swizzling/" target="_blank" rel="noopener">method swizzling</a></strong></li></ul><h2 id="void-initialize"><a href="#void-initialize" class="headerlink" title="+ (void)initialize"></a>+ (void)initialize</h2><p>接下来我们来看看<code>+ (void)initialize</code>方法是如何被调用的，我们来关注一下runtime-new.mm文件里面的lookUpImpOrForward方法，我相信有些人看到这个方法应该觉得有点熟悉，这里就是返回一个方法的实现或者消息转发的时候就会调用该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        // If sel == initialize, _class_initialize will send +initialize and </span><br><span class="line">        // then the messenger will send +initialize again after this </span><br><span class="line">        // procedure finishes. Of course, if this is not being called </span><br><span class="line">        // from the messenger then it won&apos;t happen. 2778172</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过上面的关键代码我们可以看出当一个类的方法任何一个方法被调用的时候，就会判断该类是否已经调用了initialize方法，如果没有调用的话就会通过<code>void_class_initialize(Class cls)</code>方法来调用initialize方法，接下来我们来看具体实现。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    bool reallyInitialize = NO;</span><br><span class="line"></span><br><span class="line">    // Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    // See note about deadlock above.</span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized())   &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    &#123;</span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">            cls-&gt;setInitializing();</span><br><span class="line">            reallyInitialize = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        // We successfully set the CLS_INITIALIZING bit. Initialize the class.</span><br><span class="line">        </span><br><span class="line">        // Record that we&apos;re initializing this class so we can message it.</span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        if (MultithreadedForkChild) &#123;</span><br><span class="line">            // LOL JK we don&apos;t really call +initialize methods after fork().</span><br><span class="line">            performForkChildInitialize(cls, supercls);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // Send the +initialize message.</span><br><span class="line">        // Note that +initialize is sent to the superclass (again) if </span><br><span class="line">        // this class doesn&apos;t implement +initialize. 2157218</span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: thread %p: calling +[%s initialize]&quot;,</span><br><span class="line">                         pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Exceptions: A +initialize call that throws an exception </span><br><span class="line">        // is deemed to be a complete and successful +initialize.</span><br><span class="line">        //</span><br><span class="line">        // Only __OBJC2__ adds these handlers. !__OBJC2__ has a</span><br><span class="line">        // bootstrapping problem of this versus CF&apos;s call to</span><br><span class="line">        // objc_exception_set_functions().</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @try</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">        //通过objc_msgSend方法调用initialize方法</span><br><span class="line">           ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @catch (...) &#123;</span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: +[%s initialize] &quot;</span><br><span class="line">                             &quot;threw an exception&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            @throw;</span><br><span class="line">        &#125;</span><br><span class="line">        @finally</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            // Done initializing.</span><br><span class="line">            lockAndFinishInitializing(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过上面的代码我们看到了该方法首先会获取该类的父类，并且递归调用<code>_class_initialize</code>方法保证父类的方法优先于子类执行。然后我们看到了有一行很关键的代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">  asm(&quot;&quot;);</span><br></pre></td></tr></table></figure><ul><li>+(void)initialize方法是通过objc_msgSend方法来调用的，区别于load方法通过方法内存地址调用，所以根据objc_msgSend的特性，如果一个子类没有实现initialize方法，那么将会调用父类的initialize方法，如果分类实现了initialize方法，那么将会替换子类方法。</li></ul><p><strong>综上所述，一个类的initialize方法是有可能被调用多次的，如果他有对应的子类并且子类没有实现对应的initialize方法的时候本类的initialize方法就会被调用多次。所以为了保证一个类的initialize方法里面的逻辑只会被调用一次，我们可以通过以下的代码判断</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">  if (self == [ClassName self]) &#123;</span><br><span class="line">    // ... do the initialization ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS图片解码实践</title>
      <link href="/2018/09/04/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/09/04/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在iOS中，大多数的APP都有不可或缺的图片资源，同时也很容易因为对图片的处理不恰当造成性能低下，不要让图片成为你的APP的性能杀手。</p><p>一张图片从磁盘中加载出来，同时显示到屏幕上，经过了一系列的复杂处理，其中包括了对图片的解码，我们今天就来做一次图片的解码实践。</p><h2 id="图片显示过程"><a href="#图片显示过程" class="headerlink" title="图片显示过程"></a>图片显示过程</h2><p>平时我们对于图片的显示，一般都是使用以下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIImage *image = [UIImage imageNamed:@&quot;icon&quot;];</span><br><span class="line">self.imageView.image = image;</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>简单的两行代码其实里面包含了下面几步:</p><ol><li>首先会调用 <a href="https://developer.apple.com/library/ios/documentation/graphicsimaging/conceptual/ImageIOGuide/imageio_intro/ikpg_intro.html#//apple_ref/doc/uid/TP40005462-CH201-TPXREF101" target="_blank" rel="noopener">image/io</a>从磁盘中加载一张图片，这个时候，图片还没有解码。</li><li>将image复制给imageView的image</li><li>然后一个隐式的CATransaction捕获到图层树的变化</li><li>在主线程runloop下一次迭代到来的时候，Core Animation会提交这个隐式transaction，这个过程会对图片进行copy操作，根据图片的不同，可能会涉及以下的一些甚至全部的步骤。</li></ol></blockquote><blockquote><pre><code>I. 为文件管理IO和解压缩操作分配内存缓存区域II. 从磁盘中读取数据到内存中III. 将压缩的图片数据解码成未压缩的图片数据，这通常是一个非常频繁耗时的CPU操作IV. CoreAnimation将未压缩位图数据渲染到layer上。</code></pre></blockquote><p>从上面的步骤可以看出，图片的解码主是主要耗时的原因，如果一个APP中只有几张图片是这样设置当然是没问题的，可是如果在一个TableView中有大量的图片在滚动，如果这个时候在不断的解码显示那必然会导致界面卡顿。</p><h2 id="为什么需要解码"><a href="#为什么需要解码" class="headerlink" title="为什么需要解码"></a>为什么需要解码</h2><p>实际上我们使用的JPEG或者PNG格式的图片，都是一种经过压缩的位图图形格式，只不过PNG是无损压缩并且支持alpha通道，而JEPG是有损压缩，并且可以指定压缩比。下面是iOS中提供的获得上述格式图片的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN  NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull image);                               // return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format</span><br><span class="line">UIKIT_EXTERN  NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull image, CGFloat compressionQuality);  // return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)</span><br></pre></td></tr></table></figure><p>接下来我们就要了解一下位图：</p><blockquote><p>A bitmap image (or sampled image) is an array of pixels (or samples). Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images.</p></blockquote><p>其实位图就是一个像素数组，每个像素都代表了图片中独立的一个点，每一个点其实又包含了以下内容：</p><blockquote><p>Bits per component ：一个像素中每个独立的颜色分量使用的 bit 数；<br>Bits per pixel ：一个像素使用的总 bit 数；<br>Bytes per row ：位图中的每一行使用的字节数。</p></blockquote><p>这里不多说，具体的可以查看<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBECCFG" target="_blank" rel="noopener">像素格式</a>。</p><p>我们知道位图是经过压缩后的，我们可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIImage *image = [UIImage imageNamed:@&quot;icon&quot;];</span><br><span class="line">CFDataRef rawData = CGDataProviderCopyData(CGImageGetDataProvider(image.CGImage));</span><br></pre></td></tr></table></figure><p>得到原始的数据大小，一般该数据的大小的计算方式是：</p><blockquote><p>图片像素宽<em> 图片像素高  </em> 每个像素所占的字节数4</p></blockquote><p>所以图片当前的大小并不等于解码后的大小，所以我们才需要解码之后才能得到原始的数据大小，只有使用原始数据才能正确的显示出图片。</p><h2 id="正确的解码姿势"><a href="#正确的解码姿势" class="headerlink" title="正确的解码姿势"></a>正确的解码姿势</h2><p>上面已经知道了图片显示是会在主线程解压缩图片之后然后渲染到屏幕上，首先我们可以在子线程中做解码的操作，在子线程中重新绘制图片，得到解码后的图片，然后渲染到屏幕上。</p><p>我们先上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (void)decodeImage:(UIImage *)image completion:(void(^)(UIImage *image))completion&#123;</span><br><span class="line">    if (!image) return;</span><br><span class="line">    //在子线程执行解码操作</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</span><br><span class="line">        CGImageRef imageRef = image.CGImage;</span><br><span class="line">        //获取像素宽和像素高</span><br><span class="line">        size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">        size_t height = CGImageGetHeight(imageRef);</span><br><span class="line">        if (width == 0 || height == 0) return ;</span><br><span class="line">        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask;</span><br><span class="line">        BOOL hasAlpha = NO;</span><br><span class="line">        //判断颜色是否含有alpha通道</span><br><span class="line">        if (alphaInfo == kCGImageAlphaPremultipliedLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">            alphaInfo == kCGImageAlphaLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaFirst) &#123;</span><br><span class="line">            hasAlpha = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        //在iOS中，使用的是小端模式，在mac中使用的是大端模式，为了兼容，我们使用kCGBitmapByteOrder32Host，32位字节顺序，该宏在不同的平台上面会自动组装换成不同的模式。</span><br><span class="line">        /*</span><br><span class="line">         #ifdef __BIG_ENDIAN__</span><br><span class="line">         # define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Big</span><br><span class="line">         # define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Big</span><br><span class="line">         #else    //Little endian.</span><br><span class="line">         # define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Little</span><br><span class="line">         # define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Little</span><br><span class="line">         #endif</span><br><span class="line">         */</span><br><span class="line">        </span><br><span class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        //根据是否含有alpha通道，如果有则使用kCGImageAlphaPremultipliedFirst，ARGB否则使用kCGImageAlphaNoneSkipFirst，RGB</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        //创建一个位图上下文</span><br><span class="line">        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0,  CGColorSpaceCreateDeviceRGB(), bitmapInfo);</span><br><span class="line">        if (!context) return;</span><br><span class="line">        //将原始图片绘制到上下文当中</span><br><span class="line">        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</span><br><span class="line">        //创建一张新的解压后的位图</span><br><span class="line">        CGImageRef newImage = CGBitmapContextCreateImage(context);</span><br><span class="line">        CFRelease(context);</span><br><span class="line">        UIImage *originImage =[UIImage imageWithCGImage:newImage scale:[UIScreen mainScreen].scale orientation:image.imageOrientation];</span><br><span class="line">        //回到主线程回调</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            completion(originImage);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><table><thead><tr><th>图片尺寸</th><th>未解码直接渲染时间(ms)</th><th>解码后渲染时间(ms)</th></tr></thead><tbody><tr><td>128x96.jpg</td><td>0.99</td><td>0.08</td></tr><tr><td>128x96.png</td><td>0.80</td><td>0.08</td></tr><tr><td>256x192.jpg</td><td>3.01</td><td>0.14</td></tr><tr><td>256x192.png</td><td>2.30</td><td>0.17</td></tr><tr><td>512x384.jpg</td><td>4.83</td><td>0.28</td></tr><tr><td>512x384.png</td><td>6.03</td><td>0.28</td></tr><tr><td>1024x768.jpg</td><td>13.83</td><td>1.43</td></tr><tr><td>1024x768.png</td><td>18.31</td><td>1.12</td></tr><tr><td>2048x1536.jpg</td><td>31.72</td><td>3.99</td></tr><tr><td>2048x1536.png</td><td>75.05</td><td>5.16</td></tr></tbody></table><p>通过上面的对比我们可以看出，解码后的图片的渲染速度远远高于未解码后的图片的渲染速度，并且由于我们在子线程中进行解码，所以也不会造成主线程的UI卡顿。</p><h2 id="Demo-is-here"><a href="#Demo-is-here" class="headerlink" title="Demo is here"></a>Demo is here</h2><p>最后，按照常规，这里应该有一份<a href="https://github.com/codemonkeybulucck/ImageUncompressing" target="_blank" rel="noopener">demo</a>;</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>你看那个程序员，他孤不孤独</title>
      <link href="/2018/08/31/%E6%9D%82%E8%B0%88/%E4%BD%A0%E7%9C%8B%E9%82%A3%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E4%BB%96%E5%AD%A4%E4%B8%8D%E5%AD%A4%E7%8B%AC/"/>
      <url>/2018/08/31/%E6%9D%82%E8%B0%88/%E4%BD%A0%E7%9C%8B%E9%82%A3%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E4%BB%96%E5%AD%A4%E4%B8%8D%E5%AD%A4%E7%8B%AC/</url>
      <content type="html"><![CDATA[<p>今天是星期五，对于大多数人来说估计已经在琢磨着周末去哪里浪了，或者周末在家睡个天昏地暗，享受一下这难得不用早起挤车挤地铁的周末。</p><p>龙哥看看手表，凌晨四点整，刚吃完酸菜牛肉面的龙哥打算下班回家。这已经是龙哥这周第三次加班到凌晨了，只有星期二的时候休息了一天没加班，因为项目快要上线了，估计周末还得在办公室度过。</p><p>作为“资深”程序员的龙哥虽然才工作三年多，但是已经有五年的工作经验了。如果是同行的话估计会懂这句话是啥意思，那多出来的一年半的工作经验就是加班多出来的。</p><a id="more"></a><p>加班对于龙哥来说已经司空见惯了，因为加班，他认识了很多出租车司机，通过出租车司机他就能知道今天哪里哪里又发生什么大事了，哪里的休闲会所能提供最好质量的服务，哪里的人最没素质。龙哥每次就这么坐在车上听司机闲扯着，也不会反驳司机说的不对的事情。对于龙哥来说他每天凌晨碰到的这些人就是他的私人新闻导播，只不过有点不一样的是，这些新闻往往被放大很多倍，甚至有些是谣言，不过他并不在意，毕竟这是一天中最有趣的时刻，或者更确切的说，这是龙哥最不孤独的时刻。</p><p>刚刚说了龙哥中间有一天不加班，其实是去帮女生搬家了，据说还请女生吃饭了。<br>那天我还问了龙哥，对话是这样的：<br>我：”龙哥，你去帮女生搬家，应该她请你吃饭才对啊，怎么变成你请她吃饭了？”<br>龙哥笑着说：”我请她吃饭是因为我已经很久没有和别人一起吃饭了，每天下班基本上都是自己随便吃一点就解决了，应该还要感谢她陪我吃饭。“<br>我：“那这样说的话，以后你想找别人陪你吃饭了你就找我，这样的好事别便宜别人了，但是前提是你买单”。<br>龙哥：“滚”。（请自行脑补龙哥臭脸的样子）</p><p>龙哥没有女朋友，据他说是大学的时候谈过一次恋爱，分手的原因和很多人一样，毕业之后大家意向不同，龙哥想去北上广深这些大城市工作，那里的IT就业环境是其他二线城市不能比的，但是他前女友想留在老家找个教师的工作，家里的生活压力相对小点，然后他们就和平分手了。</p><p>我问过龙哥想过重新找个女朋友吗？龙哥也很实诚，说想过，但是有个事情他意想不到。因为大学是在师范院校读的计算机专业，所以大学的时候身边的女生也相对较多一点，找女朋友机会也多一点。没想到毕业之后进去的科技公司，身边纯一色的抠脚大汉，根本没有途径去认识女生。好不容易来了一个女同事，要不就是有男朋友，要不就是已婚，再要不就是他喜欢的女生他还没行动又成为别人的女朋友了。</p><p>后来龙哥就对谈恋爱这个事情不强求了，佛系找女朋友，有也行，没有也行，不争不抢。</p><p>龙哥不喜欢待在家里，就喜欢在外边溜达，龙哥自己一个人住，广州的城中村大家都知道，即使是一房一厅也小得可怜，握手楼，一栋挨着一栋。打开窗没有阳光，看到的都是水泥钢筋，关上门也不隔音，听到的都是嘈杂噪音。这个时节的广州，基本上每天都下雨，龙哥家里也潮湿，之前听他说家里的柜子都因为潮湿木头膨胀倒塌了，不过他又把它给修好了，后来逢人他就炫耀他会修柜子这个事情。</p><p>龙哥爱好不多，如果发呆算是爱好的话那他就只有一个爱好。我经常看到他坐在座位上发呆，也不知道他在想些什么，不过我知道他很少和人说他自己的私事，他朋友不多，我算是他比较好的朋友，不过我也没听他向我抱怨过什么或者说一些，那一次龙哥发呆真的吓到我了。</p><p>那是我们俩在加班的时候，我和龙哥算是同道中人，我也是加班狂魔。除了工作原因外，我是想着攒多一点假期后面调休出去旅游一趟，至于龙哥，我问过他，但是我觉得他是在逃避一些什么东西。</p><p>我印象最深刻的时候是那一天，星期五，已经是凌晨三点钟了，办公室的人都走光了，就只有我和龙哥还在工作，我突然觉得肚子有点饿，我就和龙哥说，“龙哥，你饿吗？和你一起下去吃点东西”。龙哥抬头看着我，“我有点忙，商品详情功能我快写完了，你帮我买一个方便面上来可以吗？惯例，酸菜牛肉面”。“OK，那我帮你买上来。”然后我就下去买方便面了，龙哥总是对酸菜牛肉面情有独钟，每次都是吃这个面，而我讨厌酸菜牛肉面，我喜欢吃点健康的，蔬菜面。不到十分钟我就把面买上来了。</p><p>然后我就看到了以下的一幕，办公司所有的灯都关掉了，就只有我们俩头顶那两盏灯还开着，在暗黄的灯光的照耀下，龙哥双手交叉抱在胸前，后背靠在座位上，身体侧着对着电脑，眼镜好像看着斜上方的横梁，但是处于放空的状态，准确来说应该是双目无神，他看起来整个人静止了。</p><p>说实话我刚看到那一刻的时候我第一想法就是打120，龙哥是不是出事了， 因为我从来没有见过他这么疲惫，脸上毫无表情，一副与世隔绝的样子。那时我真的被吓到了，后来我看龙哥眨了一下眼睛，我才放下心来。</p><p>我记得我问过龙哥，“你孤独吗？”，龙哥说了下面一段话：</p><blockquote><p>“你试过凌晨三点钟突然惊醒吗？我试过！我醒来之后我看着四周黑暗一片，我看向窗外，只有微微的光亮。后来我打开灯，四周是亮白的墙，但是我还是很怕，感觉我被别人困在房子里面了，孤独感包围着我，我那晚一宿没睡，第二天六点钟我就出门去上班了，我不想再有那样的时刻。”</p></blockquote><p>可能发呆的这一刻龙哥什么都没有在想，也有可能是想起了那天的情景，那种孤独感蔓延到了公司，同样在三点钟，将龙哥包围了。</p><p>或许龙哥真的在逃避，他是在逃避孤独，我见过他一个人抱着爆米花去电影院看爱情电影，旁边都是一对对的情侣；我见过他一个人去吃海底捞，店员看他是一个人来的对面给他放了一个大的公仔；我见过他一个人去KTV，唱了一晚上《男人KTV》。</p><p>现在是凌晨四点钟，终于把商品详情功能完成了，刚吃完酸菜牛肉面，还有点饱，写完这篇文章就打算回去睡觉，今天有点累，不过我还是宁愿凌晨三点钟睡觉也不愿凌晨三点钟醒来。</p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS中的圆角处理（终结篇）</title>
      <link href="/2018/08/29/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E7%9A%84%E5%9C%86%E8%A7%92%E5%A4%84%E7%90%86%EF%BC%88%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%89/"/>
      <url>/2018/08/29/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E7%9A%84%E5%9C%86%E8%A7%92%E5%A4%84%E7%90%86%EF%BC%88%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发中，我们经常用到圆角的处理，圆角看起来会比直角更加美观和柔美。但是设置圆角往往会带来一定的性能损耗，损耗的来源主要由于大量的离屏渲染，接下来我们就来讲一下如果实现高性能的圆角。我们下面来看以下几种设置圆角的方式以及它们对性能的影响。</p><h2 id="CornerRadius-masksToBounds"><a href="#CornerRadius-masksToBounds" class="headerlink" title="CornerRadius+masksToBounds"></a>CornerRadius+masksToBounds</h2><p>第一种方式就是我们最常用的设置圆角的方式，我们首先来看看<code>cornerRadius</code>的定义是什么：</p><blockquote><p>The radius to use when drawing rounded corners for the layer’s background. Animatable.<br>Setting the radius to a value greater than 0.0 causes the layer to begin drawing rounded corners on its background. By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to YES causes the content to be clipped to the rounded corners.<br>The default value of this property is 0.0.</p></blockquote><a id="more"></a><p>通过上面的解释我们可以看到cornerRadius只是对view的背景颜色和边框起作用，对于一些像ImageView以及Label等含有内部子视图的就不起作用了，这个时候我们往往还要添下下面这一句来让label生成一个适配圆角的剪切蒙版，该蒙版与label的边界相匹配，这样就达到了圆角的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label.layer.masksToBounds = YES;</span><br></pre></td></tr></table></figure><p>但是这样就会导致另外一个问题，离屏渲染。前面我们已经说了大量的离屏渲染会导致性能下降，最直观的感受就是如果在一个tableView中有大量的离屏渲染，就会导致FPS下降导致掉帧，界面看起来卡顿。</p><h3 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h3><p>我们通过模拟器的 <code>Color-Off-screen-Render</code>可以看到那个元素产生了离屏渲染了，和很多人说的不一样，不可以统筹的说<code>创建圆角是产生离屏渲染的原因</code><br>正确的来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.layer.cornerRadius = 5;</span><br><span class="line">view.layer.maskToBounds = YES;</span><br></pre></td></tr></table></figure></p><p>这两句代码合在一起才是产生离屏渲染的原因。如下图所示，每个cell的第一和第二个的ImageView都是执行了上面的两句代码，产生了离屏幕渲染，而第三个棕色的圆形则是一个view，代码里面仅使用了<code>view.layer.cornerRadius</code>，所以没有产生离屏渲染。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/sim.png" alt="si"></p><p>如上所示，当一个tableView的离屏渲染达到了44个的时候，FPS下降到了35左右，性能下降得很厉害。所以如果一个界面上需要有很多的圆角的时候，这种方式不可取。</p><h2 id="CAShapeLayer-UIBezierPath"><a href="#CAShapeLayer-UIBezierPath" class="headerlink" title="CAShapeLayer+UIBezierPath"></a>CAShapeLayer+UIBezierPath</h2><p>这种方式简直是噩梦，我们先来看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> CAShapeLayer *mask = [CAShapeLayer new];</span><br><span class="line">    mask.path = [UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:10].CGPath;</span><br><span class="line">imageView.layer.mask = mask;</span><br></pre></td></tr></table></figure><p>我们首先创建一个mask，然后通过贝塞尔曲线覆盖到原来的imageView上面，几行代码搞定。</p><h3 id="性能影响-1"><a href="#性能影响-1" class="headerlink" title="性能影响"></a>性能影响</h3><p>然后我们来看看界面是否会产生离屏渲染。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/sim2.png" alt="si"></p><p>如果不看一下真的吓一跳，全部的元素都产生了离屏渲染，还不如第一种方式。然后我们看一下FPS是10，其实都不用看FPS，直接页面上都能看出来了，卡到怀疑人生。</p><p>上面的方式是创建子控件的时候直接添加mask，还有一种方式是在 <code>-(void)drawRect:(CGRect)rect</code>里面添加mask，这样方式更加糟糕，因为不恰当的使用这个方法会导致内存暴增。举个例子，iPhone6 上与屏幕等大的 UIView，即使重写一个空的 drawRect 方法，它也至少占用 750 <em> 1134 </em> 4 字节 ≈ 3.4 Mb 的内存。在 <a href="http://bihongbo.com/2016/01/03/memoryGhostdrawRect/" target="_blank" rel="noopener">内存恶鬼drawRect</a> 及其后续中，作者详细介绍了其中原理，据他测试，在 iPhone6 上空的、与屏幕等大的视图重写 drawRect 方法会消耗 5.2 Mb 内存。总之，能避免重写 drawRect 方法就尽可能避免。</p><h2 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a>Core Graphics</h2><p>我们知道UIView其实是由CALayer和UIResponder组成，一个负责显示，一个负责响应。但是CALayer也只是一个普通的类，它并不能直接渲染到屏幕上，我们看到屏幕上面的东西其实也只是一张张图片，那为什么我们可以看到CALayer的内容呢。因为CALayer有一个content的属性，该属性可以传一个id类型的对象，当你传的对象为CGImage的时候，才会显示出来。</p><p>那通过Core Graphics 我们可以画出一个具有圆角的图片，然后添加到layer上面。</p><p>不过UIVIew和UIImageView的实现方式不一样，UIView的方式是创建一个空白的图片，然后插入到视图的最下面。而UIImageView是将在原来Image的基础上重新绘制一张带有圆角的图片，然后赋值给ImageView。</p><p>以下是关键代码：</p><p>UIVIew:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)lm_drawRectWithRoundedCorner:(CGFloat)radius</span><br><span class="line">                              borderWidth:(CGFloat)borderWidth</span><br><span class="line">                              borderColor:(UIColor *)borderColor</span><br><span class="line">                          backGroundColor:(UIColor*)bgColor&#123;</span><br><span class="line">    CGSize size = self.bounds.size;</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale);</span><br><span class="line">    CGContextRef contextRef =  UIGraphicsGetCurrentContext();</span><br><span class="line">    </span><br><span class="line">    CGContextSetLineWidth(contextRef, borderWidth);</span><br><span class="line">    CGContextSetStrokeColorWithColor(contextRef, borderColor.CGColor);</span><br><span class="line">    CGContextSetFillColorWithColor(contextRef, bgColor.CGColor);</span><br><span class="line">    </span><br><span class="line">    CGFloat halfBorderWidth = borderWidth / 2.0;</span><br><span class="line">    CGFloat width = size.width;</span><br><span class="line">    CGFloat height = size.height;</span><br><span class="line">    </span><br><span class="line">    CGContextMoveToPoint(contextRef, width - halfBorderWidth, radius + halfBorderWidth);</span><br><span class="line">    CGContextAddArcToPoint(contextRef, width - halfBorderWidth, height - halfBorderWidth, width - radius - halfBorderWidth, height - halfBorderWidth, radius);  // 右下角角度</span><br><span class="line">    CGContextAddArcToPoint(contextRef, halfBorderWidth, height - halfBorderWidth, halfBorderWidth, height - radius - halfBorderWidth, radius); // 左下角角度</span><br><span class="line">    CGContextAddArcToPoint(contextRef, halfBorderWidth, halfBorderWidth, width - halfBorderWidth, halfBorderWidth, radius); // 左上角</span><br><span class="line">    CGContextAddArcToPoint(contextRef, width - halfBorderWidth, halfBorderWidth, width - halfBorderWidth, radius + halfBorderWidth, radius); // 右上角</span><br><span class="line">    CGContextDrawPath(contextRef, kCGPathFillStroke);</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>UIImageVIew:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)lm_drawRectWithRoundedCorner:(CGFloat)radius</span><br><span class="line">                                     size:(CGSize)size&#123;</span><br><span class="line">    </span><br><span class="line">    CGRect rect = CGRectMake(0, 0, size.width, size.height);</span><br><span class="line">    </span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(rect.size, false, [UIScreen mainScreen].scale);</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, radius)];</span><br><span class="line">    CGContextAddPath(context, path.CGPath);</span><br><span class="line">    </span><br><span class="line">    CGContextClip(context);</span><br><span class="line">    </span><br><span class="line">    [self drawInRect:rect];</span><br><span class="line">    CGContextDrawPath(context, kCGPathFillStroke);</span><br><span class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return  image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能影响-2"><a href="#性能影响-2" class="headerlink" title="性能影响"></a>性能影响</h3><p><img src="http://pcd17v2u0.bkt.clouddn.com/sim3.png" alt="si"></p><p>从上面的图片我们可以看出，设置圆角已经没有离屏渲染了，通过Core Animation可以看出FPS也回到60左右，界面也没有卡顿了。</p><font color="#dd0000">注意：即使我们使用了这种方式，我们还是要谨慎直接设置view.backGroundColor，因为我们没有设置maskToBounds属性，所以以这样的方式设置了背景颜色依然会导致没有圆角效果。<br>如果想要背景颜色，可以在画圆角图片的时候改变一下backGroundColor。</font><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，我们得出以下的结论：</p><ol><li>layer.cornerRadius不会触发离屏渲染，该属性只是对边框和背景颜色起作用，适用于内部没有其他控件的view。</li><li>CAShapeLayer+UIBezierPath会触发离屏渲染。</li><li>最好的方式就是使用Core Graphics的方式绘制圆角图片。</li><li>当然，还是那句话，根据场景来使用，如果界面中圆角的地方不多，第一种方式是最简单快捷，效率最高的。如果用到的圆角很多，那还是使用Core Graphics的方式把。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>本文章的代码已经放到Github，需要的可以自取。<a href="https://github.com/codemonkeybulucck/CornerViewDemo" target="_blank" rel="noopener">CornerViewDemo</a></p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Runloop黑魔法之复活APP</title>
      <link href="/2018/08/23/iOS%20%E5%BC%80%E5%8F%91/Runloop%E9%BB%91%E9%AD%94%E6%B3%95%E4%B9%8B%E5%A4%8D%E6%B4%BBAPP/"/>
      <url>/2018/08/23/iOS%20%E5%BC%80%E5%8F%91/Runloop%E9%BB%91%E9%AD%94%E6%B3%95%E4%B9%8B%E5%A4%8D%E6%B4%BBAPP/</url>
      <content type="html"><![CDATA[<h1 id="Runloop黑魔法之复活APP"><a href="#Runloop黑魔法之复活APP" class="headerlink" title="Runloop黑魔法之复活APP"></a>Runloop黑魔法之复活APP</h1><p>看到这个标题是不是觉得很酷炫，但是我还要是解释一下标题是什么意思，以免有人说我标题党，我现在要做的就是当APP发生Crash的时候，不要让APP闪退，而是重新复活。</p><blockquote><p>换句话可以这么形容，把一个Crash信息吞掉，大家当没事发生过。</p></blockquote><p>说得这么牛批，这个东西有什么实际的用处呢？额，其实还真的没啥实际的用处，不过我们当发生异常信息的时候可以友好的弹一个框告诉用户当前发生了异常，是选择上传异常信息继续运行还是直接退出，当然继续运行依然会有Crash风险。</p><p>接下来我们就来实现这么一个事情吧。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>大家都知道，我们的APP能随时的处理事件就是因为有Runloop的存在，Runloop顾名思义就是一个环，不断的跑，并且Runloop是事件驱动的，也就是说没有事情做得时候就休眠，当有事情做的时候就做事情。</p><p>Runloop实际上是一个对象，这个对象管理了其所需要的消息和事件，并且提供了一个入口函数。线程执行了该函数之后，就会一直处于Runloop的内部，而Runloop的内部就会一直处于接受消息-&gt;处理-&gt;等待-&gt;接受消息这样的循环中。直到这个循环结束，线程才会退出。</p><p>想想如果我们的APP接受到Exception消息的时候，我们先获得当前的Runloop，然后获取所有的mode，自行创建一个死循环，让runloop在里面执行不同的mode，这样就相当于让Runloop起死回生了，这样APP也复活了。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>在我前面写得这一篇<a href="http://lemon2well.top/2018/08/22/iOS%20%E5%BC%80%E5%8F%91/iOS%E6%94%B6%E9%9B%86Crash%E4%BF%A1%E6%81%AF%E4%B8%8A%E6%8A%A5/">iOSCrash信息上报和处理</a>中我们已经实现了监听Exception事件，所以我们在监听到该事件之后插入以下代码即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获得当前的runloop并且重新启动</span><br><span class="line">   CFRunLoopRef runloop = CFRunLoopGetCurrent();</span><br><span class="line">   NSArray *modes = CFBridgingRelease(CFRunLoopCopyAllModes(runloop));</span><br><span class="line">   while (!self.isExit) &#123;</span><br><span class="line">       for (NSString *mode in modes) &#123;</span><br><span class="line">           CFRunLoopRunInMode((CFStringRef)mode, 0.001, false);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们来逐行看一下上面的代码，首先我们获取到当前的Runloop，然后我们获取到当前Runloop的所有mode，然后我们创建一个循环，在里面不断的跑所有的mode，这样就实现了APP的复活。</p><p><a href="https://github.com/codemonkeybulucck/RunloopResurgenceAPP" target="_blank" rel="noopener">这里</a>是完整的demo</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Runloop是个好东西，它能做的事情远远超出我们的想像，虽然我们开发中很少直接去接触Runloop，但是它却起着无比重要的作用，所以下面提供一些关于Runloop的资料介绍：</p><p><a href="https://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="noopener">sunnyxx线下分享Runloop</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">ibireme深入理解Runloop</a></p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOSCrash信息上报和处理</title>
      <link href="/2018/08/22/iOS%20%E5%BC%80%E5%8F%91/iOSCrash%E4%BF%A1%E6%81%AF%E4%B8%8A%E6%8A%A5%E5%92%8C%E5%A4%84%E7%90%86/"/>
      <url>/2018/08/22/iOS%20%E5%BC%80%E5%8F%91/iOSCrash%E4%BF%A1%E6%81%AF%E4%B8%8A%E6%8A%A5%E5%92%8C%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>在iOS开发中，最严重的bug估计就是应用奔溃，如果应用奔溃了，除了做好挨骂的准备，还需要冷静的下来去处理这个事情，接下来我们来看看需要做什么事情。</p><h2 id="获取crash信息"><a href="#获取crash信息" class="headerlink" title="获取crash信息"></a>获取crash信息</h2><p>我们首先第一个事情就是要知道应用的奔溃信息是什么，这里有几种方式去获取奔溃信息。</p><ol><li>使用Bugly，友盟等第三方SDK登入后台查看奔溃信息</li><li>代码自动上传奔溃信息到服务器，然后通过恢复dSYM文件来查看奔溃信息</li><li>通过使用当前发生应用奔溃的设备导出相关的奔溃信息</li><li>如果是线上的应用，还可以通过itunesConnect来查看（非即时）</li></ol><a id="more"></a><p>第一种集成第三方SDK的方案基本上不用我们管，只需要根据文档集成即可。<br>下面我们要讲的是第二种和第三种方案，第四种方案其实和第三种方案差不多，为什么要区分这两种方案呢，因为第二种方案中我们可以直接拿到奔溃的堆栈和具体信息，也就是可以看出在那段代码奔溃以及具体的奔溃内容。但是第三种和第四种方案我们拿到的奔溃信息是经过处理的奔溃信息，如下面所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Incident Identifier: 66BAB91F-07F7-4242-B8EF-8CC1771E5EF0</span><br><span class="line">CrashReporter Key:   bb6af27d5f29cc19a8df5dbdff702227fdb1232b</span><br><span class="line">Hardware Model:      iPhone8,1</span><br><span class="line">Process:             testImageSourceCode [25042]</span><br><span class="line">Path:                /private/var/containers/Bundle/Application/C8A371D9-3F19-4A17-A817-5FF35A40C8E7/testImageSourceCode.app/testImageSourceCode</span><br><span class="line">Identifier:          com.cmcc.enterprise-classID.onecardmultinumber.sdk</span><br><span class="line">Version:             1 (1.0)</span><br><span class="line">Code Type:           ARM-64 (Native)</span><br><span class="line">Role:                Foreground</span><br><span class="line">Parent Process:      launchd [1]</span><br><span class="line">Coalition:           com.cmcc.enterprise-classID.onecardmultinumber.sdk [8274]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Date/Time:           2018-08-22 15:35:09.3494 +0800</span><br><span class="line">Launch Time:         2018-08-22 15:35:03.3154 +0800</span><br><span class="line">OS Version:          iPhone OS 11.3.1 (15E302)</span><br><span class="line">Baseband Version:    4.56.00</span><br><span class="line">Report Version:      104</span><br><span class="line"></span><br><span class="line">Exception Type:  EXC_CRASH (SIGABRT)</span><br><span class="line">Exception Codes: 0x0000000000000000, 0x0000000000000000</span><br><span class="line">Exception Note:  EXC_CORPSE_NOTIFY</span><br><span class="line">Triggered by Thread:  0</span><br><span class="line"></span><br><span class="line">Application Specific Information:</span><br><span class="line">abort() called</span><br><span class="line"></span><br><span class="line">Filtered syslog:</span><br><span class="line">None found</span><br><span class="line"></span><br><span class="line">Last Exception Backtrace:</span><br><span class="line">0   CoreFoundation                0x184152d8c __exceptionPreprocess + 228</span><br><span class="line">1   libobjc.A.dylib               0x18330c5ec objc_exception_throw + 55</span><br><span class="line">2   CoreFoundation                0x1840eb750 _CFThrowFormattedException + 111</span><br><span class="line">3   CoreFoundation                0x18401b90c -[__NSArrayI objectAtIndex:] + 131</span><br><span class="line">4   testImageSourceCode           0x100d55ee4 _hidden#0_ + 24292 (__hidden#4_:14)</span><br><span class="line">5   testImageSourceCode           0x100d5ed6c _hidden#425_ + 60780 (__hidden#452_:131)</span><br><span class="line">6   UIKit                         0x18de826c8 -[UIApplication sendAction:to:from:forEvent:] + 95</span><br><span class="line">7   UIKit                         0x18dfa38a4 -[UIControl sendAction:to:forEvent:] + 79</span><br><span class="line">8   UIKit                         0x18de8877c -[UIControl _sendActionsForEvents:withEvent:] + 439</span><br><span class="line">9   UIKit                         0x18dfbe1dc -[UIControl touchesEnded:withEvent:] + 571</span><br><span class="line">10  UIKit                         0x18df05a48 -[UIWindow _sendTouchesForEvent:] + 2427</span><br><span class="line">11  UIKit                         0x18defa8f8 -[UIWindow sendEvent:] + 3159</span><br><span class="line">12  UIKit                         0x18def9238 -[UIApplication sendEvent:] + 339</span><br><span class="line">13  UIKit                         0x18e6dac0c __dispatchPreprocessedEventFromEventQueue + 2339</span><br><span class="line">14  UIKit                         0x18e6dd1b8 __handleEventQueueInternal + 4743</span><br><span class="line">15  UIKit                         0x18e6d6258 __handleHIDEventFetcherDrain + 151</span><br><span class="line">16  CoreFoundation                0x1840fb404 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 23</span><br><span class="line">17  CoreFoundation                0x1840fac2c __CFRunLoopDoSources0 + 275</span><br><span class="line">18  CoreFoundation                0x1840f879c __CFRunLoopRun + 1203</span><br><span class="line">19  CoreFoundation                0x184018da8 CFRunLoopRunSpecific + 551</span><br><span class="line">20  GraphicsServices              0x185ffb020 GSEventRunModal + 99</span><br><span class="line">21  UIKit                         0x18dff978c UIApplicationMain + 235</span><br><span class="line">22  testImageSourceCode           0x100d75ca8 main + 154792 (__hidden#956_:14)</span><br><span class="line">23  libdyld.dylib                 0x183aa9fc0 start + 3</span><br></pre></td></tr></table></figure><p>看到上面的奔溃信息我们是一脸懵逼的，完全看不出是因为哪里的代码导致了错误，这个时候我们就要进行符号化，通过dSYM文件通过奔溃信息的地址找到源码中奔溃的地方。这个我们放到第三点来讲，下面我们先将第二个方案。</p><h2 id="收集Crash信息"><a href="#收集Crash信息" class="headerlink" title="收集Crash信息"></a>收集Crash信息</h2><p>在iOS中，系统给我们提供了<code>NSException</code>这个类来帮助我们收集异常信息。</p><blockquote><p>NSException is used to implement exception handling and contains information about an exception — Apple Documentation.</p></blockquote><p>我们可以看一下这个类里面都包含什么属性和方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface NSException : NSObject &lt;NSCopying, NSCoding&gt; &#123;</span><br><span class="line">    @private</span><br><span class="line">    NSString*name;</span><br><span class="line">    NSString*reason;</span><br><span class="line">    NSDictionary*userInfo;</span><br><span class="line">    idreserved;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSException *)exceptionWithName:(NSExceptionName)name reason:(nullable NSString *)reason userInfo:(nullable NSDictionary *)userInfo;</span><br><span class="line">- (instancetype)initWithName:(NSExceptionName)aName reason:(nullable NSString *)aReason userInfo:(nullable NSDictionary *)aUserInfo NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">@property (readonly, copy) NSExceptionName name;</span><br><span class="line">@property (nullable, readonly, copy) NSString *reason;</span><br><span class="line">@property (nullable, readonly, copy) NSDictionary *userInfo;</span><br><span class="line"></span><br><span class="line">@property (readonly, copy) NSArray&lt;NSNumber *&gt; *callStackReturnAddresses API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line">@property (readonly, copy) NSArray&lt;NSString *&gt; *callStackSymbols API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));</span><br><span class="line"></span><br><span class="line">- (void)raise;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>我们来看看几个比较重要的属性和方法：<br>例如我们碰到一个<code>name: @&quot;NSRangeException&quot; - reason: @&quot;*** -[__NSArrayI objectAtIndex:]: index 3 beyond bounds [0 .. 1]&quot;</code>这样的错误</p><blockquote><ol><li>name : exception的名字，在上面中就是NSRangeException</li><li>reason : exception的原因，这是我们修复的最主要的提示。也就是上面的[__NSArrayI objectAtIndex:]: index 3 beyond bounds [0 .. 1]。</li><li>userInfo : 其他信息，一般用于自定义的时候传递一些其他的信息。</li><li>callStackSymbols : 这个产生Exception的调用栈，从下到上。</li><li>raise方法，这个方法就是让系统产生Exception，例如我们的APP如果检测到正在被其他不怀好意的人调试的时候，可以创建一个NSException的方法，然后调用raise直接闪退，不过他也有可能hook了这个方法，这里就不多说了。</li></ol></blockquote><p>既然我们知道了有这么一个类，那我们如何来捕捉系统异常呢，Crash分为两种，一种是由EXC_BAD_ACCESS引起的，原因是访问了不属于本进程的内存地址，有可能是访问已被释放的内存；另一种是未被捕获的Objective-C异常（NSException），导致程序向自身发送了SIGABRT信号而崩溃。其实对于未捕获的Objective-C异常，我们是有办法将它记录下来的。</p><p>我们先说第一种，第一种就是我们上面所说的Exception，系统提供了一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT void NSSetUncaughtExceptionHandler(NSUncaughtExceptionHandler * _Nullable);</span><br></pre></td></tr></table></figure><p>方法来捕获异常，这个方法一般会在程序启动的时候就调用一次，这样才能保证捕获所有的异常。<br>在APPDelegate的didFinishLaunch方法中 调用  <code>NSSetUncaughtExceptionHandler(&amp;CrashExceptionHandler);</code><br>然后增加一个方法的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void CrashExceptionHandler(NSException *exception)&#123;</span><br><span class="line">    NSArray *callStack = [exception callStackSymbols];</span><br><span class="line">    NSString *reson = [exception reason];</span><br><span class="line">    NSString *name = [exception name];</span><br><span class="line">   //TODO: 保存奔溃信息到本地，下次启动的时候上传到服务器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看看第二种异常，这种异常通过上面的方法无法捕捉，但是系统会发送一个信号，我们可以通过注册对应的Signal信息来监听是否捕捉到系统发出的异常信号。</p><p>同样是在APPDelaget中加入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGABRT, SignalExceptionHandler);</span><br><span class="line">signal(SIGILL, SignalExceptionHandler);</span><br><span class="line">signal(SIGSEGV, SignalExceptionHandler);</span><br><span class="line">signal(SIGFPE, SignalExceptionHandler);</span><br><span class="line">signal(SIGBUS, SignalExceptionHandler);</span><br><span class="line">signal(SIGPIPE, SignalExceptionHandler);</span><br></pre></td></tr></table></figure><p>然后实现 <code>SignalExceptionHandler</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void SignalExceptionHandler(int signal)&#123;</span><br><span class="line">    NSArray *callStack = [LMExceptionHandler backtrace];</span><br><span class="line">    NSLog(@&quot;信号捕获崩溃，堆栈信息：%@&quot;,callStack);</span><br><span class="line">    NSString *name = LMSignalException;</span><br><span class="line">    NSString *reason = [NSString stringWithFormat:@&quot;signal %d was raised&quot;,signal];</span><br><span class="line">    //TODO: 保存信息上传到本地</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSArray *)backtrace</span><br><span class="line">&#123;</span><br><span class="line">    void* callstack[128];</span><br><span class="line">    int frames = backtrace(callstack, 128);</span><br><span class="line">    char **strs = backtrace_symbols(callstack, frames);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];</span><br><span class="line">    for (int i = 0; i &lt; frames; i++) &#123;</span><br><span class="line">        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    free(strs);</span><br><span class="line">    </span><br><span class="line">    return backtrace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上的方法我们已经可以捕获到系统的crash信息，从而根据信息修复相关的bug。</p><h2 id="通过Xcode查看Crash信息"><a href="#通过Xcode查看Crash信息" class="headerlink" title="通过Xcode查看Crash信息"></a>通过Xcode查看Crash信息</h2><p>如果奔溃发生在我们测试的设备上面，那么奔溃信息是保存到我们手机本地的，这个时候我们可以通过xcode来查看。</p><p>手机连接电脑，然后打开Xcode，点击Window-&gt;Devices And Simulators-&gt;左侧选择对应的设备，然后右侧点击View Device Logs，然后就可以看到以下的奔溃信息，你可以在搜索出对应的APP也可以根据时间来排序找到对应的那一条奔溃信息。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15349278888373.jpg" alt=""></p><p>如上图所示我们其实是看不出具体的错误信息以及堆栈信息的，根据这些我们很难再代码中找到导致奔溃的代码在哪里。接下来我们就要开始通过dSYM文件找到对应的堆栈。</p><h2 id="dSYM"><a href="#dSYM" class="headerlink" title="dSYM"></a>dSYM</h2><p>进行崩溃分析，首先要弄懂一个概念，就是符号集。</p><blockquote><p>符号集是我们对ipa文件进行打包之后，和.app文件同级的后缀名为.dSYM的文件，这个文件必须使用Xcode进行打包才有。<br>每一个.dSYM文件都有一个UUID，和.app文件中的UUID对应，代表着是一个应用。而.dSYM文件中每一条崩溃信息也有一个单独的UUID，用来和程序的UUID进行校对。<br>我们如果不使用.dSYM文件获取到的崩溃信息都是不准确的。<br>符号集中存储着文件名、方法名、行号的信息，是和可执行文件的16进制函数地址对应的，通过分析崩溃的.Crash文件可以准确知道具体的崩溃信息。<br>我们每次Archive一个包之后，都会随之生成一个dSYM文件。每次发布一个版本，我们都需要备份这个文件，以方便以后的调试。进行崩溃信息符号化的时候，必须使用当前应用打包的电脑所生成的dSYM文件，其他电脑生成的文件可能会导致分析不准确的问题。</p></blockquote><h2 id="符号化crash信息"><a href="#符号化crash信息" class="headerlink" title="符号化crash信息"></a>符号化crash信息</h2><p>当程序崩溃的时候，我们可以获得到崩溃的错误堆栈，但是这个错误堆栈都是0x开头的16进制地址，需要我们使用Xcode自带的atos工具或者<a href="https://github.com/answer-huang/dSYMTools" target="_blank" rel="noopener">dSYMTools</a>来将.Crash和.dSYM文件进行符号化，就可以得到详细崩溃的信息。</p><p>那我们如何得到dSYM文件呢</p><blockquote><p>先打开Xcode，Windows-&gt;Organize-&gt;找到对应的app包，然后右键-&gt;Show in finder,找到appName. xcarchive-&gt;显示包内容-&gt;把dSYMs拷贝出来(或者就在里面操作)。</p></blockquote><p>我们可以新建一个CrashFolder的文件夹，然后将上面的dSYMs文件拷贝到该文件夹中，然后我们还需要找到上面的Crash信息，然后右键导出该Crash信息，同样拷贝到CrashFolder文件夹中，接下来我们就可以利用atos来将Crash文件中的地址还原为代码。</p><p>atos的基本用法为：</p><p><code>$ atos -arch &lt;Binary Architecture&gt; -o &lt;Path to dSYM file&gt;/Contents/Resources/DWARF/&lt;binary image name&gt; -l &lt;load address&gt; &lt;address to symbolicate&gt;</code></p><p>在我本地中，我执行的是：<code>atos -arch arm64 -o testImageSourceCode.app.dSYM/Contents/Resources/DWARF/testImageSourceCode -l 0x100d50000 0x100d55ee4</code></p><p>在上述命令中，需要解释的可能就是-l后面的两个参数，第一个参数是程序的基地址，也就是在crash文件中，在 <code>Binary Images:</code>下面的第一行中的第一个以0X开头的地址，然后第二个参数就是Crash文件中错误信息的地址，执行完上述命令之后输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[LMTool test] (in testImageSourceCode) (LMTool.m:15)</span><br></pre></td></tr></table></figure><p>字符串，该字符串就是对应代码中的方法以及对应的文件里面的行数。</p><p>另外一个方法就是使用一个第三方工具<a href="https://github.com/answer-huang/dSYMTools" target="_blank" rel="noopener">dSYMTools</a>这里的用法和我们上述的差不多，只不过那里是可视化工具。</p><p>完整的<a href="https://github.com/codemonkeybulucck/CrashCatchDemo" target="_blank" rel="noopener">demo</a>已经上传到Github。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>NSRunLoop与iOS中的倒计时（GCD,CADisplaylink,NSTimer）</title>
      <link href="/2018/08/20/iOS%20%E5%BC%80%E5%8F%91/NSRunLoop%E4%B8%8EiOS%E4%B8%AD%E7%9A%84%E5%80%92%E8%AE%A1%E6%97%B6%EF%BC%88GCD-CADisplaylink-NSTimer%EF%BC%89/"/>
      <url>/2018/08/20/iOS%20%E5%BC%80%E5%8F%91/NSRunLoop%E4%B8%8EiOS%E4%B8%AD%E7%9A%84%E5%80%92%E8%AE%A1%E6%97%B6%EF%BC%88GCD-CADisplaylink-NSTimer%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>相信在iOS开发中大家都用过倒计时的功能，而NSTimer也是大家用得最多用来实现该功能的类，但是可能有人不太清楚NSTimer存在计时不准并且可能会导致引用循环资源无法释放的情况，接下来我会介绍一下使用GCD以及CADisplaylink来实现倒计时以及他们三者的利弊。</p><h2 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h2><p>在开始介绍下面三种方法之前，我想我们有必要先来介绍一下RunLoop，因为CADisplaylink和NSTimer都是需要通过运行在RunLoop里面才保证了每次到特定的时间点就会执行对应的事件</p><a id="more"></a><h2 id="RunLoop是什么"><a href="#RunLoop是什么" class="headerlink" title="RunLoop是什么"></a>RunLoop是什么</h2><p>一般来说线程只能执行一次任务，执行完任务之后就会退出，可是如果需要处理多个任务呢，那就需要RunLoop来保证线程能随时处理事件并且不会退出。</p><p>RunLoop实际上像是一个对象，该对象提供了一个入口函数，该入口函数会实现像不断的循环获取任务执行任务的功能，当线程执行了这个入口函数之后，就会一直处于函数内部：接受任务-&gt;等待-&gt;处理这样的循环中，知道接受到quit消息，就会推出该入口函数，然后线程销毁。</p><h2 id="RunLoop和线程之间的关系"><a href="#RunLoop和线程之间的关系" class="headerlink" title="RunLoop和线程之间的关系"></a>RunLoop和线程之间的关系</h2><p>RunLoop和线程是一一对应的，它们通过key-value的形式保存在一个全局的字典里面（key是p_thread,value是CFRunLoopRef），iOS中不允许直接创建RunLoop，可以通过两个方法获取RunLoop ，CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个方法内部会调用<code>CFRunLoopRef _CFRunLoopGet(pthread_t thread)</code>方法，调用该方法时，会优先判断该字典是不是为空，如果是的话就创建一个以pthread_main_thread_np()为key的runloop并且放到字典里面。然后在字典中寻找thread为key的runloop，如果不存在则创建一个新的RunLoop并且注册一个回调，当线程销毁时，也销毁RunLoop。</p><h2 id="RunLoopMode"><a href="#RunLoopMode" class="headerlink" title="RunLoopMode"></a>RunLoopMode</h2><p>苹果提供了两个公开的RunLoopMode，NSDefaultRunLoop以及UITrackingRunLoopMode，第一个mode程序默认的mode，当程序中有ScrollView滚动的时候，RunLoop就会将当前的mode切换为UITrackingRunLoopMode。</p><blockquote><p>相信很多人都有过NSTimer在默认情况下可用，当APP有ScrollView在滚动的时候就不可用的回调，那是因为NSTimer加到runloop里面的时候默认是NSDefaultRunLoop，当页面滑动的时候RunLoop切换到了UITrackingRunLoopMode，所以timer就不起作用了，这个时候需要使用<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code>将timer标记为NSRunLoopCommonModes，NSRunLoopCommonModes默认是包含了NSDefaultRunLoop和UITrackingRunLoopMode两个model。</p></blockquote><h2 id="RunLoop的结构"><a href="#RunLoop的结构" class="headerlink" title="RunLoop的结构"></a>RunLoop的结构</h2><p>我们首先来看一下RunLoop的都包含什么东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_CFRunLoop:</p><ul><li><p>_commonModes： 一个标记为common的集合，通过<code>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</code>可以将一个mode加到commonModes里面，当RunLoop的内容变化的时候，RunLoop都会将Timer/Observer/Sources同步到标记为“common”的Mode里面</p></li><li><p>_commonModeItems： 被加到CommonModes里面的所有的Item的集合，一个Item包含_source0,_source1,_observers，_timers。</p></li><li><p>_currentMode： 当前RunLoop的mode，可以通过 <code>CFRunLoopRunInMode(CFStringRef modeName, ...);</code>来切换mode</p></li><li><p>_modes：RunLoop包含的mode</p></li></ul><p>_CFRunLoopMode:</p><ul><li><p>source0(CFRunLoopSourceRef)： mode的事件源，source0只包含一个回调（函数指针），它并不会自动触发，需要先调用 <code>CFRunLoopSourceSinal(source)</code>将source标为待处理，然后调用<code>CFRunLoopSourceWakeUp(source)</code>来唤醒RunLoop才会调用这个方法。</p></li><li><p>_sources1(CFRunLoopSourceRef)： mode的另外一个事件源，source1包含了回调以及一个mach-port，被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程</p></li><li><p>_timers: 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）</p></li><li><p>_observers: 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</p></li></ul><p>更多的关于RunLoop的内容可以看<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p><h2 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h2><p>我们通常会使用以下的代码来创建一个Timer并且将Timer加到RunLoop里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sellf.timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(doSomeThing) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p>以上的代码会有两个问题：</p><ol><li>内存泄漏的问题，首先RunLoop会强引用timer，而timer会强引用self,所以timer不释放的时候，self也无法释放。通常我们会用以下的代码来释放Timer，但是需要找一个合适的时机去释放它，加入我们像以下代码那样在viewWillDisapper那样释放它，当回到主屏幕的时候那timer又要被销毁了，然后重新进入重新创建一个timer，这样就会非常麻烦，需要多个地方维护timer的状态。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillDisappear:(BOOL)animated&#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    self.timer  = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显我们这里要解决的就是timer的释放时机的问题，我们当然是希望持有timer的视图控制器执行dealloc释放的时候释放它，但是这时候千万别企图在dealloc方法里面做这个事情，原因自己想。</p><p>我们的思路就是通过创建一个MagicClass来弱应用这个target，然后timer的target强引用这个MagicClass，执行MagicClass的一个替身Action，在这个Action里面我们可以判断target是不是被销毁了（因为这个时候没有Timer强引用它，所以不会有有内存泄漏的问题），然后没有被销毁则执行真正的Action，如果Target已经被销毁了则调用invalidate销毁timer。</p><p>here is the code</p><p>NSTimer+LMExtension.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSTimer (LMExtension)</span><br><span class="line">+ (instancetype)lmScheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)target selector:(SEL)selector userInfo:(id)userInfo;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>NSTimer+LMExtension.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSTimer+LMExtension.h&quot;</span><br><span class="line"></span><br><span class="line">@interface LMMagicTarget : NSObject</span><br><span class="line">@property (nonatomic, weak) id target;</span><br><span class="line">@property (nonatomic, assign) SEL selector;</span><br><span class="line">@property (nonatomic, weak) NSTimer *timer;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation LMMagicTarget</span><br><span class="line">- (void)LMTimerStarAction:(NSTimer *)timer</span><br><span class="line">&#123;</span><br><span class="line">    if (self.target) &#123;</span><br><span class="line">        [self.target performSelector:self.selector withObject:timer afterDelay:0.0];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.timer invalidate];</span><br><span class="line">        self.timer = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation NSTimer (LMExtension)</span><br><span class="line">+ (instancetype)lmScheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)target selector:(SEL)selector userInfo:(id)userInfo&#123;</span><br><span class="line">    LMMagicTarget *magicTarget = [[LMMagicTarget alloc]init];</span><br><span class="line">    magicTarget.target = target;</span><br><span class="line">    magicTarget.selector = selector;</span><br><span class="line">    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:interval target:magicTarget selector:@selector(LMTimerStarAction:) userInfo:nil repeats:YES];</span><br><span class="line">    magicTarget.timer = timer;</span><br><span class="line">    return  timer;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ol start="2"><li>第二个问题，精度问题。NSTimer其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的，一个timer注册好后，RunLoop会在其重复的时间点注册事件，但是如果这个时候RunLoop正在处理一个其他任务的时候，错过了该事件点，则该次不会执行timer的事件源，会跳过当前时间点，直到下一个时间点才执行该timer的事件源。所以timer会有一个Tolerance的属性，这属性就是宽容度，该属性标记当时间点到了后，容许有多少的误差。</li></ol><h2 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h2><p>CADisplayLink是一个以屏幕刷新频率同步的计时器。以下是创建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建方法</span><br><span class="line">self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink:)];    </span><br><span class="line">[self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">停止方法</span><br><span class="line">[self.displayLink invalidate];  </span><br><span class="line">self.displayLink = nil;</span><br></pre></td></tr></table></figure><p>CADisplayLink的计算时间并不依靠RunLoop，当一个屏幕刷新完成时候则会通知RunLoop给对应的target执行action。但是CADisplayLink依然会有精度的问题，当两次界面刷新之间执行了一次长任务的时候，那就会有一帧被跳过去，也就是所谓的掉帧，那相应的此次也不会调用target的action。</p><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>GCD提供了一个计时的方法，GCD定时器的底层是由XNU内核中的select方法实现的。具体的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW , 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</span><br><span class="line">    dispatch_source_set_event_handler(self.timer, ^&#123;</span><br><span class="line">        NSLog(@&quot;GCD&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    //开启定时器</span><br><span class="line">    dispatch_resume(self.timer);</span><br><span class="line">    </span><br><span class="line">    //销毁定时器</span><br><span class="line">    dispatch_source_cancel(self.timer);</span><br><span class="line">    self.timer = nil;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果是对时间的要求不精确的计算，可以使用NSTimer，如果是对时间比较精确的，可以使用GCD提供的倒计时方法。如果是实现动画，需要高频率的绘制，可以使用CADisplayLink。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>图文混排的四种方案</title>
      <link href="/2018/08/15/iOS%20%E5%BC%80%E5%8F%91/%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
      <url>/2018/08/15/iOS%20%E5%BC%80%E5%8F%91/%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>图文混排有多种方式可以实现，下面我会用四种不同的方式来实现以下界面的效果，并且说明他们的优缺点。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/screenshot.png" alt="screenshot"></p><h2 id="NSAttributedString"><a href="#NSAttributedString" class="headerlink" title="NSAttributedString"></a>NSAttributedString</h2><blockquote><p>NSAttributedString提供了自由并且多样式的富文本设置，图文混排的实现是通过插入NSTestAttachment来实现。</p></blockquote><a id="more"></a><p>talk is cheap ，here is the code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//调用</span><br><span class="line">NSString *originStr = @&quot; Hi ALL,这是我的博客：lemon2well.top，欢迎来到我的博客，环欢迎评论留言一起交流。&quot;;</span><br><span class="line">    NSString *targetStr = @&quot;lemon2well.top&quot;;</span><br><span class="line">    NSString *imageName = @&quot;trumpet&quot;;</span><br><span class="line">    self.label.attributedText = [self attribuStringWithString:originStr targetString:targetStr image:imageName];</span><br><span class="line"></span><br><span class="line">//方法</span><br><span class="line">- (NSAttributedString*)attribuStringWithString:(NSString*)string targetString:(NSString *)target image:(NSString*)imageName&#123;</span><br><span class="line">    NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc]initWithString:string attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">    </span><br><span class="line">    NSRange linkRange = [string rangeOfString:target];</span><br><span class="line">    if (linkRange.length != 0) &#123;</span><br><span class="line">        //添加可点击链接</span><br><span class="line">        [attributedStr addAttribute:NSLinkAttributeName value:[NSURL URLWithString:@&quot;lemon2well.top&quot;] range:linkRange];</span><br><span class="line">        [attributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:linkRange];</span><br><span class="line">        //添加下划线</span><br><span class="line">        [attributedStr addAttribute:NSUnderlineStyleAttributeName value:@1 range:linkRange];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //添加图片</span><br><span class="line">    NSTextAttachment *attachment = [[NSTextAttachment alloc]init];</span><br><span class="line">    attachment.image = [UIImage imageNamed:imageName];</span><br><span class="line">    attachment.bounds = CGRectMake(0, 0, 20 ,20);</span><br><span class="line">    NSAttributedString *imageStr = [NSAttributedString attributedStringWithAttachment:attachment];</span><br><span class="line">    //插入图片</span><br><span class="line">    [attributedStr insertAttributedString:imageStr atIndex:0];</span><br><span class="line">    </span><br><span class="line">    // 段落样式</span><br><span class="line">    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init];</span><br><span class="line">    // 行间距</span><br><span class="line">    [style setLineSpacing:3];</span><br><span class="line">    // 段落间距</span><br><span class="line">    [style setParagraphSpacing:10];</span><br><span class="line">    // 首行缩进</span><br><span class="line">    [style setFirstLineHeadIndent:25];</span><br><span class="line">    [attributedStr addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, string.length-1)];</span><br><span class="line">    </span><br><span class="line">    return attributedStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是NSAttributedString的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// NSFontAttributeName                设置字体属性，默认值：字体：Helvetica(Neue) 字号：12</span><br><span class="line">// NSForegroundColorAttributeNam      设置字体颜色，取值为 UIColor对象，默认值为黑色</span><br><span class="line">// NSBackgroundColorAttributeName     设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色</span><br><span class="line">// NSLigatureAttributeName            设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符</span><br><span class="line">// NSKernAttributeName                设定字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄</span><br><span class="line">// NSStrikethroughStyleAttributeName  设置删除线，取值为 NSNumber 对象（整数）</span><br><span class="line">// NSStrikethroughColorAttributeName  设置删除线颜色，取值为 UIColor 对象，默认值为黑色</span><br><span class="line">// NSUnderlineStyleAttributeName      设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似</span><br><span class="line">// NSUnderlineColorAttributeName      设置下划线颜色，取值为 UIColor 对象，默认值为黑色</span><br><span class="line">// NSStrokeWidthAttributeName         设置笔画宽度，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果</span><br><span class="line">// NSStrokeColorAttributeName         填充部分颜色，不是字体颜色，取值为 UIColor 对象</span><br><span class="line">// NSShadowAttributeName              设置阴影属性，取值为 NSShadow 对象</span><br><span class="line">// NSTextEffectAttributeName          设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用：</span><br><span class="line">// NSBaselineOffsetAttributeName      设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏</span><br><span class="line">// NSObliquenessAttributeName         设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾</span><br><span class="line">// NSExpansionAttributeName           设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本</span><br><span class="line">// NSWritingDirectionAttributeName    设置文字书写方向，从左向右书写或者从右向左书写</span><br><span class="line">// NSVerticalGlyphFormAttributeName   设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本</span><br><span class="line">// NSLinkAttributeName                设置链接属性，点击后调用浏览器打开指定URL地址</span><br><span class="line">// NSAttachmentAttributeName          设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排</span><br><span class="line">// NSParagraphStyleAttributeName      设置文本段落排版格式，取值为 NSParagraphStyle 对象</span><br></pre></td></tr></table></figure><p>NSParagraphStyle的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];  </span><br><span class="line">paragraphStyle.lineSpacing = 10;// 字体的行间距  </span><br><span class="line">paragraphStyle.firstLineHeadIndent = 20.0f;//首行缩进  </span><br><span class="line">paragraphStyle.alignment = NSTextAlignmentJustified;//（两端对齐的）文本对齐方式：（左，中，右，两端对齐，自然）  </span><br><span class="line">paragraphStyle.lineBreakMode = NSLineBreakByTruncatingTail;//结尾部分的内容以……方式省略 ( &quot;...wxyz&quot; ,&quot;abcd...&quot; ,&quot;ab...yz&quot;)  </span><br><span class="line">paragraphStyle.headIndent = 20;//整体缩进(首行除外)  </span><br><span class="line">paragraphStyle.tailIndent = 20;//  </span><br><span class="line">paragraphStyle.minimumLineHeight = 10;//最低行高  </span><br><span class="line">paragraphStyle.maximumLineHeight = 20;//最大行高  </span><br><span class="line">paragraphStyle.paragraphSpacing = 15;//段与段之间的间距  </span><br><span class="line">paragraphStyle.paragraphSpacingBefore = 22.0f;//段首行空白空间/* Distance between the bottom of the previous paragraph (or the end of its paragraphSpacing, if any) and the top of this paragraph. */  </span><br><span class="line">paragraphStyle.baseWritingDirection = NSWritingDirectionLeftToRight;//从左到右的书写方向（一共➡️三种）  </span><br><span class="line">paragraphStyle.lineHeightMultiple = 15;/* Natural line height is multiplied by this factor (if positive) before being constrained by minimum and maximum line height. */  </span><br><span class="line">paragraphStyle.hyphenationFactor = 1;//连字属性 在iOS，唯一支持的值分别为0和1</span><br></pre></td></tr></table></figure><h2 id="TextView-UIImageview"><a href="#TextView-UIImageview" class="headerlink" title="TextView + UIImageview"></a>TextView + UIImageview</h2><blockquote><p> 以上的效果同样可以使用UITextView + UIImageView来实现，该方法主要利用了textview的textContainer.exclusionPaths属性</p></blockquote><p>// Default value : empty array  An array of UIBezierPath representing the exclusion paths inside the receiver’s bounding rect.<br>@property (copy, NS_NONATOMIC_IOSONLY) NSArray<uibezierpath *=""> *exclusionPaths NS_AVAILABLE(10_11, 7_0);</uibezierpath></p><p>按照文档的说明我们可以提供一个元素为UIBezierPath的数组，这样文字的描绘就会避开这些路径。从而实现图文混排的效果。不过这种方式最适合用于文字环绕的效果，所有的文字把图片包围住。</p><p>here is the code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 调用</span><br><span class="line"> UITextView *textView = [[UITextView alloc]init];</span><br><span class="line">    textView.frame = CGRectMake(20, 200, 335, 150);</span><br><span class="line">    textView.attributedText = [self textViewAttributestring];</span><br><span class="line">    [textView sizeToFit];</span><br><span class="line">    [self.view addSubview:textView];</span><br><span class="line">    self.textView = textView;</span><br><span class="line">    </span><br><span class="line">    UIImageView *imageView = [[UIImageView alloc]init];</span><br><span class="line">    imageView.frame = CGRectMake(45, 210, 20, 20);</span><br><span class="line">    imageView.image = [UIImage imageNamed:@&quot;trumpet&quot;];</span><br><span class="line">    [self.view addSubview:imageView];</span><br><span class="line">    self.imageView = imageView;</span><br><span class="line">    textView.textContainer.exclusionPaths = @[[self translatedBezierPath]];</span><br><span class="line">    </span><br><span class="line">//方法：</span><br><span class="line">- (UIBezierPath *)translatedBezierPath</span><br><span class="line">&#123;</span><br><span class="line">    //计算出imageView相对于textView的相对坐标</span><br><span class="line">    CGRect imageRect = [self.textView</span><br><span class="line">                        convertRect:self.imageView.frame fromView:self.view];</span><br><span class="line">    UIBezierPath *bezierPath = [UIBezierPath bezierPathWithRect:CGRectMake(imageRect.origin.x, imageRect.origin.y-10, imageRect.size.width, imageRect.size.height)];</span><br><span class="line">    return bezierPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSAttributedString*)textViewAttributestring&#123;</span><br><span class="line">    NSString *originStr = @&quot; Hi ALL,这是我的博客：lemon2well.top，欢迎来到我的博客，环欢迎评论留言一起交流。&quot;;</span><br><span class="line">    NSString *targetStr = @&quot;lemon2well.top&quot;;</span><br><span class="line">    </span><br><span class="line">    NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc]initWithString:originStr attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">    </span><br><span class="line">    NSRange linkRange = [originStr rangeOfString:targetStr];</span><br><span class="line">    if (linkRange.length != 0) &#123;</span><br><span class="line">        //添加可点击链接</span><br><span class="line">        [attributedStr addAttribute:NSLinkAttributeName value:[NSURL URLWithString:targetStr] range:linkRange];</span><br><span class="line">        [attributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:linkRange];</span><br><span class="line">        //添加下划线</span><br><span class="line">        [attributedStr addAttribute:NSUnderlineStyleAttributeName value:@1 range:linkRange];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 段落样式</span><br><span class="line">    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init];</span><br><span class="line">    // 行间距</span><br><span class="line">    [style setLineSpacing:3];</span><br><span class="line">    // 段落间距</span><br><span class="line">    [style setParagraphSpacing:10];</span><br><span class="line">    // 首行缩进</span><br><span class="line">    [style setFirstLineHeadIndent:25];</span><br><span class="line">    [attributedStr addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, originStr.length-1)];</span><br><span class="line">    </span><br><span class="line">    return attributedStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CoreText"><a href="#CoreText" class="headerlink" title="CoreText"></a>CoreText</h2><p>coreText给我的感觉就是太难用了，但是可创造性又很高，因为CoreText是属于比较底层的框架，所以基本上都是使用的C的方法，CoreText可以实现很复杂的图文混排而且渲染速度更快。</p><p>CoreText来实现图文混排实际上分为以下的几步:</p><blockquote><p>获得上下文，翻转坐标系 -&gt; 创建NSAttributeString -&gt; 创建空白占位图片，创建代理 -&gt; 实现代理 -&gt; 创建CTFrameRef,CTFrameDraw绘制 -&gt; 计算图片坐标，CGContextDrawImage绘制 -&gt; 释放资源</p></blockquote><p><img src="http://pcd17v2u0.bkt.clouddn.com/15343172514431.jpg" alt=""></p><blockquote></blockquote><p>CFAttributedStringRef ：属性字符串，用于存储需要绘制的文字字符和字符属性<br>CTFramesetterRef：通过CFAttributedStringRef进行初始化，作为CTFrame对象的生产工厂，负责根据path创建对应的CTFrame<br>CTFrame：用于绘制文字的类，可以通过CTFrameDraw函数，直接将文字绘制到context上<br>CTLine：在CTFrame内部是由多个CTLine来组成的，每个CTLine代表一行<br>CTRun：每个CTLine又是由多个CTRun组成的，每个CTRun代表一组显示风格一致的文本<br>实际上CoreText是不直接支持绘制图片的，但是我们可以先在需要显示图片的地方用一个特殊的空白占位符代替，同时设置该字体的CTRunDelegate信息为要显示的图片的宽度和高度，这样绘制文字的时候就会先把图片的位置留出来，再在drawRect方法里面用CGContextDrawImage绘制图片。</p><p>Here is the code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">-(void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);</span><br><span class="line">    CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">    NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot; Hi ALL,这是我的博客：lemon2well.top，欢迎来到我的博客，环欢迎评论留言一起交流。&quot; attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">    NSString *targetStr = @&quot;lemon2well.top&quot;;</span><br><span class="line">    </span><br><span class="line">    NSRange linkRange = [attributeStr.string rangeOfString:targetStr];</span><br><span class="line">    if (linkRange.length != 0) &#123;</span><br><span class="line">        //添加可点击链接</span><br><span class="line">        [attributeStr addAttribute:NSLinkAttributeName value:[NSURL URLWithString:targetStr] range:linkRange];</span><br><span class="line">        [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:linkRange];</span><br><span class="line">        //添加下划线</span><br><span class="line">        [attributeStr addAttribute:NSUnderlineStyleAttributeName value:@1 range:linkRange];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 段落样式</span><br><span class="line">    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init];</span><br><span class="line">    // 行间距</span><br><span class="line">    [style setLineSpacing:3];</span><br><span class="line">    // 段落间距</span><br><span class="line">    [style setParagraphSpacing:10];</span><br><span class="line">    // 首行缩进</span><br><span class="line">    [style setFirstLineHeadIndent:25];</span><br><span class="line">    [attributeStr addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, attributeStr.length-1)];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    CTRunDelegateCallbacks callBacks;</span><br><span class="line">    memset(&amp;callBacks,0,sizeof(CTRunDelegateCallbacks));</span><br><span class="line">    callBacks.version = kCTRunDelegateVersion1;</span><br><span class="line">    callBacks.getAscent = ascentCallBacks;</span><br><span class="line">    callBacks.getDescent = descentCallBacks;</span><br><span class="line">    callBacks.getWidth = widthCallBacks;</span><br><span class="line">    NSDictionary * dicPic = @&#123;@&quot;height&quot;:@16,@&quot;width&quot;:@16&#125;;</span><br><span class="line">    CTRunDelegateRef delegate = CTRunDelegateCreate(&amp; callBacks, (__bridge void *)dicPic);</span><br><span class="line">    unichar placeHolder = 0xFFFC;</span><br><span class="line">    NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];</span><br><span class="line">    NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];</span><br><span class="line">    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);</span><br><span class="line">    CFRelease(delegate);</span><br><span class="line">    [attributeStr insertAttributedString:placeHolderAttrStr atIndex:0];</span><br><span class="line">    CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);</span><br><span class="line">    CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">    CGPathAddRect(path, NULL, self.bounds);</span><br><span class="line">    NSInteger length = attributeStr.length;</span><br><span class="line">    CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, length), path, NULL);</span><br><span class="line">    CTFrameDraw(frame, context);</span><br><span class="line">    </span><br><span class="line">    UIImage * image = [UIImage imageNamed:@&quot;trumpet&quot;];</span><br><span class="line">    CGRect imgFrm = [self calculateImageRectWithFrame:frame];</span><br><span class="line">    CGContextDrawImage(context,imgFrm, image.CGImage);</span><br><span class="line">    CFRelease(frame);</span><br><span class="line">    CFRelease(path);</span><br><span class="line">    CFRelease(frameSetter);</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat ascentCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;height&quot;] floatValue];</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat descentCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat widthCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">    return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;width&quot;] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(CGRect)calculateImageRectWithFrame:(CTFrameRef)frame</span><br><span class="line">&#123;</span><br><span class="line">    NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);</span><br><span class="line">    NSInteger count = [arrLines count];</span><br><span class="line">    CGPoint points[count];</span><br><span class="line">    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);</span><br><span class="line">    for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">        CTLineRef line = (__bridge CTLineRef)arrLines[i];</span><br><span class="line">        NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);</span><br><span class="line">        for (int j = 0; j &lt; arrGlyphRun.count; j ++) &#123;</span><br><span class="line">            CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];</span><br><span class="line">            NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];</span><br><span class="line">            if (delegate == nil) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            NSDictionary * dic = CTRunDelegateGetRefCon(delegate);</span><br><span class="line">            if (![dic isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            CGPoint point = points[i];</span><br><span class="line">            CGFloat ascent;</span><br><span class="line">            CGFloat descent;</span><br><span class="line">            CGRect boundsRun;</span><br><span class="line">            boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</span><br><span class="line">            boundsRun.size.height = ascent + descent;</span><br><span class="line">            CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</span><br><span class="line">            boundsRun.origin.x = point.x + xOffset;</span><br><span class="line">            boundsRun.origin.y = point.y - descent;</span><br><span class="line">            CGPathRef path = CTFrameGetPath(frame);</span><br><span class="line">            CGRect colRect = CGPathGetBoundingBox(path);</span><br><span class="line">            CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);</span><br><span class="line">            return imageBounds;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return CGRectZero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="YYText"><a href="#YYText" class="headerlink" title="YYText"></a>YYText</h2><p><a href="https://github.com/ibireme/YYText" target="_blank" rel="noopener">YYText</a><br>YYText是大神郭曜源开发的一个强大的展示和编辑富文本的第三方工具，里面提供了丰富的与富文本开发相关的方法，具体的可以到github里面看。YYText是基于CoreText向上封装了一层，所以对开发者更加友好，如果在项目中运用到大量的富文本的地方建议可以用YYText。</p><p>here is the code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">YYLabel *label = [[YYLabel alloc]init];</span><br><span class="line">  label.numberOfLines = 0 ;</span><br><span class="line">  label.frame = CGRectMake(0, 200, 375, 200);</span><br><span class="line">  [self.view addSubview:label];</span><br><span class="line">  </span><br><span class="line">  NSString *headStr = @&quot;Hi ALL,这是我的博客：&quot;;</span><br><span class="line">  NSString *linkStr = @&quot;lemon2well.top&quot;;</span><br><span class="line">  NSString *lastStr = @&quot;，欢迎来到我的博客，环欢迎评论留言一起交流。&quot;;</span><br><span class="line">  UIImage *image = [UIImage imageNamed:@&quot;trumpet&quot;];</span><br><span class="line">  </span><br><span class="line">  NSMutableAttributedString *attrText = [NSMutableAttributedString new];</span><br><span class="line">  </span><br><span class="line">  NSAttributedString *headAttr = [[NSAttributedString alloc] initWithString:headStr attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">  </span><br><span class="line">  NSAttributedString *lastAttr = [[NSAttributedString alloc] initWithString:lastStr attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20]&#125;];</span><br><span class="line">  </span><br><span class="line">  NSMutableAttributedString *linkAttr = [[NSMutableAttributedString alloc] initWithString:linkStr];</span><br><span class="line">  linkAttr.yy_font = [UIFont systemFontOfSize:20];</span><br><span class="line">  linkAttr.yy_underlineStyle = NSUnderlineStyleSingle;</span><br><span class="line">  [linkAttr yy_setTextHighlightRange:NSMakeRange(0, linkStr.length) color:[UIColor blueColor] backgroundColor:nil tapAction:^(UIView * _Nonnull containerView, NSAttributedString * _Nonnull text, NSRange range, CGRect rect) &#123;</span><br><span class="line">      NSLog(@&quot;link = %@&quot;,text);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  NSMutableAttributedString *imageAttr = [NSMutableAttributedString yy_attachmentStringWithContent:image contentMode:UIViewContentModeCenter attachmentSize:CGSizeMake(32, 32) alignToFont:[UIFont systemFontOfSize:20] alignment:YYTextVerticalAlignmentCenter];</span><br><span class="line">  </span><br><span class="line">  [attrText appendAttributedString:imageAttr];</span><br><span class="line">  [attrText appendAttributedString:headAttr];</span><br><span class="line">  [attrText appendAttributedString:linkAttr];</span><br><span class="line">  [attrText appendAttributedString:lastAttr];</span><br><span class="line"></span><br><span class="line">  label.attributedText = attrText;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>总的来说，以上说的四种都各有优劣，但是他们都用了NSAttributedString来实现富文本。</p><p>如果在项目中用到富文本的地方不多，出于APP体积考虑没必要引入一个第三方，  可以考虑使用第一和第二种方案，如果是图文环绕这种，可以使用UITextView+UIImageview的方案，如果是小的表情图文混排可以使用NSAttributedString+label即可。</p><p>如果在项目中多处用到富文本的展示和编辑，建议使用YYText，因为它对于开发者更加友好，并且也是基于CoreText来渲染，不过有一点就是目前YYText已经有一年没维护了，之前他生病了，现在正在家里修养，希望他快点好起来，祝好。</p><h2 id="突然有感"><a href="#突然有感" class="headerlink" title="突然有感"></a>突然有感</h2><p>本来这篇文章到这里就应该完了，不过刚刚去看了一下YYKit的作者的<a href="https://blog.ibireme.com/author/ibireme/" target="_blank" rel="noopener">博客</a>，突然有点伤感，没想到他生病这么严重，看他的文字感觉他是一个对待生活也很细腻的人，这也说得通为什么他可以用业余的时间写出了YYKIT这么强大的工具，因为他对待技术也是很细腻。</p><p>真的很佩服这样的人，你可以感受到他的真诚，我虽然没和他聊过天，没见过他真人，不过他一定会是一个让别人感受到交流沟通起来让你没有防御的一个人。现在这个社会因为各种各样变态的人以及事，总会让人无论何时何地总会身上架着一层防御装，更可怕的是还有那种表面善内里恶的人，多可怕，如果是危害别人的人我一点都不心疼。</p><p>最后希望大家一定要注意自己的身体，祝大家都好。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>开发细节之 hash 与 isEqual 方法</title>
      <link href="/2018/08/14/iOS%20%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%BB%86%E8%8A%82%E4%B9%8B-hash-%E4%B8%8E-isEqual-%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/14/iOS%20%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%BB%86%E8%8A%82%E4%B9%8B-hash-%E4%B8%8E-isEqual-%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="isEuqal-与-的区别"><a href="#isEuqal-与-的区别" class="headerlink" title="isEuqal 与 == 的区别"></a>isEuqal 与 == 的区别</h2><p>相信大家都知道在OC中有两种比较是否相等的方法，第一种是直接用<code>==</code>符号比较，第二种是使用isEqual来比较，它们的区别如下：</p><ol><li><code>==</code> 如果是用于基本数据类型的比较，那么直接比较数值，isEqual只能用于OC对象比较</li><li><code>==</code> 如果是用于OC对象比较，那么是判断他们是不是同一个对象，也就是指针所指向的地址是否一致。而isEqual则是比较两个对象是否相同。</li></ol><a id="more"></a><p>接下来用一个颜色的示例来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIColor *color1 = [UIColor colorWithRed:120/255.0 green:120/255.0 blue:120/255.0 alpha:1];</span><br><span class="line">UIColor *color2 = [UIColor colorWithRed:120/255.0 green:120/255.0 blue:120/255.0 alpha:1];</span><br><span class="line">NSLog(@&quot;color1.address = %p\ncolor2.address = %p&quot;,color1,color2);</span><br><span class="line">NSLog(@&quot;color1 == color2 ? %@ &quot;,color1 == color2 ? @&quot;是&quot; : @&quot;否&quot;);</span><br><span class="line">NSLog(@&quot;color1 isEqual color2 ? %@ &quot;,[color1 isEqual:color2] ? @&quot;是&quot; : @&quot;否&quot;);</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color1.address = 0x60400046af40</span><br><span class="line">color2.address = 0x60400046b280</span><br><span class="line">color1 == color2 ? 否</span><br><span class="line">color1 isEqual color2 ? 是</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以看出，color1和color2是两个不同的对象，所以使用<code>==</code>来比较的时候他们不相等。但是color1和color2颜色的值都是一样的，所以使用isEuqal来比较的时候他们是相等的。</p><h2 id="isEuqal-用于自定义对象的比较"><a href="#isEuqal-用于自定义对象的比较" class="headerlink" title="isEuqal 用于自定义对象的比较"></a>isEuqal 用于自定义对象的比较</h2><p>刚刚我们是使用系统的UIColor的对象来比较，如果是我们是自定义的对象，如果需要判断两个对象是否相等的时候，使用isEqual方法来比较是否还起作用呢？</p><p>看看以下代码，我们有一个<code>LMPerson</code>类，里面有两个属性，一个name，一个age，我们创建两个不同的对象，然后给他们赋予同样的name和age，看看使用isEuqal来比较是否相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LMPerson *person1 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line">  LMPerson *person2 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line">  NSLog(@&quot;person1.address = %p\nperson2.address = %p&quot;,person1,person2);</span><br><span class="line">  NSLog(@&quot;person1 == person2 ? %@ &quot;,person1==person2?@&quot;是&quot;:@&quot;否&quot;);</span><br><span class="line">  NSLog(@&quot;person1 isEqual person2 ? %@ &quot;,[person1 isEqual:person2]?@&quot;是&quot;:@&quot;否&quot;);</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.address = 0x60400022b500</span><br><span class="line">person2.address = 0x60400022b200</span><br><span class="line">person1 == person2 ? 否</span><br><span class="line">person1 isEqual person2 ? 否</span><br></pre></td></tr></table></figure><p>通过上面的结果可以看出，当isEqual是用于我们自定义对象的比较的时候，即使我们赋予两个对象属性相同的值，但是返回的却是NO。这是为什么呢？</p><p><strong>这是因为UIColor，NSArray,NSdictonary 系统已经帮我们实现了对应的isEqual或者isEqualTo的方法，所以我们如果要用于自定义对象比较，那么也需要实现对应的isEqual方法，接下来我们给LMPerson添加以下实现方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object&#123;</span><br><span class="line">    if (self == object) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (![object isKindOfClass:LMPerson.class]) &#123;</span><br><span class="line">        return  NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LMPerson *person2 = (LMPerson*)object;</span><br><span class="line">    BOOL isSameName = (!self.name &amp;&amp; !person2.name) || [self.name isEqualToString:person2.name];</span><br><span class="line">    BOOL isSameAge = self.age == person2.age ;</span><br><span class="line">    return isSameName &amp;&amp; isSameAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.address = 0x60000022bac0</span><br><span class="line">person2.address = 0x60000022c460</span><br><span class="line">person1 == person2 ? 否</span><br><span class="line">person1 isEqual person2 ? 是</span><br></pre></td></tr></table></figure><p><strong>综上，如果我们要比较两个自定义对象是否相等的时候我们需要重写isEqual方法，给该方法提供一个实现。</strong></p><h2 id="什么是hash方法"><a href="#什么是hash方法" class="headerlink" title="什么是hash方法"></a>什么是hash方法</h2><p>这个要从hashTable说起，因为hashTabe是无序的集合，并且查找的时间复杂度是O(1)，数组是O(array_lenth)，为什么hashTable可以做到O(1)呢，因为当一个元素加到hashTable里面的时候，会有一个默认的hash值，用于标记元素在table中的位置，后面如果需要查找该元素，通过hash值可以直接找到该元素。</p><p>那么问题来了，这个hash值是怎样得来的呢？</p><p>这个hash值其实就是通过<code>- (NSUInteger)hash</code>方法提供的，并且系统默认的实现就是返回该对象的地址。下面我们来验证这个说法：</p><p>我们增加以下方法，并且打印出hash的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//LMPerson.m</span><br><span class="line">- (NSUInteger)getSuperHash&#123;</span><br><span class="line">    NSUInteger superHash = [super hash];</span><br><span class="line">    return superHash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ViewController</span><br><span class="line">  LMPerson *person1 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line">    LMPerson *person2 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line">    NSLog(@&quot;person1.address = %ld\nperson2.address = %ld&quot;,(NSUInteger)person1,(NSUInteger)person2);</span><br><span class="line">    NSLog(@&quot;person1.hash = %ld\nperson2.hash = %ld&quot;,[person1 getSuperHash],[person2 getSuperHash]);</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1.address = 105553118496736</span><br><span class="line">person2.address = 105553116524864</span><br><span class="line">person1.hash = 105553118496736</span><br><span class="line">person2.hash = 105553116524864</span><br></pre></td></tr></table></figure><p>通过结果我们可以知道，其实系统默认的hash方法就是返回对象地址的十进制。</p><h2 id="什么时候会调用hash-方法"><a href="#什么时候会调用hash-方法" class="headerlink" title="什么时候会调用hash 方法"></a>什么时候会调用hash 方法</h2><p>这里我们直接说结论，如果一个集合中不能出现重复的元素那么就会调用hash方法来判断两个元素是否相等。什么意思呢？</p><p>NSMutableArray和NSArray是允许添加重复元素的，所以将一个元素放到该容器中的时候是不会调用hash方法，像NSSet，NSMutableSet元素不能重复，在添加和删除的时候会调用hash方法。当一个元素作为NSDictonary的key的时候，因为key也不能重复，所以也会调用hash方法。大家可以通过将上述创建的两个person对象分别放到不同的集合中进行验证。</p><p>值得注意的是，就算hash方法相等也不能判断两个元素就一定是相等，还会调用isEqual来进行判断。也就是说，会优先判断hash是否相等，如果hash不相等那么这两个元素一定不相等，如果hash相等，那么就调用isEqual判断两个元素是否相等，如果返回NO，那么两个元素也不相等， 如果返回YES那么两个元素相等。</p><p>也就是说当我们把自定义对象加到NSSet中的或者作为NSDictonary的key的时候 会同时调用hash方法和isEqual方法来判断两个元素是否相等，因此我们需要重写isEqual方法和hash方法。</p><h2 id="hash-的正确使用姿势"><a href="#hash-的正确使用姿势" class="headerlink" title="hash 的正确使用姿势"></a>hash 的正确使用姿势</h2><p>我们在上面已经验证过如果我们使用系统默认的hash方法来比较两个自定义对象是否相等是不正确的了，那么正确的使用姿势是什么呢？</p><p>在<a href="https://nshipster.com/equality/" target="_blank" rel="noopener">Equality</a>这篇文章中，matt大神给了方法，也就是对属性的hash进行异或运算。在<code>LMPerson.m</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash&#123;</span><br><span class="line">    return ([self.name hash] ^ [[NSNumber numberWithInteger:self.age] hash]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们编写以下代码来测试一下相同的元素是否还能加到hashTable里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LMPerson *person1 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line"> LMPerson *person2 = [LMPerson personWithName:@&quot;lemon&quot; age:18];</span><br><span class="line"> LMPerson *person3 = [LMPerson personWithName:@&quot;lemon&quot; age:19];</span><br><span class="line"> NSSet *set = [NSSet setWithObjects:person1,person2, person3,nil];</span><br><span class="line"> NSLog(@&quot;set.count = %ld&quot;,[set count]);</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-08-14 11:08:13.250550+0800 testImageSourceCode[47478:7219161] set.count = 2</span><br></pre></td></tr></table></figure><p>可以看到我们往hashTable里面添加了三个元素，但是第一和第二个元素是相同的，所以最后加到集合里面的只有两个元素，证明hash方法起作用了。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> isEuqal </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>细说HTTP与HTTPS</title>
      <link href="/2018/08/10/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/%E7%BB%86%E8%AF%B4HTTP%E4%B8%8EHTTPS/"/>
      <url>/2018/08/10/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/%E7%BB%86%E8%AF%B4HTTP%E4%B8%8EHTTPS/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网上已经有很多关于HTTP与HTTPS的文章，为什么我还要写这篇文章呢，源于昨天有个iOS开发同学昨天在群里面提了一个问题，如果一个人下载了一个APP，该APP与服务器是HTTPS连接，他不会信任任何来源于不明身份的证书，然后连上了我的WIFI，我有没有办法去破解里面的通信内容?</p><p>接下来我们就带着这个疑问去寻找答案，并且给出我的答案。</p><h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h2><blockquote><p>HTTP(HyperText Transfer Protocol)超文本传输协议，HTTP是七层网络模型中作用在应用层的协议。</p></blockquote><a id="more"></a><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><ol><li>窃听风险（eavesdropping）：第三方可以获知通信内容。</li><li>篡改风险（tampering）：第三方可以修改通信内容。</li><li>冒充风险（pretending）：第三方可以冒充他人身份参与通信。</li></ol><p>因为HTTP是明文传输内容的，所以只要攻击者通过劫持你的WIFI或者你连上了不安全的WIFI那么你所有的传输内容他都可以拿到，接下来就可以篡改里面的数据。基于以上的缺点就有了HTTPS，待会我们再来说这个事儿。</p><h3 id="HTTP的工作流程："><a href="#HTTP的工作流程：" class="headerlink" title="HTTP的工作流程："></a>HTTP的工作流程：</h3><p>相信大家都听说过TCP三次握手，HTTP就是通过TCP三次握手建立连接，值得一提的是HTTP/1.0版本是默认没有复用TCP连接的，每次发送数据都要建立一个连接(需要使用keep-alive来建立长连接)，这样导致了耗时以及占用资源非常严重，后来发布了HTTP/1.1，同一个TCP通道可以复用发送多个请求，但是在该通道里面所有的请求都是按照顺序来发送的发送的，容易导致阻塞。HTTP/2在1.1的基础上改进了，不止复用同一个TCP通道并且可以并发的处理多个请求。</p><p>TCP三次握手，依照惯例，先发一个图片，看图说话</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15338881870637.png" alt=""></p><p>下面来解释一下上面三次握手的作用：</p><p>第一次握手：客户端发送将SYN标志位设置为1，并且随机产生一个序列号值seq=J，发送给数据包给服务端后，自身状态变为SYN_SENT</p><p>第二次握手：服务端接收到数据包之后，将发送标志位SYN设置为1，ACK应答需要为J+1表，并且再发送一个随机序列号值seq=K然后发送到客户端</p><p>第三次握手：客户端检查ACK是否为J+1，如果是的话发送一个ACK包，ACK=k+!，服务端收到之后确定ack是否等于K+1，是的话连接建立</p><p>我们先来解释一下为什么需要三次握手：<br>第一次握手确认客户端是具有发送消息能力的，发送消息之后客户端出于SYN_SENT状态，第二次握手服务器确定了自己有接收消息的能力，但是还不知道有没有发送消息的能力，此时服务器出于SYN_RECV的状态，也就是半连接的状态，第三次握手确定了服务器有发送消息的能力，因为客户端收到了他的消息并且回应了。此时客户端和服务端都处于establish状态，连接已经建立，可以开始收发消息。</p><p>基于HTTP的确定，后面衍生出来了HTTPS，那接下来我们来讲讲HTTPS以及他们的区别</p><h2 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h2><blockquote><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）顾名思义就是在HTTP的基础上加了SSL/TLS，以此来保证数据传输的安全性。</p></blockquote><h3 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h3><p>HTTPS 协议旨在解决以上三个风险，因此它可以：</p><ol><li>保证所有信息加密传输，无法被第三方窃取。</li><li>为信息添加校验机制，如果被第三方恶意破坏，可以检测出来。</li><li>配备身份证书，防止第三方伪装参与通信。</li></ol><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><blockquote><p>SSL(Secure Sockets Layer)/TLS(transport Layer Security)安全套接层是保证HTTPS安全的协议，这个协议主要的思想是通过公钥加解密来实现数据传输安全。</p></blockquote><p>那么我们就面临着两个问题.<br>1.如何保证公钥不被篡改 </p><blockquote><p>我们通过权威机构申请证书，将自己的公钥包装到证书里面，只要证书是可信的，那么公钥就是可信的。</p></blockquote><p>2.每次都生成公钥，消耗的时间太长，如何减少消耗。</p><blockquote><p>使用对称加密来替换非对称加密，每一次对话，客户端和和服务端都生成一个对话秘钥，而这个对称秘钥使用服务端的公私钥来进行加解密，这样就减少了加密运算的消耗时间。</p></blockquote><p>SSL/TLS 握手的流程：</p><ol><li><p>首先客户端发起请求，这个时候客户端会向服务端提供一些信息，包括支持的加密的算法，支持协议的版本TLS,一个随机数（用于待会生成对称秘钥），支持的压缩算法</p></li><li><p>服务端收到请求之后，向客户端发出相应，该响应也包括一些信息，确认使用的加密算法，一个服务端生成的随机数（用于待会生成秘钥）,支持的协议的版本TLS，还有一个最重要的数字证书，该数字证书包含了服务器的域名，还有服务端的公钥，以及经过加密后的摘要，该摘要是通过一定的算法对域名以及公钥进行计算得来。然后使用CA的私钥对摘要进行加密，</p></li><li><p>客户端收到数据之后首先会验证该数字证书是不是权威机构申请的证书，或者证书中的域名与实际域名是否一致，证书是否已经过期，如果都不符合的话那么就会提示是否信任该未知来源证书警告。<br>这里会验证证书是否被篡改，因为本地系统会内置权威机构的公钥，所以可以使  用公钥对解密出证书里面的摘要，然后通过特定的算法对域名以及公钥进行计算得到一个本地摘要，再和服务端传过来的摘要进行对比是否一致，以此来判断证书是否被篡改。<br>如果校验了证书是没有问题，客户端会生成一个随机数，并且使用服务器的公钥进行加密，并且发送编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p></li><li><p>服务端获取客户端的数据，然后使用自己的私钥机密客户端发过来的随机数。至此，一共有三个随机数。</p></li><li><p>客户端和服务端通过之前协议好的加密算法，使用前面生成的三个随机数生成一个真正的对称秘钥，该对称秘钥用于加密传输数据。</p></li></ol><p>简单点来说以上步骤就是：</p><ol><li>客户端发送请求</li><li>服务端返回证书，该证书包含服务端的公钥</li><li>客户端验证证书，并且生成对称秘钥，并且使用服务端的公钥加密该对称秘钥</li><li>服务端用私钥解密客户端的对称秘钥</li><li>发送内容通过对称秘钥来加密</li></ol><p>总结一下 HTTPS 协议是如何避免前文所说的三大风险的：<br>先用非对称加密传输密码，然后用这个密码对称加密数据，使得第三方无法获得通信内容<br>发送方将数据的哈希结果写到数据中，接收方解密后对比数据的哈希结果，如果不一致则说明被修改。由于传输数据加密，第三方无法修改哈希结果。<br>由权威机构颁发证书，再加上证书校验机制，避免第三方伪装参与通信。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>在我们抛砖引玉说了这么多HTTP与HTTPS的区别之后，我们得到了答案。</p><blockquote><p>如果一个人下载了一个APP，该APP与服务器是HTTPS连接，他不会信任任何来源于不明身份的证书，然后连上了我的WIFI，我有没有办法去破解里面的通信内容</p></blockquote><p><strong>答案就是不行</strong></p><p>我们想到的可以破解里面的通信内容也许就是希望能做一个中间人拦截，在服务端向客户端发送证书的时候拦截该证书，并且伪造一个和服务端域名相同并且替换将里面的公钥替换成自己的公钥，并且用自己的私钥进行签名。客户端收到伪造的证书之后，如果客户端的系统中有我们的公钥，那么就可以验证通过该中间人的证书，然后获取得到公钥，然后用该公钥对对称秘钥加密发送给服务端，此时中间件又可以拦截，并且使用自己的私钥解密出对称秘钥，然后中间人通过服务端的公钥对该秘钥进行加密，然后发送给服务端，这样中间人就拿到了对称秘钥信息，所以也可以窃取到里面的通信内容。</p><p>但是……….</p><p>前面的题目说了一个前提，不会信任任何来源于不明身份的证书，也就是说在中间人拦截了服务端的证书并且将伪造的证书发送给客户端之后，客户端并不会通过验证该证书，然后连接就到此中断了。。。。</p><h2 id="附加：HTTPS与HTTPS的区别"><a href="#附加：HTTPS与HTTPS的区别" class="headerlink" title="附加：HTTPS与HTTPS的区别"></a>附加：HTTPS与HTTPS的区别</h2><ol><li>HTTP是明文传输，HTTPS是加密传输</li><li>HTTP只有TCP三次握手，HTTPS是TCP三次握手+SSL/TLS</li><li>HTTP是使用80端口，HTTPS是使用443端口</li><li>HTTPS比HTTPS更加耗时</li><li>HTTPS需要到CA购买证书，需要一定的费用</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1  <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></p><ol start="2"><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></li><li><a href="http://skx926.com/2017/12/05/https/" target="_blank" rel="noopener">深入理解HTTPS</a></li></ol>]]></content>
      
      <categories>
          
          <category> 其他技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> SSL/TLS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>回文数</title>
      <link href="/2018/08/10/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2018/08/10/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。"><a href="#判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。" class="headerlink" title="判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。"></a>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</h1><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><a id="more"></a><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><blockquote><p>思路：<br>根据定义如果我们要找出一个数是否是回文数我们其实只需要将这个数分成平均分成两个部分，然后将后半部分翻转，只要翻转后的后半部分等于前半部分，就代表这个数是回文数。<br>我们拿1221来举例，假设我们拿到后半段是21然后将21翻转就是12了，和前半段比较相等就代表是回文数。<br>那么我们第一个问题，如何将21翻转，首先我们将1221%10 得到的就是第一个数1，然后用这第一个数 1<em> 10 得到翻转后的正确位置。第二个数我们依然是122%10，然后得到第二个数，用第一个数加上第二个数就得到了12.<br>第二个问题就是我们如何将这个数分成两部分。当原始数/10小于翻转数</em>10的时候就代表已经完成了一半的翻转。</p></blockquote><p><strong>不过依然有两点需要注意，第一点是如果这个原始的数是负数的话我们需要返回，如果这个数是以0结尾的数，那么只有0才满足回文数，其他数都不满足回文数，我们直接返回false。</strong><br><strong>第二点是如果这个数的位数是基数，例如12321，那么循环完成之后原始数编程12，翻转数是123，这个时候我们用123/10得到12再和原始数12比较，忽略中间那一位数</strong></p><p>以下是代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func solution(_ num:Int)-&gt;Bool&#123;</span><br><span class="line">      if num&lt;0 || (num % 10 == 0 &amp;&amp; num != 0)&#123;</span><br><span class="line">          return false</span><br><span class="line">      &#125;</span><br><span class="line">      var originNum = num</span><br><span class="line">      var reverserNum = 0</span><br><span class="line">      while originNum &gt; reverserNum &#123;</span><br><span class="line">          reverserNum = reverserNum * 10 + originNum % 10</span><br><span class="line">          originNum = originNum / 10</span><br><span class="line">      &#125;</span><br><span class="line">      return originNum == reverserNum || originNum == reverserNum / 10</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>持续集成之Jenkins构建项目并上传到蒲公英</title>
      <link href="/2018/08/08/iOS%20%E5%BC%80%E5%8F%91/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
      <url>/2018/08/08/iOS%20%E5%BC%80%E5%8F%91/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%92%B2%E5%85%AC%E8%8B%B1/</url>
      <content type="html"><![CDATA[<blockquote><p>在第一篇<a href="http://lemon2well.top/2018/08/07/iOS%20开发/持续集成之Jenkins搭建/">Jenkins的搭建</a>中我们已经把本地jenkins环境都搭建好了，接下来我们通过jenkins构建一个ipa并且上传到蒲公英。</p></blockquote><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p>1.首先选择左侧的新建任务，然后下面是构建该工程的基本信息</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336240434000.jpg" alt=""></p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336241947095.jpg" alt=""></p><a id="more"></a><h2 id="填写源码地址"><a href="#填写源码地址" class="headerlink" title="填写源码地址"></a>填写源码地址</h2><ol start="2"><li>下面填写github或者gitLab的源码的地址，并且需要配置对应的Credentials，这里相当是授权。等到构建的时候jenkins会从对应的git上面拉去代码开始构建。</li></ol><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336242653880.jpg" alt=""></p><p>填完源码的网址之后需要填写git的账号密码或者输入对应的私钥。点击Add然后会出现下面的界面</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336242294039.jpg" alt=""></p><blockquote><p>如果你的git已经配置了ssh那么可以选择SSH username and private key， 然后到你的/Users/用户名/.ssh/id_rsa 将这个私钥文件里面的所有内容复制到privatekey (enter directly)上面去。<br>否则可以按照上图那样，选择username with password，然后输入用户名和密码</p></blockquote><h2 id="设置触发器（非必要）"><a href="#设置触发器（非必要）" class="headerlink" title="设置触发器（非必要）"></a>设置触发器（非必要）</h2><ol start="3"><li>构建触发器是与测试相关的操作，这里可以根据需求选择构建的触发时刻，例如选择第二个就是当代码仓库有push事件的时候，就会触发构建操作，然后构建一个版本并且通知测试去操作。因为我们是手动构建，所以这里先不管这个。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336265635081.jpg" alt=""></li></ol><h2 id="设置签名和证书"><a href="#设置签名和证书" class="headerlink" title="设置签名和证书"></a>设置签名和证书</h2><ol start="4"><li>接下我们需要设置签名文件和证书。<br>首先保存我们原先的设置，然后回到首页，选择系统管理-&gt;Keychains and Provisioning Profiles Management 点击选取文件，然后选择login.keychain文件和 provisioning file 上传。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336269763882.jpg" alt=""></li></ol><p>填写本机密码，输入描述，然后选择Add Code Signing Identity 输入签名文件的名称，这里的名称可以到钥匙串找到对应的证书然后选择显示简介然后复制头部的文字。</p><blockquote><p>这个Keychain在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下</p></blockquote><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336275407363.jpg" alt=""></p><p>上面的配置完成之后，回到任务的配置里面，选择对应的keyChain和provisioning file</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15336251729871.jpg" alt=""></p><h2 id="构建命令"><a href="#构建命令" class="headerlink" title="构建命令"></a>构建命令</h2><ol start="5"><li>上面已经将所有的设置都配置好了，接下来需要选择构建的方式，你可以选择通过xcode来构建，但是这里我们选择shell 并且也推荐通过shell来构建。选择执行shell，然后输入下面的代码，里面有些地方需要改成你自己的，根据实际情况改就可以了，不过一定要注意一点，jenkins那个编辑框极其不好用，我因为不小心输入了一个空格字符然后一直报 command not found ，搞到我一直以为是jenkins配置环境的问题。如果中间有构建错误，点击构建那个红点然后可以查看具体的控制台信息，根据错误提示来修改就好了</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 工程名，记得改成你自己</span><br><span class="line">APP_NAME=&quot;TestUMCOpen&quot;</span><br><span class="line"># 证书</span><br><span class="line">CODE_SIGN_DISTRIBUTION=&quot;iPhone Distribution: XXXXXXXXXX&quot;</span><br><span class="line"># info.plist路径</span><br><span class="line">project_infoplist_path=&quot;./$&#123;APP_NAME&#125;/Info.plist&quot;</span><br><span class="line"></span><br><span class="line">#取版本号</span><br><span class="line">bundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line"></span><br><span class="line">#取build值</span><br><span class="line">bundleVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</span><br><span class="line">DATE=&quot;$(date +%Y%m%d)&quot;</span><br><span class="line">IPAFOLDER=&quot;$&#123;APP_NAME&#125;_V$&#123;bundleShortVersion&#125;_$&#123;DATE&#125;&quot;</span><br><span class="line"></span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">ARCHIVE_PATH=&quot;$&#123;HOME&#125;/Desktop/archive&quot;</span><br><span class="line">IPA_PATH=&quot;$ARCHIVE_PATH/$&#123;IPAFOLDER&#125;/$&#123;APP_NAME&#125;.ipa&quot;</span><br><span class="line">PLIST_PATH=&quot;$ARCHIVE_PATH/ADHocExportOptions.plist&quot;</span><br><span class="line">echo $&#123;IPA_PATH&#125;</span><br><span class="line">echo $&#123;PLIST_PATH&#125;</span><br><span class="line"></span><br><span class="line">#下面两行是没有Cocopods的用法</span><br><span class="line"># 清除上次构建</span><br><span class="line">xcodebuild clean -project &quot;$&#123;APP_NAME&#125;.xcodeproj&quot; -scheme $&#123;APP_NAME&#125;   -configuration &apos;Release&apos;</span><br><span class="line"># 构建xcarchive文件</span><br><span class="line">xcodebuild archive -project &quot;$&#123;APP_NAME&#125;.xcodeproj&quot; -scheme $&#123;APP_NAME&#125; -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot;</span><br><span class="line"></span><br><span class="line">#下面两行是有cocopods的用法</span><br><span class="line"># xcodebuild clean -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme $&#123;APP_NAME&#125;   -configuration &apos;Release&apos;</span><br><span class="line"></span><br><span class="line"># xcodebuild archive -workspace &quot;$&#123;APP_NAME&#125;.xcworkspace&quot; -scheme $&#123;APP_NAME&#125; -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot;</span><br><span class="line"></span><br><span class="line"># 导出ipa</span><br><span class="line">xcodebuild -exportArchive -archivePath &quot;$&#123;ARCHIVE_PATH&#125;/$&#123;APP_NAME&#125;.xcarchive&quot; -exportPath &quot;$ARCHIVE_PATH/$IPAFOLDER&quot; -exportOptionsPlist &quot;$PLIST_PATH&quot;</span><br><span class="line"></span><br><span class="line">#打开文件夹</span><br><span class="line">open $&#123;ARCHIVE_PATH&#125;</span><br></pre></td></tr></table></figure><p><strong>这里有个地方需要注意一下，在xcode9之后，需要提供一个信息才能打包，我们可以通过xcode打包出来ipa文件然后复制那个ExportOption.plist文件就好了以下是我的文件的内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;compileBitcode&lt;/key&gt;</span><br><span class="line">&lt;false/&gt;</span><br><span class="line">&lt;key&gt;method&lt;/key&gt;</span><br><span class="line">&lt;string&gt;enterprise&lt;/string&gt;</span><br><span class="line">&lt;key&gt;provisioningProfiles&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;your Bundle id&lt;/key&gt;</span><br><span class="line">&lt;string&gt;证书的名字&lt;/string&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;key&gt;signingCertificate&lt;/key&gt;</span><br><span class="line">&lt;string&gt;iPhone Distribution&lt;/string&gt;</span><br><span class="line">&lt;key&gt;signingStyle&lt;/key&gt;</span><br><span class="line">&lt;string&gt;manual&lt;/string&gt;</span><br><span class="line">&lt;key&gt;stripSwiftSymbols&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;teamID&lt;/key&gt;</span><br><span class="line">&lt;string&gt;7LD5QKB26C&lt;/string&gt;</span><br><span class="line">&lt;key&gt;thinning&lt;/key&gt;</span><br><span class="line">&lt;string&gt;none&lt;/string&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>如果成功之后会在我们指定的文件里面生成下面的文件，除了那个ADHocExportOption.plist是我创建的，前天的文件都是jenkins构建的。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336256611678.jpg" alt=""></p></li><li><p>上传ipa到蒲公英</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#上传到蒲公英</span><br><span class="line">uKey=&quot;aec42b3cc32*******837cc7084a819c&quot;</span><br><span class="line">#蒲公英上的API Key</span><br><span class="line">apiKey=&quot;ba4e62***************8067a87315&quot;</span><br><span class="line">#要上传的ipa文件路径</span><br><span class="line">echo $IPA_PATH</span><br><span class="line"> </span><br><span class="line">#执行上传至蒲公英的命令</span><br><span class="line">echo &quot;++++++++++++++upload+++++++++++++&quot;</span><br><span class="line">curl -F &quot;file=@$&#123;IPA_PATH&#125;&quot; -F &quot;uKey=$&#123;uKey&#125;&quot; -F &quot;_api_key=$&#123;apiKey&#125;&quot; http://www.pgyer.com/apiv1/app/upload</span><br></pre></td></tr></table></figure><h2 id="命令行构建"><a href="#命令行构建" class="headerlink" title="命令行构建"></a>命令行构建</h2><ol start="7"><li>至此我们已经完成手动构建项目了，接下来我们利用Jenkins命令行来完成一行命令构建版本<br>进入系统管理然后选择Jenkins命令行，下载最新的jenkins-cli.jar<br><img src="http://pcd17v2u0.bkt.clouddn.com/15336535463602.jpg" alt=""></li></ol><p>下载完成之后，如果直接运行上述命令行会提示没有权限，这个时候我们需要配置一下SSH。点击右上角的用户名，然后点击设置，找到SSH，然后将本地的公钥复制粘贴到上面，保存。</p><p>下面是完整的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">add-job-to-view</span><br><span class="line">    Adds jobs to view.</span><br><span class="line">  build</span><br><span class="line">    Builds a job, and optionally waits until its completion.</span><br><span class="line">  cancel-quiet-down</span><br><span class="line">    Cancel the effect of the &quot;quiet-down&quot; command.</span><br><span class="line">  clear-queue</span><br><span class="line">    Clears the build queue.</span><br><span class="line">  connect-node</span><br><span class="line">    Reconnect to a node(s)</span><br><span class="line">  console</span><br><span class="line">    Retrieves console output of a build.</span><br><span class="line">  copy-job</span><br><span class="line">    Copies a job.</span><br><span class="line">  create-credentials-by-xml</span><br><span class="line">    Create Credential by XML</span><br><span class="line">  create-credentials-domain-by-xml</span><br><span class="line">    Create Credentials Domain by XML</span><br><span class="line">  create-job</span><br><span class="line">    Creates a new job by reading stdin as a configuration XML file.</span><br><span class="line">  create-node</span><br><span class="line">    Creates a new node by reading stdin as a XML configuration.</span><br><span class="line">  create-view</span><br><span class="line">    Creates a new view by reading stdin as a XML configuration.</span><br><span class="line">  delete-builds</span><br><span class="line">    Deletes build record(s).</span><br><span class="line">  delete-credentials</span><br><span class="line">    Delete a Credential</span><br><span class="line">  delete-credentials-domain</span><br><span class="line">    Delete a Credentials Domain</span><br><span class="line">  delete-job</span><br><span class="line">    Deletes job(s).</span><br><span class="line">  delete-node</span><br><span class="line">    Deletes node(s)</span><br><span class="line">  delete-view</span><br><span class="line">    Deletes view(s).</span><br><span class="line">  disable-job</span><br><span class="line">    禁用任务</span><br><span class="line">  disconnect-node</span><br><span class="line">    Disconnects from a node.</span><br><span class="line">  enable-job</span><br><span class="line">    启用任务</span><br><span class="line">  get-credentials-as-xml</span><br><span class="line">    Get a Credentials as XML (secrets redacted)</span><br><span class="line">  get-credentials-domain-as-xml</span><br><span class="line">    Get a Credentials Domain as XML</span><br><span class="line">  get-job</span><br><span class="line">    Dumps the job definition XML to stdout.</span><br><span class="line">  get-node</span><br><span class="line">    Dumps the node definition XML to stdout.</span><br><span class="line">  get-view</span><br><span class="line">    Dumps the view definition XML to stdout.</span><br><span class="line">  groovy</span><br><span class="line">    Executes the specified Groovy script.</span><br><span class="line">  groovysh</span><br><span class="line">    Runs an interactive groovy shell.</span><br><span class="line">  help</span><br><span class="line">    Lists all the available commands or a detailed description of single command.</span><br><span class="line">  import-credentials-as-xml</span><br><span class="line">    Import credentials as XML. The output of &quot;list-credentials-as-xml&quot; can be used as input here as is, the only needed change is to set the actual Secrets which are redacted in the output.</span><br><span class="line">  install-plugin</span><br><span class="line">    Installs a plugin either from a file, an URL, or from update center.</span><br><span class="line">  install-tool</span><br><span class="line">    Performs automatic tool installation, and print its location to stdout. Can be only called from inside a build. [deprecated]</span><br><span class="line">  keep-build</span><br><span class="line">    永久保留这次构建。</span><br><span class="line">  list-changes</span><br><span class="line">    Dumps the changelog for the specified build(s).</span><br><span class="line">  list-credentials</span><br><span class="line">    Lists the Credentials in a specific Store</span><br><span class="line">  list-credentials-as-xml</span><br><span class="line">    Export credentials as XML. The output of this command can be used as input for &quot;import-credentials-as-xml&quot; as is, the only needed change is to set the actual Secrets which are redacted in the output.</span><br><span class="line">  list-credentials-context-resolvers</span><br><span class="line">    List Credentials Context Resolvers</span><br><span class="line">  list-credentials-providers</span><br><span class="line">    List Credentials Providers</span><br><span class="line">  list-jobs</span><br><span class="line">    Lists all jobs in a specific view or item group.</span><br><span class="line">  list-plugins</span><br><span class="line">    Outputs a list of installed plugins.</span><br><span class="line">  login</span><br><span class="line">    Saves the current credentials to allow future commands to run without explicit credential information. [deprecated]</span><br><span class="line">  logout</span><br><span class="line">    Deletes the credentials stored with the login command. [deprecated]</span><br><span class="line">  mail</span><br><span class="line">    Reads stdin and sends that out as an e-mail.</span><br><span class="line">  offline-node</span><br><span class="line">    Stop using a node for performing builds temporarily, until the next &quot;online-node&quot; command.</span><br><span class="line">  online-node</span><br><span class="line">    Resume using a node for performing builds, to cancel out the earlier &quot;offline-node&quot; command.</span><br><span class="line">  quiet-down</span><br><span class="line">    Quiet down Jenkins, in preparation for a restart. Don’t start any builds.</span><br><span class="line">  reload-configuration</span><br><span class="line">    Discard all the loaded data in memory and reload everything from file system. Useful when you modified config files directly on disk.</span><br><span class="line">  reload-job</span><br><span class="line">    Reload job(s)</span><br><span class="line">  remove-job-from-view</span><br><span class="line">    Removes jobs from view.</span><br><span class="line">  restart</span><br><span class="line">    重新启动Jenkins</span><br><span class="line">  safe-restart</span><br><span class="line">    安全地重新启动Jenkins</span><br><span class="line">  safe-shutdown</span><br><span class="line">    Puts Jenkins into the quiet mode, wait for existing builds to be completed, and then shut down Jenkins.</span><br><span class="line">  session-id</span><br><span class="line">    Outputs the session ID, which changes every time Jenkins restarts.</span><br><span class="line">  set-build-description</span><br><span class="line">    Sets the description of a build.</span><br><span class="line">  set-build-display-name</span><br><span class="line">    Sets the displayName of a build.</span><br><span class="line">  set-build-parameter</span><br><span class="line">    Update/set the build parameter of the current build in progress. [deprecated]</span><br><span class="line">  set-build-result</span><br><span class="line">    Sets the result of the current build. Works only if invoked from within a build. [deprecated]</span><br><span class="line">  set-external-build-result</span><br><span class="line">    Set external monitor job result.</span><br><span class="line">  shutdown</span><br><span class="line">    立刻关闭Jenkins</span><br><span class="line">  update-credentials-by-xml</span><br><span class="line">    Update Credentials by XML</span><br><span class="line">  update-credentials-domain-by-xml</span><br><span class="line">    Update Credentials Domain by XML</span><br><span class="line">  update-job</span><br><span class="line">    Updates the job definition XML from stdin. The opposite of the get-job command.</span><br><span class="line">  update-node</span><br><span class="line">    Updates the node definition XML from stdin. The opposite of the get-node command.</span><br><span class="line">  update-view</span><br><span class="line">    Updates the view definition XML from stdin. The opposite of the get-view command.</span><br><span class="line">  version</span><br><span class="line">    Outputs the current version.</span><br><span class="line">  wait-node-offline</span><br><span class="line">    Wait for a node to become offline.</span><br><span class="line">  wait-node-online</span><br><span class="line">    Wait for a node to become online.</span><br><span class="line">  who-am-i</span><br><span class="line">    Reports your credential and permissions.</span><br></pre></td></tr></table></figure><p>我们执行命令的格式是<br><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -ssh -user username command</code><br>command 就是我们需要执行的命令，build是构建命令，下面的事情就很简单了。</p><p><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -ssh -user username build UMC10.1.0Demo</code><br><strong>UMC10.1.0Demo是我们一开始创建任务的时候的名字，这个时候就会自动构建版本并且上传蒲公英</strong><br>可以将上述命令放到.command文件里面，并且增加可执行权限，这样双击这个文件的时候就会触发构建。注意里面cli.jar的路径。</p><p>上述命令指示构建一个指定版本的脚本，下面我们可以通过列举出所有的任务，然后选择其中一个任务来开始构建版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">ps -fe|grep &quot;jenkins&quot; |grep -v grep</span><br><span class="line">if [ $? -ne 0 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;******请先使用Jenkins -h来启动jenkins**********&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;********检测到Jenkins已经启动**********&quot;</span><br><span class="line">fi</span><br><span class="line">LOCALHOST=&quot;http://localhost:8080/&quot;</span><br><span class="line">CLIJAR=&quot;/Users/lemon/jenkins-cli.jar&quot;</span><br><span class="line"></span><br><span class="line">java -jar $&#123;CLIJAR&#125; -s $&#123;LOCALHOST&#125; -ssh -user admin list-jobs</span><br><span class="line"></span><br><span class="line">echo &quot;*******请输入你要构建的任务*******&quot;</span><br><span class="line">read BuildName</span><br><span class="line"></span><br><span class="line">java -jar $&#123;CLIJAR&#125; -s $&#123;LOCALHOST&#125; -ssh -user admin build $&#123;BuildName&#125;</span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">echo &quot;*******正在构建$&#123;BuildName&#125;，构建完成后会自动打开本地文件夹*******&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;*******构建$&#123;BuildName&#125;失败，请检查是否有对应的任务*******&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述：总的来说在我们jenkins已经安装好的情况下，我们需要做的就是构建任务，然后填写源码地址，设置构建策略，设置签名和证书，编写构建代码（包括上传蒲公英），编写shell。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
            <tag> 蒲公英 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>持续集成之Jenkins搭建</title>
      <link href="/2018/08/07/iOS%20%E5%BC%80%E5%8F%91/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/08/07/iOS%20%E5%BC%80%E5%8F%91/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B9%8BJenkins%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于一个APP来说，我相信我们开发最担心的就是出bug，只要是线上APP出bug，心里就慌得很，这是一件很严重的事情，还有可能让用户一气之下把你的APP删掉，从此再也不会出现在他的手机里面。</p><p>但是如果我们严格把控APP的质量，我们做到每天都构建一个版本并且测试，我们将这个APP上传到一个特定的测试系统，当有代码更新的时候或者每天设置一个时间去不断的跑测试，这样我们在开发阶段就发现很多问题。</p><blockquote><p>上面我们说的就是CI(Continuous Integration)持续集成+TDD(Test Driven Development)测试驱动开发。</p></blockquote><a id="more"></a><h2 id="持续集成带来的好处"><a href="#持续集成带来的好处" class="headerlink" title="持续集成带来的好处"></a>持续集成带来的好处</h2><p>持续集成带来的好处是显而易见的</p><ol><li><p>减少风险。通过每天构建版本，在开发阶段就可以发现项目的缺陷，排除一些因为项目设置的低级错误而导致的bug，用同样的脚本和过程构建和测试软件，排除因代码外的其他因素。</p></li><li><p>减少重复的过程，提高效率。当项目变大之后，频繁的打包会很影响开发的效率，但是有了持续集成我们不用关心打包的过程，将重复的build,archive,code sign交给提供构建服务的机器去做，将时间放在更有意义的事情上面。</p></li><li><p>随时可部署。持续集成有一个好处就是我们每天都会做构建版本，可以交付部署上线，当我们无休止的讨论需求软件质量或者开发进度的时候，对于客户来说，不如一个可安装的软件包来得实际</p></li></ol><h3 id="持续集成之Jenkins"><a href="#持续集成之Jenkins" class="headerlink" title="持续集成之Jenkins"></a>持续集成之Jenkins</h3><p>CI包括三个基本的元素，第一个是可自动构建版本的服务，第二个是代码仓库，第三个是搭建了服务的机器。</p><blockquote><p>可自动构建版本的服务目前有Jenkins和fastlane。<br>代码仓库也就是我们平时使用的github,gitlab等等<br>在iOS中机器必须是搭建OSX系统的机器，因为构建需要用到xcodeBuild命令，该命令由xcode提供，而xcode只能安装在OSX系统下面。</p></blockquote><p>下面我们要说的就是可自动构建版本的服务，<a href="https://jenkins.io" target="_blank" rel="noopener">Jenkins</a>。</p><p>Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性，构建完成之后通过脚本直接上传到分发平台或者测试平台。</p><h2 id="Jenkins搭建"><a href="#Jenkins搭建" class="headerlink" title="Jenkins搭建"></a>Jenkins搭建</h2><p>jenkins有两种安装方式</p><p>一种是通过在<a href="https://jenkins.io/download" target="_blank" rel="noopener">官网</a>下载pkg安装包的方式安装，图形化的安装界面直接跟着提示安装就好了。</p><p>第二种是通过homebrew安装，不过在安装之前我们需要检测本地环境是否已经安装了java，可以使用<code>java -version</code>来查看当前的java版本，如果没有安装的java的话可以在<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">这里</a>安装java。<br>还要检测是否已经安装了homebrew,查看本机homebrew版本’brew -v’。</p><p>如果java和homebrew都已经安装好，就可以开始安装jenkins了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure><p>当出现Jenkins is fully up and running之后，表明jenkins已经安装好了，如果没有自动打开<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> ，可以到网页上面自行打开该外地址。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337123514685.png" alt=""></p><p>上面给了一个地址，提示你去那里找到初始化的密码。打开/User/Shared/Jenkins/Home/secrets/initialAdminPassword复制出密码。</p><p>接下来会提示你安装一些插件，安装默认的插件即可，不过就算这里安装失败了也没关系，后面进到主界面还可以继续安装。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337131168237.png" alt=""></p><p>安装完插件之后会提示你创建一个jenkins用户。<br><img src="http://pcd17v2u0.bkt.clouddn.com/15337133154570.jpg" alt=""></p><p>输入这些信息之后点击save And Finish安装的过程就算完成了。接下来可以进入到jenkins主界面了。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337135245241.jpg" alt=""><br>我们主要关注一下面板左侧的选项，点击“系统管理”，然后找到“管理插件”<br>在“可选插件”中选中“GitLab Plugin”和“Gitlab Hook Plugin”这两项，然后安装。<br>安装Xcode插件<br>同安装GitLab插件的步骤一样，我们依次选择系统管理-&gt;管理插件，在“可选插件”中选中“Xcode integration”安装，安装完这个插件我们还需要安装一个“Keychains and Provisioning Profiles Management”插件。这个插件用于我们设置签名和证书。</p><p>安装“Keychains and Provisioning Profiles Management”之后，我们去到系统管理-&gt;Keychains and Provisioning Profiles Management设置签名和证书。</p><p><img src="http://pcd17v2u0.bkt.clouddn.com/15337147054369.jpg" alt=""></p><p>这里需要选择 login.keychain ，在 /Users/用户名/Library/keychains/login.keychain 目录里。如果不能通过选择的话，可以把login.keychain拷贝到桌面，然后在选择上传。<br>Code Signing Identity，可以添加多项。进入钥匙串，选择开发者证书或发布证书，拷贝完全，粘贴至Jenkins的Code Signing Identity项。</p><p>当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下</p><p>到这里Jenkins的搭建就算完成了，下一篇文章我们将会使用jenkins创建一个任务，然后构造版本并且上传蒲公英，最终的目的都是通过一个脚本来完成上述的操作。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用队列实现栈和用栈实现队列</title>
      <link href="/2018/08/03/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2018/08/03/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>用两个栈来实现队列，思路和用数组实现队列一样</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//用栈实现队列</span><br><span class="line">struct QueueByStack&#123;</span><br><span class="line">    </span><br><span class="line">    var Peek: Int? &#123;</span><br><span class="line">        mutating middleCaulate()</span><br><span class="line">        return rightStack?.peek</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    typealias Element = Int</span><br><span class="line">    </span><br><span class="line">    private var leftStack:IntergerStack?</span><br><span class="line">    private var rightStack:IntergerStack?</span><br><span class="line">    </span><br><span class="line">    init() &#123;</span><br><span class="line">    leftStack = IntergerStack()</span><br><span class="line">    rightStack = IntergerStack()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var isEmpty: Bool &#123;return leftStack!.isEmpty &amp;&amp; rightStack!.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return leftStack!.Size + rightStack!.Size&#125;</span><br><span class="line">    </span><br><span class="line">    mutating func middleCaulate()&#123;</span><br><span class="line">        if leftStack!.isEmpty &#123;</span><br><span class="line">            while !rightStack!.isEmpty&#123;</span><br><span class="line">                leftStack!.push((rightStack?.pop())!)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func enQueue(_ newElement: Int) &#123;</span><br><span class="line">        rightStack?.push(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func deQueue() -&gt; Int? &#123;</span><br><span class="line">        middleCaulate()</span><br><span class="line">        return leftStack?.peek</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用两个队列来实现栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct StackByQueue &#123;</span><br><span class="line">    private var queueA : IntergerQueue?</span><br><span class="line">    private var queueB : IntergerQueue?</span><br><span class="line">    init() &#123;</span><br><span class="line">        queueA = IntergerQueue()</span><br><span class="line">        queueB = IntergerQueue()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var isEmpty: Bool&#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return queueA!.isEmpty &amp;&amp; queueB!.isEmpty</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var Size: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return queueA!.Size</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var peek: Int?&#123;</span><br><span class="line">        mutating get &#123;</span><br><span class="line">            transfer()</span><br><span class="line">            let obj = queueB?.Peek</span><br><span class="line">            swap()</span><br><span class="line">            return obj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func push(_ newElement:Int)&#123;</span><br><span class="line">        queueB?.enQueue(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func pop()-&gt;Int?&#123;</span><br><span class="line">        transfer()</span><br><span class="line">        let obj = queueB?.deQueue()</span><br><span class="line">        swap()</span><br><span class="line">        return obj</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func transfer() &#123;</span><br><span class="line">        if queueB?.Size != 1&#123;</span><br><span class="line">            queueA?.enQueue((queueB?.deQueue())!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func swap()&#123;</span><br><span class="line">        (queueA,queueB) = (queueB,queueA)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>swift实现栈和队列</title>
      <link href="/2018/08/02/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/swift%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2018/08/02/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/swift%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>在swift中并没有内设的栈和队列，接下来我们通过数组来实现栈和队列</p><p>栈的实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protocol Stack &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    //是否为空</span><br><span class="line">    var isEmpty: Bool&#123; get &#125;</span><br><span class="line">    //栈的大小</span><br><span class="line">    var Size: Int&#123; get &#125;</span><br><span class="line">    //栈顶元素</span><br><span class="line">    var peek: Element? &#123; get &#125;</span><br><span class="line">    //入栈</span><br><span class="line">    mutating func push(_ newElement:Element)</span><br><span class="line">    //出栈</span><br><span class="line">    mutating func pop()-&gt;Element?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct IntegerStack:Stack &#123;</span><br><span class="line">    typealias Element  = Int</span><br><span class="line">    private var stack = [Element]()</span><br><span class="line">    var isEmpty: Bool &#123;return stack.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return stack.count&#125;</span><br><span class="line">    var peek: Int? &#123;return stack.last&#125;</span><br><span class="line">    mutating func push(_ newElement: Int) &#123;</span><br><span class="line">        self.stack.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    func pop() -&gt; Int? &#123;</span><br><span class="line">        return stack.last</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>队列的实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protocol Queue &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    var isEmpty: Bool &#123;get&#125;</span><br><span class="line">    var Size: Int &#123;get&#125;</span><br><span class="line">    var Peek:Element? &#123;get&#125;</span><br><span class="line">    mutating func enQueue(_ newElement:Element)</span><br><span class="line">    mutating func deQueue()-&gt;Element?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct IntergerQueue:Queue &#123;</span><br><span class="line">    typealias Element = Int</span><br><span class="line">    private var left = [Element]()</span><br><span class="line">    private var right = [Element]()</span><br><span class="line">    var isEmpty: Bool &#123;return left.isEmpty &amp;&amp; right.isEmpty&#125;</span><br><span class="line">    var Size: Int &#123;return left.count + right.count&#125;</span><br><span class="line">    var Peek: Element? &#123;return left.isEmpty ? right.first : left.last&#125;</span><br><span class="line">    mutating func enQueue(_ newElement: Int) &#123;</span><br><span class="line">       right.append(newElement)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func deQueue() -&gt; Element? &#123;</span><br><span class="line">        if left.isEmpty &#123;</span><br><span class="line">            left = right.reversed()</span><br><span class="line">            right.removeAll()</span><br><span class="line">        &#125;</span><br><span class="line">        return left.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络层设计方案以及去Model化实践</title>
      <link href="/2018/08/02/iOS%20%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E4%BB%A5%E5%8F%8A%E5%8E%BBModel%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/08/02/iOS%20%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E4%BB%A5%E5%8F%8A%E5%8E%BBModel%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然在网上看到<a href="https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="noopener">casa的网络层设计方案</a>，在以前的iOS开发中，用的最多的就是集约型的网络请求+去Model的形式，然而在看完这篇文章之后我觉得好像发现了新大陆，原来还可以这么玩。</p><a id="more"></a><blockquote><ol><li>此网络层设计方案最大的好处就是解耦，每个API都有特定的APIManager管理，可以方便的缓存数据以及取消网络请求。</li><li>在集约型网络基础上封装了散约型的API，参数以及请求以及处理请求数据全部封装到该APIManager方法里面。</li><li>通过Delegate的方法回调，更好的方便调试以及释放对象。如果以block来调用的话首先不方便调试，其次会延长对象的生命周期，对象需要必须等到网络请求回来之后才能释放。</li><li>提供一个BaseAPIManager，然后通过IOP的方式约束子类必须要遵循APIRequestProtocol，通过实现该协议的方式来提供给API参数，这样父类就不用提供空载函数。 该父类还提供一个代理，该代理用于返回数据。</li><li>最后是去Model化的设计，APIRequestProtocol 提供了一个<code>-(id)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer;</code>协议方法，在该方法里面可以会传入一个遵守ReformProtocol协议的reformer，到时reformer就可以自定义处理数据的方法，返回特定的数据</li><li>ReformProtocol有一个<code>- (id)reformDataWith:(LMBaseAPIManager*)apiManager;</code>的协议方法，里面可以根据apiManager做判断，然后返回不同的数据，也就是说，一个reformer可以对应多个apiManager。</li></ol></blockquote><p>具体的原理和好处在case的文章里面已经说得很清楚了</p><h2 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h2><p><img src="http://pcd17v2u0.bkt.clouddn.com/15331959524160.jpg" alt=""></p><ul><li>LMNetwork是具体的网络出口类，里面提供了集约化的网络请求方法，通过block返回数据。</li><li><p>LMBaseAPIManager是网络请求基类，里面有一个遵循了APIRequestProtocol协议的request，这个协议提供了网络请求参数的的方法和处理网络请求结果的方法。发送网络请求的时候会通过这个request获取必要的参数，以及返回数据的时候通过这个类处理数据。</p><p>该类还提供了一个遵循了APIResponseProtocol的代理对象，当网络返回数据的时候会调用该协议方法，该协议方法返回一个遵循APIRequestProtocol的request，调用方需要调用<code>fetchDataWithReformer:</code>方法，并且传入一个reformer，然后在该方法的实现里面就可以将apiManager传给reformer，reformer可以根据不同apiManager做不同的数据返回了。</p><p>LMBaseAPIManager还提供了两个属性，一个responseData和error，网络请求结果和错误都会放到这里面，到时将apiManager传到reformer的时候，通过这两个属性可以取出数据。</p><p>LMBaseAPIManager还可以提供一个isCache的方法，可以自己设置缓存策略。</p><p>总的来说，LMBaseAPIManager需要派生一个子类，然后子类需要实现apiRequestProtocol方法，提供网络必要的参数。调用<code>startRequest</code>方法之后调用LMNetwork发送网络请求。当网络请求回来之后，通过代理回调结果，并且将apiManager返回，调用方收到回调时候，传入reformer对数据进行处理。</p></li></ul><ul><li><p>LMReformerProtocol是一个协议，里面有一个协议方法<code>- (id)reformDataWith:(LMBaseAPIManager*)apiManager;</code>该方法用来处理返回数据。</p></li><li><p>LMProductionAPIManager是LMBaseAPIManagerd的派生类，里面提供了apiRequestProtocol协议方法的实现。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以上已经将框架介绍清楚了，下面是代码实现：</p><ol><li>首先初始化productionAPIManager并且设计代理。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (LMProductionAPIManager *)productionAPIManager&#123;</span><br><span class="line">    if(!_productionAPIManager)&#123;</span><br><span class="line">        _productionAPIManager = [[LMProductionAPIManager alloc]init];</span><br><span class="line">        _productionAPIManager.response = self;</span><br><span class="line">    &#125;</span><br><span class="line">    return _productionAPIManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于LMProductionAPIManager是LMBaseAPIManagerd的子类，因此会调用父类的init方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        if ([self conformsToProtocol:@protocol(APIRequestProtocol)]) &#123;</span><br><span class="line">            self.request = (id&lt;APIRequestProtocol&gt;)self;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSAssert(NO, @&quot;子类必须要遵循APIRequestProtocol协议&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于子类遵循了 <code>@interface LMProductionAPIManager: LMBaseAPIManager&lt;APIRequestProtocol&gt;</code> APIRequestProtocol协议，因为该类内部有一个request的属性指向该对象。而该对象是遵循了上述的协议，所以要实现上述协议里面的方法，接下来看看LMProductionAPIManager里面的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@implementation LMProductionAPIManager</span><br><span class="line">- (NSString *)apiRequestName&#123;</span><br><span class="line">    return  @&quot;http://120.197.235.101:8080/apk/iosPagingQuery?pageNo=1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSString *)apiRequestMethod&#123;</span><br><span class="line">    return GET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)apiRequestParameters&#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer&#123;</span><br><span class="line">    if (reformer == nil) &#123;</span><br><span class="line">        return self.responseData;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [reformer reformDataWith:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该对象内部提供了url以及get方法和参数，还提供处理返回数据的实现。</p><ol start="2"><li><p>接下来调用 <code>[self.productionAPIManager startRequest];</code>方法，看看该方法内部会做什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   - (void)startRequest&#123;</span><br><span class="line">    [[LMNetwork sharedInstance]requestMethod:[self.request apiRequestMethod] url:[self.request apiRequestName] parameters:[self.request apiRequestParameters] finishBlock:^(id data, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            self.responseError = error;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">         self.responseData = data;</span><br><span class="line">         &#125;</span><br><span class="line">        if ([self.response respondsToSelector:@selector(apiResponseSuccess:)]) &#123;</span><br><span class="line">            [self.response apiResponseSuccess:self.request];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>该方法会发送网络请求并且将请求后的数据复制给当前对象的相关属性，然后通过代理回到结果，并且将当前请求对象返回。</p><ol start="3"><li><p>调用方收到代理之后进行处理 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)apiResponseSuccess:(id&lt;APIRequestProtocol&gt;)request&#123;</span><br><span class="line">    [MBProgressHUD hideHUD];</span><br><span class="line">    self.productionArr =  [request fetchDataWithReformer:[LMProductReformer new]];</span><br><span class="line">    [self.tableView reloadData];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>收到回调之后首先对初始化一个LMProductionReform对象，该对象遵循了LMReformerProtocol协议，待会再来看里面的实现。</p><p>然后调用request的协议方法 <code>fetchDataWithReformer</code>该方法的实现在第一点已经提到了，该方法内部会看一下有没有传reformer进来，如果没有的话直接返回未经处理的对象，如果有的话那就调用reformer的LMReformerProtocol协议方法。</p><p>接下来来看<code>LMReformerProtocol</code>方法的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   - (id)reformDataWith:(LMBaseAPIManager *)apiManager&#123;</span><br><span class="line">    //这里根据不同的APIManager返回相应的数据</span><br><span class="line">    if ([apiManager isKindOfClass: [LMProductionAPIManager class]]) &#123;</span><br><span class="line">        NSDictionary *dict = apiManager.responseData;</span><br><span class="line">        NSArray *list = dict[@&quot;list&quot;];</span><br><span class="line">        NSMutableArray *mArr = [NSMutableArray arrayWithCapacity:list.count];</span><br><span class="line">        for (NSDictionary *dict in list) &#123;</span><br><span class="line">            NSDictionary *infoDict = @&#123;kLMProductionVer:dict[@&quot;ver&quot;],kLMProductionVerDesc:dict[@&quot;verDesc&quot;]&#125;;</span><br><span class="line">            [mArr addObject:infoDict];</span><br><span class="line">        &#125;</span><br><span class="line">        return mArr;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return  nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>reform在这里根据不同的APIManager进行不同的解析，返回不同的数据。</p><p>到这里，整个网络和去model的设计就完成了。每个API都应该对应一个APIManager，但是可以使用同一个reformer，然后reformer对apimanager做判断从而返回不同的数据。</p><p>值得注意的是：由于我们用字典的形式来存储数据，所以肯定会有hardcode，我们可以定义一个头文件了里面包含所有我们用到的字符串常量，然后在reformer的实现文件里面给这些常量赋值。<br>如在<code>LMProductReformKeys.h</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern NSString *const kLMProductionVer;</span><br><span class="line">extern NSString *const kLMProductionVerDesc;</span><br></pre></td></tr></table></figure><p>在<code>LMProductReformer.m</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString * const kLMProductionVer = @&quot;productionVer&quot;;</span><br><span class="line">NSString * const kLMProductionVerDesc = @&quot;productionVerDesc&quot;;</span><br></pre></td></tr></table></figure><p>这样只要引入LMProductReformer.h都可以使用该常量。</p><p>完整的<a href="https://github.com/codemonkeybulucck/NoModelExample.git" target="_blank" rel="noopener">demo</a></p><p>以上。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 去model </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快行指针</title>
      <link href="/2018/08/01/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E5%BF%AB%E8%A1%8C%E6%8C%87%E9%92%88/"/>
      <url>/2018/08/01/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E5%BF%AB%E8%A1%8C%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<p>快行指针的定义就是有两个指针访问链表，但是一个指针的速度比另外一个快，或者说一个指针在前，一个在后。</p><p>根据这个特性我们可以用来检测一个链表中是否有环。</p><blockquote><p>假设：一个指针的速度是另外一个指针的两倍，它们同时开始访问同一个链表，如果链表有环的情况下，那么快行指针总会追上慢行指针，也就是总有一个时刻快行指针和慢行指针指向同一个节点，当慢行指针跑一圈的时候，快行指针此时刚好跑了两圈。<br><a id="more"></a><br>以下是具体算法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:Equatable &#123;</span><br><span class="line">//遵守Equatable协议</span><br><span class="line">    static func == (lhs: ListNode, rhs: ListNode) -&gt; Bool &#123;</span><br><span class="line">        if lhs.val == rhs.val &amp;&amp; lhs.next == rhs.next&#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      public var val: Int</span><br><span class="line">      public var next: ListNode?</span><br><span class="line">      public init(_ val: Int) &#123;</span><br><span class="line">          self.val = val</span><br><span class="line">          self.next = nil</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class quickSolution &#123;</span><br><span class="line">    func checkCycle(_ l1:ListNode?)-&gt;Bool&#123;</span><br><span class="line">        guard let l1 = l1 else&#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        var slowNode:ListNode? = l1,fastNode:ListNode? = l1</span><br><span class="line">        while fastNode != nil &amp;&amp; fastNode?.next != nil &#123;</span><br><span class="line">            slowNode = slowNode?.next</span><br><span class="line">            fastNode = fastNode?.next!.next</span><br><span class="line">            if slowNode == fastNode &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们依然可以用这个方法来解决另外一个问题。<br>删除链表中的第n个节点，例如：1-&gt;3-&gt;6-&gt;5-&gt;2 ，这里要删除倒数第2个节点。那么删除后的链表为： 1-&gt;3-&gt;6-&gt;2。</p><blockquote><p>思路：<br>假设快行指针从一开始就比慢行指针快n个节点，然后他们以相同的速度前进，当快行指针走到链表的最后一个节点的时候，慢行指针的当前节点的下一个节点就是我们要删除的节点。</p></blockquote><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class DeleteSolution &#123;</span><br><span class="line">    func deleteNode(_ l1:ListNode?,n:Int)-&gt;ListNode?&#123;</span><br><span class="line">        guard let l1 = l1 else&#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        let dummy = ListNode(0)</span><br><span class="line">        dummy.next = l1</span><br><span class="line">        var slowNode:ListNode? = dummy</span><br><span class="line">        var fastNode:ListNode? = dummy</span><br><span class="line">        //设置快行指针比慢行指针快n个节点</span><br><span class="line">        for _ in 0 ..&lt; n &#123;</span><br><span class="line">            if fastNode == nil &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            fastNode = fastNode?.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //同时移动两个指针</span><br><span class="line">        while fastNode != nil &amp;&amp; fastNode?.next != nil &#123;</span><br><span class="line">            slowNode = slowNode?.next</span><br><span class="line">            fastNode = fastNode?.next</span><br><span class="line">        &#125;</span><br><span class="line">        //删除需要删除的节点</span><br><span class="line">        slowNode?.next = slowNode?.next?.next</span><br><span class="line">        return dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dummy节点和尾巴插法</title>
      <link href="/2018/07/31/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/dummy%E8%8A%82%E7%82%B9%E5%92%8C%E5%B0%BE%E5%B7%B4%E6%8F%92%E6%B3%95/"/>
      <url>/2018/07/31/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/dummy%E8%8A%82%E7%82%B9%E5%92%8C%E5%B0%BE%E5%B7%B4%E6%8F%92%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>给出一个链表和一个数X，要求将链表中所有小于X的值放到左边，等于或者大于X的值放到右边，并且原链表的节点顺序不变。</p><p>示例：<br>假设： 1-&gt;7-&gt;3-&gt;5-&gt;2-&gt;8-&gt;4，给定x=4<br>那么变换后的节点为： 1-&gt;3-&gt;2-&gt;7-&gt;5-&gt;8-&gt;4</p><a id="more"></a><blockquote><p>思路：<br>我们先把题目简单化，我们可以先找出链表中小于X的节点放到一个新的链表里面<br>然后再找出等于或者大于X的节点放到另外一个条链表<br>最后将第一条链表的next指向第二条链表的头结点，这样就完成了题目的要求。</p></blockquote><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">      public var val: Int</span><br><span class="line">      public var next: ListNode?</span><br><span class="line">      public init(_ val: Int) &#123;</span><br><span class="line">          self.val = val</span><br><span class="line">          self.next = nil</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class NewSoluction &#123;</span><br><span class="line">    func getNewList(_ l1:ListNode?,x:Int)-&gt;ListNode?&#123;</span><br><span class="line">        let headDummy = ListNode(0), tailDummy = ListNode(0)</span><br><span class="line">        var head = headDummy,tail = tailDummy</span><br><span class="line">        var node = l1</span><br><span class="line">        while node != nil &#123;</span><br><span class="line">            if node!.val &lt; x &#123;</span><br><span class="line">                head.next = node!</span><br><span class="line">                head = node!</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                tail.next = node!</span><br><span class="line">                tail = node!;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node!.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail.next = nil;</span><br><span class="line">        //头链加上尾链</span><br><span class="line">        head.next = tailDummy.next</span><br><span class="line">        return headDummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：tail.next = nil 是为了防止形成环，因为<code>tail.next = node ! ,tail = node</code>这一句实际上是形成了环，所以需要将tail.next置空来打破环</strong></p>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 组件化实践《二》基于现有项目拆分组件化实践</title>
      <link href="/2018/07/31/iOS%20%E5%BC%80%E5%8F%91/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%BA%8C%E3%80%8B-%E5%9F%BA%E4%BA%8E%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/07/31/iOS%20%E5%BC%80%E5%8F%91/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%BA%8C%E3%80%8B-%E5%9F%BA%E4%BA%8E%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><blockquote><p>在<a href="http://lemon2well.top/2018/07/30/iOS%20开发/组件化实践《一》创建私有pod/">第一篇</a>介绍中已经介绍了如果发布一个私有pod，下面将会介绍如何基于一个现有的项目拆分成组件化形式的项目。<br>假设我们现有的项目是有一个AViewController,还有一个BViewController，目前的功能是点击rootViewController页面的按钮会push到AviewController，然后点击AviewController的一个按钮会跳转到BViewController。这里是未拆分的<a href="https://github.com/codemonkeybulucck/TestModule" target="_blank" rel="noopener">demo</a></p></blockquote><a id="more"></a><h2 id="0x02-拆分组件"><a href="#0x02-拆分组件" class="headerlink" title="0x02 拆分组件"></a>0x02 拆分组件</h2><blockquote><p>现在我们要拆分AViewController和BViewController,将他们拆分成两个组件，并且按照Target-Action的形式提供对外的接口，通过中间件去调用Target对应的Action，在最上层是中间件的分类，给调用方提供具体且便利的方法和接口。</p></blockquote><h3 id="0x02-1-分析如何拆分AViewController"><a href="#0x02-1-分析如何拆分AViewController" class="headerlink" title="0x02.1 分析如何拆分AViewController"></a>0x02.1 分析如何拆分AViewController</h3><ol><li><p>首先AViewController，现在AViewController需要外部传一个NSString类型的参数进去，然后返回一个AViewController的对象。这个时候应该创建一个Target_AViewController的类，然后对外一个<code>Action_fectchAViewController:</code>的方法，这个方法需要接收一个字典类型的参数，到时我们会从这个字典中取出key为navTitle的值来作为AViewController的参数。以下是该方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   - (UIViewController*)Action_fetchAViewController:(NSDictionary*)params&#123;</span><br><span class="line">    AViewController *aViewControlelr = [[AViewController alloc]init];</span><br><span class="line">    NSString *title = params[@&quot;navTitle&quot;];</span><br><span class="line">    aViewControlelr.navTitle = title;</span><br><span class="line">    return aViewControlelr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>然后我们要创建CTMediator的分类<code>CTMediator+ModuleAActions</code>，这个分类方法对外提供了一个<code>fetchAViewController</code>的方法，到时调用方调用此方法即可获取到一个AViewController的实例，而不用自己去初始化AViewController。</p></li><li><p>那么上面那个分类具体做了什么操作呢，该方法会传一个“AViewController”和“fetchAViewController”来表明需要调用Target_AViewController的Action_fetchAViewller方法，也就是我们刚刚提供的Target_Action。本来调用方是不用通过类别来调用组件Target_Action的，因为可以通过CTMediator的<code>perform Target: action: params:</code>来直接调用。但是那样非常不友好以及不统一。<br>加上了该分类之后，可以做更多的容错处理以及有一个容易的入口。</p></li><li><p>所以在后面做成pod的时候，category是一个pod，它只依赖于CTMediator，调用方法是通过CTMediator通过runtime来找到Target_Action来调用。所以另外一个pod就是AViewController+Target_AViewController。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   - (UIViewController*)fetchAViewController&#123;</span><br><span class="line">    UIViewController *vc = [self performTarget:@&quot;AViewController&quot; action:@&quot;fetchAViewController&quot; params:@&#123;@&quot;navTitle&quot;:@&quot;This is A ViewController&quot;&#125; shouldCacheTarget:NO];</span><br><span class="line">    if ([vc isKindOfClass:[UIViewController class]]) &#123;</span><br><span class="line">        return vc;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [[UIViewController alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>以上提到的pod：</strong><br><a href="https://github.com/codemonkeybulucck/AViewControllerCategory" target="_blank" rel="noopener">CategoryAViewController</a><br><a href="https://github.com/codemonkeybulucck/LMAViewController" target="_blank" rel="noopener">AviewControllerPod</a><br><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="noopener">CTMediactor</a></p><h3 id="0x02-2-创建BViewController的category和Target-Action的pod"><a href="#0x02-2-创建BViewController的category和Target-Action的pod" class="headerlink" title="0x02.2 创建BViewController的category和Target_Action的pod"></a>0x02.2 创建BViewController的category和Target_Action的pod</h3><p>1、为什么需要先创建BViewController组件，因为AViewController会依赖于BViewController，所以我们先创建BViewController组件。</p><p>2、首先我们先创建BViewController私有pod，按照我的<a href="http://lemon2well.top/2018/07/30/iOS%20开发/组件化实践《一》创建私有pod/">组件化实践《一》</a>创建好<a href="https://github.com/codemonkeybulucck/BViewController" target="_blank" rel="noopener">BViewController</a>的pod，这个pod不用依赖于任何其他组件，所以应该没啥困难。</p><p>3、接下来我们需要创建<a href="https://github.com/codemonkeybulucck/BCategory" target="_blank" rel="noopener">BViewControllerCategory</a>，这里有一点要注意的是在podspec文件的最下面需要加入<code>s.dependency &#39;CTMediator&#39;</code>，因为里面需要用到CTMediator的perform方法去调用到对应的组件。因为CTMediator已经发布到cocoapods所以可以直接用，如果这里的依赖是你自己改动之后的私有Mediator，记得在pod spec lint 的时候要加上<code>--sources=yourgithub/spec,master</code>将源改成你自己的私有索引库的地址，不然默认是从公有索引库里面找不到对应的Mediator。待会在AViewController调用B的时候会用到这个命令。</p><h3 id="0x02-3-创建AViewController的category和Target-Action的pod"><a href="#0x02-3-创建AViewController的category和Target-Action的pod" class="headerlink" title="0x02.3 创建AViewController的category和Target_Action的pod"></a>0x02.3 创建AViewController的category和Target_Action的pod</h3><p>1、方法同上，首先创建AViewController的<a href="https://github.com/codemonkeybulucck/AViewControllerCategory" target="_blank" rel="noopener">Category</a>组件，这里只需要注意在podspec文件的最下面需要加入<code>s.dependency &#39;CTMediator&#39;</code>。<br>2、 然后我们创建<a href="https://github.com/codemonkeybulucck/LMAViewController" target="_blank" rel="noopener">AViewController</a>私有pod，由于在AViewController里面我们有个按钮点击之后会push到BViewController，那必然要引入BViewController，但是在组件中不会直接引入BViewController，我们通过引入BViewControllerCategory来让程序编译的时候不要报错就行。podspec文件要加入<code>s.dependency &#39;BCategory&#39;</code>。</p><p>3、 验证，因为第二部中我们的私有工程依赖了另外一个私有工程，这个时候的<code>pod spec lint</code>和 <code>pod repo push</code>命令都要加上 <code>--source</code>说明</p><p><strong>注意：组件间的调用依然是利用Target对应的分类来调用。记住分类是统一的入口，组件里面的代码不会依赖于另外一个组件，而是依赖于对应的分类组件或者CTMediator，然后所有依赖的pod都要写到主工程的podfile里面</strong></p><h2 id="0x03-引用组件"><a href="#0x03-引用组件" class="headerlink" title="0x03 引用组件"></a>0x03 引用组件</h2><p>我们将AViewController和BViewController拆分后，我们创建一个demo来测试一下刚刚拆分的组件。创建一个OC项目，在项目的跟目录下执行<code>pod init</code>，然后在podfile文件里面写入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/codemonkeybulucck/LMSpec&apos;</span><br><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"></span><br><span class="line">target &apos;moduleTest&apos; do</span><br><span class="line">  # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line">  pod &apos;ACategory&apos;</span><br><span class="line">  pod &apos;AViewController&apos;,&apos;~&gt;0.1.1&apos;</span><br><span class="line">  pod &apos;BViewController&apos;</span><br><span class="line">  # Pods for moduleTest</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>完成后执行 <code>pod install</code>，成功之后再<code>#import &quot;CTMediator+ModuleAActions.h&quot;</code> 然后调用方式就变成了<br><code>UIViewController *vc = [[CTMediator sharedInstance] fetchAViewController];</code></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>组件化最核心的思想就是解耦，将庞大的项目抽丝剥茧，分离成互相独立的一个一个模块，每个模块都是可复用的。上述的方案其实已经做到了解耦，调用者只需要用到中间件的分类的方法接口而不需要引入实际的组件的类。<br>但是在分类里面有一个弊端就是：动态调用方法的时候需要硬编码也就是，这样容错率就很低，不过幸好这个东西是在分类中，在开发的过程中就可以发现的问题。<br>另外一个方面也不是所有的项目都适合用组件化，只有当项目规模扩大到一定的程度，并且人员众多的情况下用组件化的便捷性才体现出来。所以很多时候我们讨论架构或者讨论一种新的技术，并不是它就是最好的，没有什么东西是最好的，只有最合适的，因地制宜。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocoapods </tag>
            
            <tag> 组件化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2018/07/31/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2018/07/31/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><p>示例：</p><p>给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。</p><p>给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。</p><p>给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列  而不是子串。</p><a id="more"></a><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">leetcode链接</a></p><blockquote><p>解答思路：</p><ol><li>首先从头开始遍历字符串，并且将已经遍历过的字符串放到一个数组里面</li><li>但是放到数组里面的前提是当前遍历的字符并不存在在数组当中，也就是如果当前遍历的字符不在数组中，那么就将字符放到数组中，开始下一次遍历</li><li>如果当前当前的字符在数组中，那么找到该字符在数组中的下标，删除数组中从下标为0到该字符下标区间的元素，然后将当前字符放到数组里面开始下一次遍历。</li><li>每遍历一次，都要判断上一次的最长字符串maxCount是否小于当前数组的元素的数量，如果是，那么就更新maxCount。</li></ol></blockquote><p>下面是代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func _maxLongString(s:String!)-&gt;Int&#123;</span><br><span class="line">        if s.count == 0 &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">        var subArr = [CChar]()</span><br><span class="line">        var maxCount = 0;</span><br><span class="line">        var array = s.cString(using:.utf8)!</span><br><span class="line">        array.removeLast() //由于字符串会有一个结束符，所以需要删掉最后的结束符</span><br><span class="line">        for str in array&#123;</span><br><span class="line">            if subArr.contains(str) &#123;</span><br><span class="line">                let index:Int = subArr.index(of: str)!</span><br><span class="line">                let empty = 0..&lt;index+1</span><br><span class="line">                subArr.removeSubrange(empty)</span><br><span class="line">            &#125;</span><br><span class="line">            subArr.append(str)</span><br><span class="line">            maxCount = max(maxCount, subArr.count)</span><br><span class="line">        &#125;</span><br><span class="line">        return maxCount</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>非空链表相加</title>
      <link href="/2018/07/30/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E9%9D%9E%E7%A9%BA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/"/>
      <url>/2018/07/30/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E9%9D%9E%E7%A9%BA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/</url>
      <content type="html"><![CDATA[<p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p><blockquote><p>思路：</p><ol><li>只要两个非空链表中的其中一个链表不为空的时候就循环便利两个链表</li><li>如果其中一个链表为空而另外一个链表不为空，那么为空的那个链表的值就为0</li><li>用一个carry位来表示是否有进位，0代表无进位，1代表有进位，因为链表中都是个位数，所以最大进位也只能为1，初始化进位为0</li><li>用x,y来表示当前两个链表的值，sum = x+y+carry为新链表的值，但是有可能有进位，所以新的carry = sum / 10,当前节点位的值为sum = sum %10。<a id="more"></a></li><li>创建一个新节点，将上述中sum的值赋给新节点，然后将新链表当前节点的next指向新节点，然后将当前节点指向到新节点</li><li>两个链表的当前节点都要指向下一个节点</li><li>当遍历完成之后，还需要判断一下carry的值是不是大于0，如果大于0则代表还需要创建一个节点，并且将新链表的节点的next指向该节点</li></ol></blockquote><p>以下是代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class ListNode &#123;</span><br><span class="line">      public var val: Int</span><br><span class="line">      public var next: ListNode?</span><br><span class="line">      public init(_ val: Int) &#123;</span><br><span class="line">          self.val = val</span><br><span class="line">          self.next = nil</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123;</span><br><span class="line">        let resultNode = ListNode(0)</span><br><span class="line">        var currentNode = resultNode</span><br><span class="line">        var p = l1</span><br><span class="line">        var q = l2</span><br><span class="line">        var carry = 0 //表示进位</span><br><span class="line">        while p != nil || q != nil &#123;</span><br><span class="line">            //获取当前的值</span><br><span class="line">            var x = 0,y = 0;</span><br><span class="line">            if let p = p &#123;</span><br><span class="line">                x = p.val</span><br><span class="line">            &#125;</span><br><span class="line">            if let q = q &#123;</span><br><span class="line">                y = q.val</span><br><span class="line">            &#125;</span><br><span class="line">            let sum = x + y + carry</span><br><span class="line">            carry = sum / 10</span><br><span class="line">            let newSum = sum % 10;</span><br><span class="line">            currentNode.next = ListNode(newSum)</span><br><span class="line">            currentNode = currentNode.next!</span><br><span class="line">            p = p?.next</span><br><span class="line">            q = q?.next</span><br><span class="line">        &#125;</span><br><span class="line">        if carry &gt; 0 &#123;</span><br><span class="line">            currentNode.next = ListNode(carry)</span><br><span class="line">        &#125;</span><br><span class="line">        return resultNode.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 组件化实践《一》创建私有pod</title>
      <link href="/2018/07/30/iOS%20%E5%BC%80%E5%8F%91/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%B8%80%E3%80%8B%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89pod/"/>
      <url>/2018/07/30/iOS%20%E5%BC%80%E5%8F%91/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%B8%80%E3%80%8B%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89pod/</url>
      <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>本次组件化实践的方式来自于<a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">casaty组件化方案</a>，该方案是基于target-action模式和Mediator模式，通过Mediator利用runtime的机制来调用对应的target-action。并且在上层通过category的方式暴露对外调用的接口，这样调用者在调用的时候就知道需要传递哪些参数。</p><a id="more"></a><p>具体的调用方式就是：<br><img src="http://pcd17v2u0.bkt.clouddn.com/WX20180730-160336@2x.png" alt="WX20180730-160336@2x"></p><blockquote><p>实际上是可以不使用category的形式而是直接调用CTMediactor的<code>- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget</code> 方法直接调用对应target的action，但是那样对于调用方来说极其不友好，最直观的感受就是不知道params应该传哪些参数。</p></blockquote><blockquote><p>利用catogory的方式暴露方法的好处在于<br>1、一个组件对应一个category，每个category提供了组件所有的调用方法，调用方直接调用，可以直观的看到需要传递哪些参数。<br>2、提供统一的调用入口，所有的组件的被调用都是通过category<br>3、可以做异常处理，将参数的校验提前，并且可以做请求转发。</p></blockquote><h2 id="0x02-组件化实践"><a href="#0x02-组件化实践" class="headerlink" title="0x02 组件化实践"></a>0x02 组件化实践</h2><p>在简单的介绍了组件化的实际逻辑之后下面开始真正的开始动手实现组件化实践流程。</p><blockquote><p>一个私有pod的创建具体分为以下几步：</p></blockquote><ol><li>创建工程</li><li>创建私有库，修改podSpec文件，将本地代码库和远程代码库关联起来，上传代码到远程仓库。</li><li>创建远程索引库和本地索引库，也就是用于放置podspec的地方，每个podspec文件可以索引到我们远程不同的代码私有库</li><li>本地测试podspec文件是否可用</li><li>向索引库Spec Repo中提交podspec</li><li>测试Spec Repo中的的 podspec 是否可用</li></ol><p>1、 首先到github里面创建一个空的工程，例如我要创建一个FirstViewController<br><img src="http://pcd17v2u0.bkt.clouddn.com/15329320727207.jpg" alt=""></p><hr><p>2、 创建私有库，终端运行<code>pod lib create FirstViewController</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:Module lemon$ pod lib create FirstViewController</span><br><span class="line">Cloning `https://github.com/CocoaPods/pod-template.git` into `FirstViewController`.</span><br><span class="line">Configuring FirstViewController template.</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">To get you started we need to ask a few questions, this should only take a minute.</span><br><span class="line"></span><br><span class="line">If this is your first time we recommend running through with the guide:</span><br><span class="line"> - https://guides.cocoapods.org/making/using-pod-lib-create.html</span><br><span class="line"> ( hold cmd and click links to open in a browser. )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line"> &gt; iOS //pod平台</span><br><span class="line"></span><br><span class="line">What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line"> &gt; ObjC //pod语言</span><br><span class="line"></span><br><span class="line">Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class="line"> &gt; No //是否需要提供demo</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line"> &gt; None //测试框架</span><br><span class="line"></span><br><span class="line">Would you like to do view based testing? [ Yes / No ]</span><br><span class="line"> &gt; No //是否需要测试视图</span><br><span class="line"></span><br><span class="line">What is your class prefix?</span><br><span class="line"> &gt; LM //demo类前缀</span><br><span class="line"></span><br><span class="line">Running pod install on your new library.</span><br><span class="line"></span><br><span class="line">Analyzing dependencies</span><br><span class="line">Fetching podspec for `FirstViewController` from `../`</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing FirstViewController (0.1.0)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br></pre></td></tr></table></figure><p>上述命令执行完成之后会本地帮我们生成一个pod的模板文件，我们在这里首先需要改动的就是FirstViewController.podspec文件，用xcode打开该文件。<br>目前我们需要注意下面几处地方：</p><ul><li><code>s.version          = &#39;1.0.0&#39;</code>    //pod的版本，后面将podSpec文件提交到私有repo的时候会验证远程的仓库中是否已经存在对应的tag，所以这个要与后面提交代码的时候的tag相同,我们先修改为1.0.0，可以按照你们自己的标准修改。</li><li><code>s.homepage         = &#39;https://github.com/codemonkeybulucck/FirstViewController&#39;</code>  //homepage这里填写在第一步中再github创建的远程仓库的地址即可。</li><li><p><code>s.source           = { :git =&gt; &#39;https://github.com/codemonkeybulucck/FirstViewController.git&#39;, :tag =&gt; s.version.to_s }</code>  //这里填写远程仓库的地址，记得后面要加上.git的后缀</p></li><li><p><code>s.ios.deployment_target = &#39;8.0&#39;</code> //该pod的最低运行环境</p></li><li><p><code>s.source_files = &#39;FirstViewController/Classes/**/*&#39;</code> //pod中源代码的路径，后面会将实际的代码放在Classes文件夹下面</p></li></ul><p>一些其他设置的说明：</p><p>  s.summary          = ‘A short description of FirstViewController.’  //pod的简述<br>  s.description      = &lt;&lt;-DESC //具体描述<br> s.license          = { :type =&gt; ‘MIT’, :file =&gt; ‘LICENSE’ } //许可证<br>  s.author           = { <a href="mailto:&#39;545390087@qq.com" target="_blank" rel="noopener">&#39;545390087@qq.com</a>‘ =&gt; <a href="mailto:&#39;codebulucck@163.com" target="_blank" rel="noopener">&#39;codebulucck@163.com</a>‘ } //作者信息<br> s.dependency ‘AFNetworking’, ‘~&gt; 2.3’ //依赖库，如果该pod依赖其他pod，可以在此处加上。</p><p>完成podspec文件修改之后我们可以将对应的组件代码放到Classes文件夹路径下面。下面将本地代码库和远程代码库关联起来，然后将本地代码推送到远程仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git remote add origin https://github.com/codemonkeybulucck/FirstViewController.git</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git add .</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git commit -m &quot;初始化&quot;</span><br><span class="line">[master 8ac032c] 初始化</span><br><span class="line"> 25 files changed, 1209 insertions(+)</span><br><span class="line"> create mode 100644 Example/FirstViewController.xcworkspace/contents.xcworkspacedata</span><br><span class="line"> create mode 100644 Example/FirstViewController.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist</span><br><span class="line"> create mode 100644 Example/Podfile.lock</span><br><span class="line"> create mode 100644 Example/Pods/Local Podspecs/FirstViewController.podspec.json</span><br><span class="line"> create mode 100644 Example/Pods/Manifest.lock</span><br><span class="line"> create mode 100644 Example/Pods/Pods.xcodeproj/project.pbxproj</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-dummy.m</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-prefix.pch</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController-umbrella.h</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController.modulemap</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/FirstViewController.xcconfig</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/FirstViewController/Info.plist</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Info.plist</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-acknowledgements.markdown</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-acknowledgements.plist</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-dummy.m</span><br><span class="line"> create mode 100755 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-frameworks.sh</span><br><span class="line"> create mode 100755 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-resources.sh</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests-umbrella.h</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.debug.xcconfig</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.modulemap</span><br><span class="line"> create mode 100644 Example/Pods/Target Support Files/Pods-FirstViewController_Tests/Pods-FirstViewController_Tests.release.xcconfig</span><br><span class="line"> create mode 100644 FirstViewController/Classes/FirstViewController.h</span><br><span class="line"> create mode 100644 FirstViewController/Classes/FirstViewController.m</span><br><span class="line"> delete mode 100644 FirstViewController/Classes/ReplaceMe.m</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git push origin master</span><br><span class="line">Counting objects: 62, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (55/55), done.</span><br><span class="line">Writing objects: 100% (62/62), 23.04 KiB | 2.56 MiB/s, done.</span><br><span class="line">Total 62 (delta 10), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (10/10), done.</span><br><span class="line">To https://github.com/codemonkeybulucck/FirstViewController.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure><hr><p>3、 创建远程索引库和本地索引库，同样在github创建一个新的仓库，仓库的名字叫做LMSpec，这个仓库是pod的索引库，也就是后面如果要引用组件pod的话只要引入这个LMSpec就能从里面找到对应的组件。<br>    创建完远程仓库之后我们创建一个本地索引库，并且将本地索引库和远程仓库连接起来。<br>    <code>pod repo add LMSpec https://github.com/codemonkeybulucck/LMSpec.git</code> 执行完这条命令之后，去到 <code>~/.cocoapods/repo</code>路径下就能看到有一个master和LMSpec，master是公有cocoapod的索引库，LMSpec就是我们自己新建的索引库。到此我们已经创建好代码库以及索引库了。</p><hr><p>4、本地测试podspec文件是否可用 本地测试podspec文件是否可用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ pod lib lint</span><br><span class="line"></span><br><span class="line"> -&gt; FirstViewController (1.0.0)</span><br><span class="line">    - WARN  | summary: The summary is not meaningful.</span><br><span class="line"></span><br><span class="line">[!] FirstViewController did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it).</span><br><span class="line">You can use the `--no-clean` option to inspect any issue.</span><br></pre></td></tr></table></figure><p>上述验证表明我们本地验证已经没有错误了，但是有一个警告，我们可以使用<br><code>pod lib lint --allow-warnings</code>来忽略警告。如果我们使用<code>pod spec lint</code>来验证的话，记得要先本地代码库打tag然后将tag推动到远程仓库才能通过验证，因为该命令是同时验证本地和远程仓库，因为我们还没有打tag推送到远程仓库，所以我们先用<code>pod lib lint</code>来验证。</p><hr><p>5、 向索引库Spec Repo中提交podspec<br>  在第四步中我们已经验证我们的podspec文件没有问题了，但是我们现在还不能推送到索引库，因为我们还没有打tag，这个tag应该是与podspec文件里面的version一致，不一致的话远程验证的时候是通不过验证的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git tag -a 1.0.0 -m &quot;第一个版本pod&quot;</span><br><span class="line">Lemons-MacBookPro:FirstViewController lemon$ git push origin master 1.0.0</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 183 bytes | 183.00 KiB/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/codemonkeybulucck/FirstViewController.git</span><br><span class="line"> * [new tag]         1.0.0 -&gt; 1.0.0</span><br></pre></td></tr></table></figure><p>完成上述步骤后我们需要将podspec提交到索引库中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:FirstViewController lemon$ pod repo push LMSpec FirstViewController.podspec --allow-warnings</span><br><span class="line"></span><br><span class="line">Validating spec</span><br><span class="line"> -&gt; FirstViewController (1.0.0)</span><br><span class="line">    - WARN  | summary: The summary is not meaningful.</span><br><span class="line"></span><br><span class="line">Updating the `LMSpec&apos; repo</span><br><span class="line"></span><br><span class="line">Already up to date.</span><br><span class="line"></span><br><span class="line">Adding the spec to the `LMSpec&apos; repo</span><br><span class="line"></span><br><span class="line"> - [Add] FirstViewController (1.0.0)</span><br><span class="line"></span><br><span class="line">Pushing the `LMSpec&apos; repo</span><br></pre></td></tr></table></figure><p>至此为止我们已经将podspec文件推送到本地LMSpec和远程LMSpec里面了，可以到 <code>~/.cocoapods/repo/LMSpec</code>文件夹下看有没有对应FirstViewControll文件夹。该文件夹下会有一个1.0.0的文件夹，也就是我们刚刚打的tag的数值。后续如果修改代码需要重新打tag,然后到时这里也会出现新的版本的代码。<br><strong>注</strong> 如果该私有库里面引用了其他的私有库，也就是podspec文件中s.dependency引用了其他私有库的信息，需要指定私有库的位置，那么推送命令将变为</p><p><code>pod repo push LMSpec FirstViewController.podspec --allow-warnings --sources=https://github.com/codemonkeybulucck/LMSpec,master</code> </p><hr><p>6、 测试Spec Repo中的的 podspec 是否可用<br>创建一个ModuleTest的工程，进入到工程里面先执行 <code>pod init</code> ，然后编辑podfile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/codemonkeybulucck/LMSpec&apos;</span><br><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"></span><br><span class="line">target &apos;moduleTest&apos; do</span><br><span class="line">  # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line">  pod &apos;FirstViewController&apos;</span><br><span class="line">  # Pods for moduleTest</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>执行<code>pod install</code>如果没出错就代表私有库已经添加成功。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocoapods </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>两数之和</title>
      <link href="/2018/07/29/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2018/07/29/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>给定一个数组和一个目标数，判断数组中是否有两个数的和等于该目标数，如果存在则输出它们在数组中的序号。</p><blockquote><p>解法1：第一眼看到上述题目我们第一时间的反应应该是通过两个循环遍历来找出它们的序号。第一个循环找出一个数X，然后用目标数减去该数值X得到第二个数Y，然后第二次循环找出有没有与Y相等的数值。这样时间的复杂度是O(n²)。</p></blockquote><a id="more"></a><blockquote><p>解法2：我们可以通过使用字典的的方式，数值作为字典的key，数组下标作为字典的value。我们可以在第一次便利的时候，用目标数减去循环得到的数X，然后得到目标数Y，然后判断字典中有没有以Y作为key的value。<br>如果有的话，那么此次循环的i就是第一个数值的下标，以Y作为key那个value就是第二个数值的下标。<br>如果不存在则将该次循环的下标和数值保存到字典里面。继续下一次遍历。<br>以下是Swift代码示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func _sum(_ array:[Int],targetNum:Int)-&gt;[Int]&#123;</span><br><span class="line">       var dict = [Int:Int]()</span><br><span class="line">       for(i,num) in array.enumerated()&#123;</span><br><span class="line">           let secondNum = targetNum - num</span><br><span class="line">           if let secondIndex = dict[secondNum]&#123;</span><br><span class="line">               return [i,secondIndex]</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               dict[num] = i</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return [0,0]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>字符串反转算法</title>
      <link href="/2018/07/29/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E7%AE%97%E6%B3%95/"/>
      <url>/2018/07/29/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h1><p>给定一个字符串，要求按照其按照单词的顺序进行反转<br>即： oc is the best language<br>反转后的字符串应该为： language is the bast oc</p><blockquote><p>思路：我们首先可以对给定的字符串进行普通的反转，然后将反转后的字符串进行切割成单词只有再反转会正常的单词。swift实现如下：</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func _reverseWold(_ s: String?)-&gt;String?&#123;</span><br><span class="line">        //首先先对整体字符串反转</span><br><span class="line">        guard let s = s else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        let rs = String(s.reversed())</span><br><span class="line">        //对反转后的字符串在切割成单词反转</span><br><span class="line">        var result = String()</span><br><span class="line">        let array = rs.split(separator: &quot; &quot;)</span><br><span class="line">        for (i,word) in array.enumerated()&#123;</span><br><span class="line">            let rw = String(word.reversed())</span><br><span class="line">            if i != array.count-1&#123;</span><br><span class="line">                result.append(rw+&quot; &quot;)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result.append(rw)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 常见算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串反转 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS防止被逆向调试</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%98%B2%E6%AD%A2%E8%A2%AB%E9%80%86%E5%90%91%E8%B0%83%E8%AF%95/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%98%B2%E6%AD%A2%E8%A2%AB%E9%80%86%E5%90%91%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><blockquote><p>反调试主要分为两种，第一种阻止调试器附加，第二种是检测是否有调试器存在</p></blockquote><a id="more"></a><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>第一种方法：</p><h3 id="0x01-ptrace"><a href="#0x01-ptrace" class="headerlink" title="0x01 ptrace"></a>0x01 ptrace</h3><blockquote><p>ptrace是系统用来对运行中的进程进行调试和跟踪的工具，通过ptrace，可以对另一个进程实现调试跟踪。但是里面提供了一个非常有用的参数，就是PT_DENY_ATTACH，const值是31，这个参数用户告诉系统阻止调试器附加。<br>在main.m里面加入以下代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line">#import &lt;dlfcn.h&gt;</span><br><span class="line">#import &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">typedef int  (*ptrace_ptr_t)(int _request,pid_t pid,caddr_t _addr,int _data);</span><br><span class="line">#ifndef PT_DENY_ATTACH</span><br><span class="line">#define PT_DENY_ATTACH 31</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">       // ptrace(PT_DENY_ATTACH,0,0,0); //系统函数并没有暴露出此方法所以不能直接通过此方式调用</span><br><span class="line">        void *handle = dlopen(0, RTLD_NOW|RTLD_GLOBAL);</span><br><span class="line">        ptrace_ptr_t ptrace_ptr = (ptrace_ptr_t)dlsym(handle, &quot;ptrace&quot;);</span><br><span class="line">        ptrace_ptr(PT_DENY_ATTACH,0,0,0);</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的代码中，本来是直接调用上面被注释的那一行代码就可以了，不过由于不是公开的函数所以没法直接调用。所以我们通过dlopen的方式，当path 参数为0是,他会自动查找 $LD_LIBRARY_PATH,$DYLD_LIBRARY_PATH, $DYLD_FALLBACK_LIBRARY_PATH 和 当前工作目录中的动态链接库，通过句柄找到对应的ptarce对应的地址，然后传入PT_DENY_ATTACH。</p></blockquote><h3 id="0x02-syscall"><a href="#0x02-syscall" class="headerlink" title="0x02 syscall"></a>0x02 syscall</h3><blockquote><p>另外一种方式可以使用syscall的方式来调用ptrace，syscall是系统提供的一个系统调用函数，因为上面的调用方式会容易被反反调试，通过NSFindSymbol找到_ptrace然后hook对应的函数，所以可以最好是通过syscall来反调试<br>在Kernel Syscalls里面找到<a href="https://www.theiphonewiki.com/wiki/Kernel_Syscalls" target="_blank" rel="noopener">ptrace</a>对应的const。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ joker -u ~/Documents/projects/iOS.6.0.iPod4.kernel </span><br><span class="line">This is an ARM binary. Applying iOS kernel signatures</span><br><span class="line">Entry point is 0x80085084....This appears to be XNU 2107.2.33</span><br><span class="line">Syscall names are @2a70f0</span><br><span class="line">Sysent offset in file/memory (for patching purposes): 0x2ef0c0/0x802f00c0</span><br><span class="line"></span><br><span class="line">Suppressing enosys (0x800b3429)  T = Thumb</span><br><span class="line">1. exit                  801d4a74 T</span><br><span class="line">2. fork                  801d7980 T</span><br><span class="line">3. read                  801eb584 T</span><br><span class="line">4. write                 801eb958 T</span><br><span class="line">5. open                  800b13a4 T</span><br><span class="line">6. close                 801ccab4 T</span><br><span class="line">7. wait4                 801d56bc T</span><br><span class="line">9. link                  800b18e8 T</span><br><span class="line">10. unlink               800b1ff0 T</span><br><span class="line">12. chdir                800b0c60 T</span><br><span class="line">13. fchdir               800b0af0 T</span><br><span class="line">14. mknod                800b14bc T</span><br><span class="line">15. chmod                800b2b40 T</span><br><span class="line">16. chown                800b2c9c T</span><br><span class="line">18. getfsstat            800b088c T</span><br><span class="line">20. getpid               801dc20c T</span><br><span class="line">23. setuid               801dc4c0 T</span><br><span class="line">24. getuid               801dc290 T</span><br><span class="line">25. geteuid              801dc2a0 T</span><br><span class="line">26. ptrace               801e812c T</span><br><span class="line">27. recvmsg              8020a8fc T</span><br><span class="line">28. sendmsg              8020a444 T</span><br><span class="line">29. recvfrom             8020a528 T</span><br><span class="line">30. accept               80209dfc T</span><br><span class="line">31. getpeername          8020abc8 T</span><br><span class="line">32. getsockname          8020ab18 T</span><br><span class="line">33. access               800b24ac T</span><br><span class="line">34. chflags              800b2928 T</span><br><span class="line">35. fchflags             800b29f0 T</span><br><span class="line">36. sync                 800b0320 T</span><br><span class="line">37. kill                 801dfdcc T</span><br><span class="line">39. getppid              801dc214 T</span><br><span class="line">41. dup                  801cab04 T</span><br><span class="line">42. pipe                 801edbe4 T</span><br><span class="line">43. getegid              801dc318 T</span><br><span class="line">46. sigaction            801deee8 T</span><br><span class="line">47. getgid               801dc308 T</span><br><span class="line">48. sigprocmask          801df42c T</span><br><span class="line">49. getlogin             801dd0e8 T</span><br><span class="line">50. setlogin             801dd160 T</span><br><span class="line">51. acct                 801c54ec T</span><br><span class="line">52. sigpending           801df5d0 T</span><br></pre></td></tr></table></figure><blockquote><p>注意一下代码中的26就是ptrace的const。<br>综上所述：调用syscall(26,31,0,0,0)就可以达到反调试的目的。</p></blockquote><h3 id="0x03-sysctl"><a href="#0x03-sysctl" class="headerlink" title="0x03 sysctl"></a>0x03 sysctl</h3><blockquote><p>可以通过sysctl查看内核进程状态标志位，如果一个进程在调试状态，会有一个标志位（info.kp_proc.p_flag）来标识当前是否正在调试。<br>代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BOOL existDebugger()&#123;</span><br><span class="line">    int name[4];//指定查询信息的数组</span><br><span class="line">    struct kinfo_proc info;//查询的返回结果</span><br><span class="line">    size_t info_size = sizeof(info);</span><br><span class="line">    info.kp_proc.p_flag = 0;</span><br><span class="line">    </span><br><span class="line">    name[0] = CTL_KERN;</span><br><span class="line">    name[1] = KERN_PROC;</span><br><span class="line">    name[2] = KERN_PROC_PID;</span><br><span class="line">    name[3] = getpid();</span><br><span class="line">    if (sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0) == -1) &#123;</span><br><span class="line">        NSLog(@&quot;sysctl error ...&quot;);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以定时执行以上代码，当检测到程序正在被调试，可以调用exit(0)来让程序奔溃或者做其他的操作</p></blockquote><h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><blockquote><p>syscall可以通过软中断实现从用户态切换到系统内核态的转换，同时可以通过arm 汇编实现以上功能。通过asm volatile内联汇编，实际上也是调用了ptrace。<br>代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __arm__</span><br><span class="line">        asm volatile(</span><br><span class="line">                     &quot;mov r0,#31\n&quot;</span><br><span class="line">                     &quot;mov r1,#0\n&quot;</span><br><span class="line">                     &quot;mov r2,#0\n&quot;</span><br><span class="line">                     &quot;mov r12,#26\n&quot;</span><br><span class="line">                     &quot;svc #80\n&quot;</span><br><span class="line"></span><br><span class="line">                     );</span><br><span class="line">#endif</span><br><span class="line">#ifdef __arm64__</span><br><span class="line">        asm volatile(</span><br><span class="line">                     &quot;mov x0,#26\n&quot;</span><br><span class="line">                     &quot;mov x1,#31\n&quot;</span><br><span class="line">                     &quot;mov x2,#0\n&quot;</span><br><span class="line">                     &quot;mov x3,#0\n&quot;</span><br><span class="line">                     &quot;mov x16,#0\n&quot;</span><br><span class="line">                     &quot;svc #128\n&quot;</span><br><span class="line">                     );</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反调试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS字符串加密以及静态混淆</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E6%B7%B7%E6%B7%86/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E6%B7%B7%E6%B7%86/</url>
      <content type="html"><![CDATA[<h2 id="0x01-字符串加密"><a href="#0x01-字符串加密" class="headerlink" title="0x01 字符串加密"></a>0x01 字符串加密</h2><blockquote><h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>在开发中我们总是会用到加解密，有些同学可能不注意会直接把对称加密的key直接写到程序中，这样使用Hopper或者IDA静态分析的时候是可以直接看到加密的key，这样容易被别人破解，所以需要采用一些方法对文件里面的key进行加密，使得在静态分析阶段无法直接获取加密的key，增加逆向难度。</p><h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>在这里我们可以使用异或计算方法对某一个key进行加密，异或的原理是如果二进制位相同则为0，不相同则为1，如果a^b = c,那么b^c=a。</p></blockquote><a id="more"></a><blockquote><p>代码参考如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#define XOR_KEY 0xBB</span><br><span class="line"></span><br><span class="line">void xorString(unsigned char *str, unsigned char key)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char *p = str;</span><br><span class="line">    while( ((*p) ^=  key) != &apos;\0&apos;)  p++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testFunction</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char str[] = &#123;(XOR_KEY ^ &apos;e&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;n&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;k&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;e&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;y&apos;),</span><br><span class="line">                           (XOR_KEY ^ &apos;\0&apos;)&#125;;</span><br><span class="line">    xorString(str, XOR_KEY);</span><br><span class="line">    static unsigned char result[6];</span><br><span class="line">    memcpy(result, str, 6);</span><br><span class="line">    NSLog(@&quot;%s&quot;,result);      //output: enkey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>如果在工程中需要加密的字符串很多，这个时候就要遍历文件进行加密，这个时候如果手动查找的话那工作量就会很大，还好Clang可以帮助我们完成这个事情。iOS中有一个libClang提供了Clang的C接口，用于源代码转换成抽象语法树，并对抽象语法树进行便利和分析。具体的操作思路可以看<a href="https://bbs.pediy.com/thread-217991.htm" target="_blank" rel="noopener">iOS加固浅谈之字符串加密</a></p></blockquote><h2 id="0x02-类和方法加密"><a href="#0x02-类和方法加密" class="headerlink" title="0x02 类和方法加密"></a>0x02 类和方法加密</h2><blockquote><h3 id="0x01-1"><a href="#0x01-1" class="headerlink" title="0x01"></a>0x01</h3><p>如果对程序的安全要求更高一点，可以对程序中所有的类和方法进行混淆，也就是用一些乱序无意义的字符串来对程序的类和方法进行替换。但是这个方法有一个弊端，至于什么弊端会在0x04说明</p><h3 id="0x02-1"><a href="#0x02-1" class="headerlink" title="0x02"></a>0x02</h3><p>第一种混淆方法是宏定义，通过增加一个pch文件，在pch文件中将类名和方法名定义成一些无意义的字符串，然后配置prefix Header的路径为pch的路径，这样在静态分析的时候看到的就是乱序的字符串。以下为PCH的内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ifndef PrefixHeader_pch</span><br><span class="line">#define PrefixHeader_pch</span><br><span class="line">// Classes</span><br><span class="line">#ifndef TestClass</span><br><span class="line">#define TestClass l4prfxSkn</span><br><span class="line">#endif</span><br><span class="line">// Methods</span><br><span class="line">#ifndef testClasssMehtod</span><br><span class="line">#define testClasssMehtod l9b0e29rLKJNqI23</span><br><span class="line">#endif // testClasssMehtod</span><br><span class="line">#ifndef testInstanceMethod</span><br><span class="line">#define testInstanceMethod e0lvc2hezXEA2jIBNw</span><br><span class="line">#endif // testInstanceMethod</span><br><span class="line"></span><br><span class="line">#endif /* PrefixHeader_pch */</span><br></pre></td></tr></table></figure><blockquote><p>下面是testClass.h</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface TestClass : NSObject</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">- (void)testInstanceMethod;</span><br><span class="line">+ (void)testClasssMehtod;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>静态分析截图<br><img src="https://upload-images.jianshu.io/upload_images/2269918-0567c17a9a579829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><blockquote><p>通过上面我们已经可以看到静态分析之后完全看不出上面是哪个类调用了哪个方法。</p><h3 id="0x03-1"><a href="#0x03-1" class="headerlink" title="0x03"></a>0x03</h3><p>和字符串加密一样，一个项目中肯定有很多类和很多方法，如果我们手动去宏定义的话那这是一个巨大的工作量，不过还好Github已经有现成的项目来帮我们生成宏定义。<a href="https://github.com/Polidea/ios-class-guard" target="_blank" rel="noopener">ios-class-guard</a>这个项目可以把所有使用系统库符号的dump下来并过滤掉，只生成用户需要混淆的符号。然后将生成的符号添加到pch文件里面即可</p><h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>上面无序随机字符串加密的弊端就是在提交到AppStore审核的时候，苹果会认为你的APP可能会存在隐藏的功能然后拒接你的上架。<br>另外一种解决方法就是将上线无序随机字符串换成有意义的单词，使得方法名看起来是有意义的，但是它的意义却不是该方法真正的作用。</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码混淆 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LLDB解密framework</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/LLDB%E8%A7%A3%E5%AF%86framework/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/LLDB%E8%A7%A3%E5%AF%86framework/</url>
      <content type="html"><![CDATA[<blockquote><p>除了使用dumpdecrypted去解密APP和framework的内容以外，也可以使用LLDB直接从内存中dump出解密后的模块。</p></blockquote><a id="more"></a><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>获取framework文件，查看文件对应的偏移<br>以下是要执行的命令以及解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lemons-iPhone5S:~ root# ps aux | grep WeChat  //查看Wechat的沙盒目录</span><br><span class="line">mobile    2636   0.0  2.7  1019472  27476   ??  Ss    9:14AM   0:15.37 /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app/WeChat</span><br><span class="line">root      3316   0.0  0.0   525920    224 s001  R+    4:52PM   0:00.01 grep WeChat</span><br><span class="line">lemons-iPhone5S:~ root# /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app</span><br><span class="line">-sh: /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app: is a directory</span><br><span class="line">lemons-iPhone5S:~ root# cd /var/containers/Bundle/Application/4C23658C-1FC4-4616-A9CD-84E328C4A5CD/WeChat.app</span><br><span class="line">找到对应的MMCommon.framework，将MMCommon.framework复制到mac</span><br></pre></td></tr></table></figure><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>在mac查看MMCommon.framework的加密偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd MMCommon.framework</span><br><span class="line">otool -hf MMCommon  //查看MMcommon的文件头部的基础信息</span><br><span class="line">otool -arch arm64 -l MMCommon | grep crypt //获取64位机器加密数据信息</span><br></pre></td></tr></table></figure><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p>使用LLDB附加越狱机器，查看MMcommon进程的偏移<br>image list MMCommon<br>通过如下命令dump出解密后的二进制数据<br>memory read –force –outfile ~/Desktop/outputStream –binary –count 3928342 16384+0x00000000384829894</p><ul><li>3928342 是在上述otool -arch 命令中获取到的cryptsize的值，表明当加密数据的的大小</li><li>16384 是在上述otool -arch命令汇总获取到的cryptoff的值，代表加密的数据在MMCommon中偏移</li><li>0x00000000384829894 是在上述image list MMCommon中的模块基地址</li></ul><p>上述命令执行完成之后会在桌面生成一个outputStream文件</p><h2 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h2><p>修复文件，因为dump出来的文件都没有mach-O文件头，所以需要把dump出来的数据放回原来的framework里面，替换原来加密的数据</p><p>dd seek=2384834 bs=1 conv=notrunc if=/Users/lemon/Desktop/outputSteam of=./MMCommon</p><p>lipo MMCommon -thin arm64 -output MMCommon_arm64</p><ul><li>2384834是上述otool -hf的时候architecture 1中的offset的值加上16384（加密数据偏移的值），两者相加，得到了写入的加密数据在文件中的偏移值。</li><li>替换之后，使用lipo 从FAT文件中提取arm64架构的文件。将MMcommon_arm64拖到MachOView中，修改cryptid为00000000。</li></ul>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dumpdecrypted介绍及其使用</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/dumpdecrypted%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/dumpdecrypted%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><blockquote><p>dumpdecrypted 是一个开源的工具，它会注入可执行文件中，动态的从内存中dump解密后的内容。</p></blockquote><p>##2.原始版dumpdecrypted使用</p><p>###2.1下载以及编译dumpdecrypted</p><blockquote><p>从github下载源代码并且编译：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MacBookPro:dumpdecrypted lemon$ git clone https://github.com/stefanesser/dumpdecrypted.git</span><br><span class="line">Cloning into &apos;dumpdecrypted&apos;...</span><br><span class="line">remote: Counting objects: 31, done.</span><br><span class="line">remote: Total 31 (delta 0), reused 0 (delta 0), pack-reused 31</span><br><span class="line">Unpacking objects: 100% (31/31), done.</span><br><span class="line">MacBookPro:dumpdecrypted lemon$ cd dumpdecrypted/</span><br><span class="line">MacBookPro:dumpdecrypted lemon$ make</span><br><span class="line">`xcrun --sdk iphoneos --find gcc` -Os  -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -c -o dumpdecrypted.o dumpdecrypted.c</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-2-用PS命令定位待解密的可执行文件"><a href="#2-2-用PS命令定位待解密的可执行文件" class="headerlink" title="2.2 用PS命令定位待解密的可执行文件"></a>2.2 用PS命令定位待解密的可执行文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MacBookPro:~ lemon$ ssh 5s</span><br><span class="line">lemons-iPhone5S:~ root# ps -e | grep /var</span><br><span class="line">  481 ??         0:05.44 /usr/libexec/pkd -d/var/db/PlugInKit-Annotations</span><br><span class="line"> 6707 ??         0:06.07 /var/containers/Bundle/Application/4503A878-7B82-46C3-B938-8D8719A6D78E/Friday.app/Friday</span><br><span class="line"> 6715 ttys000    0:00.01 grep /var</span><br></pre></td></tr></table></figure><h3 id="2-3-获取目标APP的document目录"><a href="#2-3-获取目标APP的document目录" class="headerlink" title="2.3 获取目标APP的document目录"></a>2.3 获取目标APP的document目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lemons-iPhone5S:~ root# cat /var/containers/Bundle/Application/4503A878-7B82-46C3-B938-8D8719A6D78E/Friday.app/Info.plist | grep CFBundleIdentifier -A 1</span><br><span class="line">    &lt;key&gt;CFBundleIdentifier&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;com.xtuone.Friday&lt;/string&gt;</span><br></pre></td></tr></table></figure><h3 id="2-4-将dylib复制到document目录"><a href="#2-4-将dylib复制到document目录" class="headerlink" title="2.4 将dylib复制到document目录"></a>2.4 将dylib复制到document目录</h3><h4 id="2-4-1-通过私有api获取目标app的document目录"><a href="#2-4-1-通过私有api获取目标app的document目录" class="headerlink" title="2.4.1 通过私有api获取目标app的document目录"></a>2.4.1 通过私有api获取目标app的document目录</h4><blockquote><p>新建一个xcode项目，将以下代码复制到APPDelegate的application:didfinishLaunchingWithOptions:下，然后运行项目，就可以在控制器输出document的目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *bundleId = @&quot;com.xtuone.Friday&quot;;</span><br><span class="line">    NSURL *url = [[NSClassFromString(@&quot;LSApplicationProxy&quot;) performSelector:@selector(applicationProxyForIdentifier:) withObject:bundleId]performSelector:@selector(dataContainerURL)];</span><br><span class="line">    NSLog(@&quot;%@&quot;,[url.absoluteString stringByAppendingString:@&quot;/Documents&quot;]);</span><br></pre></td></tr></table></figure><blockquote><p>通过以上代码获得的document目录是：/var/mobile/Containers/Data/Application/06B16FDB-4EA1-4093-A729-613111061798/Documents</p></blockquote><p>####2.4.2 通过cycript获取目标app的document目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lemons-iPhone5S:~ root# cycript -p 6707</span><br><span class="line">cy# [[NSBundle mainBundle]bundleIdentifier]</span><br><span class="line">@&quot;com.xtuone.Friday&quot;</span><br><span class="line">cy# NSHomeDirectory()</span><br><span class="line">@&quot;/var/mobile/Containers/Data/Application/06B16FDB-4EA1-4093-A729-613111061798&quot;</span><br><span class="line">cy#</span><br></pre></td></tr></table></figure><h4 id="2-4-3-复制dumpdecrypted-dylib到上述的document路径中"><a href="#2-4-3-复制dumpdecrypted-dylib到上述的document路径中" class="headerlink" title="2.4.3 复制dumpdecrypted.dylib到上述的document路径中"></a>2.4.3 复制dumpdecrypted.dylib到上述的document路径中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 dumpdecrypted.dylib root@localhost:/var/mobile/Containers/Data/Application/06B16FDB-4EA1-4093-A729-613111061798/Documents</span><br></pre></td></tr></table></figure><h3 id="2-5-解密"><a href="#2-5-解密" class="headerlink" title="2.5 解密"></a>2.5 解密</h3><blockquote><p>通过DYLD_INSERT_LIBRARIES注入解密</p></blockquote><h2 id="3-通过frida-ios-dump-来给应用脱壳"><a href="#3-通过frida-ios-dump-来给应用脱壳" class="headerlink" title="3 通过frida-ios-dump 来给应用脱壳"></a>3 通过<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a> 来给应用脱壳</h2><h2 id="4-Clutch"><a href="#4-Clutch" class="headerlink" title="4 Clutch"></a>4 <a href="https://github.com/KJCracks/Clutch" target="_blank" rel="noopener">Clutch</a></h2><blockquote><p>clutch同样是一个开源解密工具，与dumpdecrypted不同的是，Clutch会生成一个新的进程，然后暂停进程并且dump内存来生成新的ipa。</p></blockquote><h3 id="4-1-下载并编译Clutch"><a href="#4-1-下载并编译Clutch" class="headerlink" title="4.1 下载并编译Clutch"></a>4.1 下载并编译Clutch</h3><blockquote><p>git clone  <a href="https://github.com/KJCracks/Clutch" target="_blank" rel="noopener">https://github.com/KJCracks/Clutch</a><br>下载完成之后用xcode打开工程，设置Debug生成所有的架构，设置Build Active Architecture 为 NO ，选择真机设备 command+B 编译。编译完成之后在本地的Build文件夹里面会有一个Clutch的命令行文件</p></blockquote><h3 id="4-2-将文件复制到设备中"><a href="#4-2-将文件复制到设备中" class="headerlink" title="4.2 将文件复制到设备中"></a>4.2 将文件复制到设备中</h3><blockquote><p>使用如下命令，把生成的Build/Clutch复制到设备/usr/bin目录下，并且设置可执行权限。<br>scp -P 2222 root@localhost:/usr/bin<br>ssh 5s<br>chmod +x /usr/bin/Cluch</p></blockquote><h3 id="4-3-Clutch解密"><a href="#4-3-Clutch解密" class="headerlink" title="4.3 Clutch解密"></a>4.3 Clutch解密</h3><blockquote><p>SSH到越狱设备，使用Clutch -i 运行获取目标target的BundleID<br>使用Clutch -b target.BundleID来解密</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lemons-iPhone5S:~ root# Clutch -b com.xtuone.Friday</span><br><span class="line">2018-06-21 16:46:11.732 Clutch[6958:1126993] command: Only dump binary files from specified bundleID</span><br><span class="line">Zipping Friday.app</span><br><span class="line">Dumping &lt;FridayExtensionOC&gt; (arm64)</span><br><span class="line">Patched cryptid (64bit segment)</span><br><span class="line">Writing new checksum</span><br><span class="line">2018-06-21 16:46:12.872 clutch[6960:1127016] command: Only dump binary files from specified bundleID</span><br><span class="line">Failed to dump framework (null) :(</span><br><span class="line">Dumping &lt;Friday&gt; (arm64)</span><br><span class="line">Patched cryptid (64bit segment)</span><br><span class="line">Writing new checksum</span><br><span class="line">Zipping lame.framework</span><br><span class="line">Zipping FridayExtensionOC.appex</span><br><span class="line">DONE: /private/var/mobile/Documents/Dumped/com.xtuone.Friday-iOS8.0-(Clutch-(null)).ipa</span><br><span class="line">Finished dumping com.xtuone.Friday in 20.8 seconds</span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>给应用砸壳实际上有两种方法，一种是基于DYLD_INSERT_LIBRARIES环境变量将动态库注入到目标进程，然后dump内存。另外一种是通过posix_spawnp创建一个进程，然后dump内存。</p>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dumpdecrypted </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 逆向常用工具</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/iOS-%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/iOS-%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h2 id="mac工具"><a href="#mac工具" class="headerlink" title="mac工具"></a>mac工具</h2><h3 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h3><ul><li><a href="https://iterm2.com/" target="_blank" rel="noopener">iTerm2</a></li></ul><blockquote><p>代替默认的Terminal，提供了很多高级设置，例如自动补全，高亮等等</p></blockquote><ul><li><a href="https://github.com.robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a></li></ul><blockquote><p>自定义主题，git显示，Tab补全等</p></blockquote><ul><li><a href="http://zipzapmac.com/go2shell" target="_blank" rel="noopener">Go2Shell</a></li></ul><blockquote><p>从finder中打开终端并且自动切换到当前目录</p></blockquote><ul><li><a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a></li></ul><blockquote><p>工作流软件，快速打开软件，添加自己的工作流。参见<a href="https://bestswifter.gitbook.io/effectivemac/mac-gong-zuo-liu/alfred-jian-jie" target="_blank" rel="noopener">bestswifter的博客</a></p></blockquote><a id="more"></a><h3 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h3><ul><li><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a></li></ul><blockquote><p>MacOS的包管理器，快速安装各种工作</p></blockquote><ul><li><a href="https://github.com/libimobiledevice" target="_blank" rel="noopener">libimobiledevice</a></li></ul><blockquote><p>提供了很多能与iOS交付的工具，例如端口映射查看日志，安装程序</p></blockquote><h3 id="逆向工具"><a href="#逆向工具" class="headerlink" title="逆向工具"></a>逆向工具</h3><ul><li><a href="http://www.newosxbook.com/tools/jtool.html" target="_blank" rel="noopener">jtool</a></li></ul><blockquote><p>查看文件的结构，代码签名</p></blockquote><ul><li><a href="http://www.capstone-engine.org/" target="_blank" rel="noopener">capstone</a></li></ul><blockquote><p>多平台，多架构支持的反汇编框架</p></blockquote><ul><li><a href="https://github.com/keystone-engine/keystone" target="_blank" rel="noopener">keystone</a></li></ul><blockquote><p>将汇编指令转换成Hex机器码</p></blockquote><ul><li><a href="https://github.com/radare/radare2" target="_blank" rel="noopener">redare2</a></li></ul><blockquote><p>一款开放源代码的逆向工程平台</p></blockquote><ul><li><a href="https://github.com/imkira/mobiledevice" target="_blank" rel="noopener">mobiledevice</a></li></ul><blockquote><p>安装app或者ipa包</p></blockquote><ul><li><a href="http://www.i-funbox.com/" target="_blank" rel="noopener">iFunBox</a></li></ul><blockquote><p>查看越狱设备的文件目录</p></blockquote><ul><li><a href="https://github.com/stefanesser/dumpdecrypted.git" target="_blank" rel="noopener">dumpdecrypted</a></li></ul><blockquote><p>dumpdecrypted 是一个开源的砸壳工具，它会注入可执行文件，动态的从内存中dump出解密后的内容。使用教程请看<a href="">这里</a></p></blockquote><ul><li><a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">class-dump</a></li></ul><blockquote><p>class-dump 是一个用于从可执行文件中获取类，方法和属性的工具，上述源代码在导出ARMV7架构的时候会出问题，原因是在读取类没有分64和32位系统进行不同的操作，最新的fix bug的源码在<a href="https://github.com/AloneMonkey/class-dump" target="_blank" rel="noopener">AloneMonkey/Class-dump</a></p></blockquote><ul><li><a href="https://revealapp.com" target="_blank" rel="noopener">Reveal</a></li></ul><blockquote><p>Reveal 是一个用户动态查看APP UI层级架构的工具，可以在开发过程中动态调试修改程序的样式，也可以注入第三方APP以查看应用的界面结构。<br>有两种方式可以使用Reveal，第一种是正向开发的时候通过pod的方式加入Reveal</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target &apos;RevealAPP&apos; do</span><br><span class="line">    pod &apos;Reveal-SDK&apos;, :configurations=&gt; [&apos;Debug&apos;]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>第二种方式是越狱设备注入Raveal,可以调试所有的APP，在越狱设备，可以将RevealServer重命名为libReveal.dylib，以及新建libReveal.plist文件，里面输入需要调试的APP的BundleID</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   Filter = &#123;</span><br><span class="line">         Bundles = (</span><br><span class="line">             &quot;com.lemon.example&quot;,</span><br><span class="line">         );</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上两个文件复制到越狱设备的 /Library/MobileSubstrate/DynamicLibraries/目录下，这样可以通过Cydia Substrate的MobileLoader在程序运行的时候通过dyld_insert_libraries命令将自己加载到目标APP的Document目录下，然后查找上述路径的所有的plist，找到对应的Bundleid之后，通过dlopen()函数将动态库注入到APP中 </p><h2 id="越狱设备工具"><a href="#越狱设备工具" class="headerlink" title="越狱设备工具"></a>越狱设备工具</h2><ul><li>cydia</li></ul><blockquote><p>cydia是一个可以让用户在越狱设备上面安装各种插件的软件管理器，相当于越狱设备的APPStore</p></blockquote><ul><li>SSH</li></ul><blockquote><p>SSH是一种网络协议，用于计算机之前的加密登录，他存在多种实现，因为不同系统使用的越狱工具不一样，所以需要根据iOS的版本来进行设置。<br>iOS8 &amp; iOS9 ，可以通过安装OpenSSH来登录，安装方法：1.在cydia中搜索OpenSSH并且安装，安装完成之后打开Wifi设置界面，打开当前连接的wifi，获取ip地址(假设是192.168.2.21)，然后打开终端，输入以下命令后回车： ssh <a href="mailto:root@192.168.2.21" target="_blank" rel="noopener">root@192.168.2.21</a>  2.稍等片刻之后输入yes并且回车，然后输入默认密码alpine完成登录。（当远程主机的公钥被接受以后，他会保存到mac的$HOME/.ssh/known_hosts文件中，再次连接这台主机时，系统就会认出他的公钥已经保存到本地，从而跳过警告部分，直接提示用户输入密码。）<br>iOS10.0 &amp; iOS10.2 ，越狱工具yalu内置了一个相对轻量级的工具dropbear，供用户直接使用。安装方法：1.在cydia中搜索MTerminal和adv-cmds，然后运行ps aux | grep dropbear 命令。如果有输出内容，则代表默认支持usb连接，如果这是要连接，在mac上转发端口即可登录，命令如下：<br>iproxy 22 2222<br>ssh root@localhost -p 2222<br>如果要通过wifi连接，需要在终端设备执行一下命令<br>/usr/local/bin/dropbear -F -R -p 22<br>然后在mac上直接SSH登录<br>ssh <a href="mailto:root@192.168.2.21" target="_blank" rel="noopener">root@192.168.2.21</a></p></blockquote><ul><li><a href="通过cydia安装">iFile</a></li></ul><blockquote><p>查看越狱设备的文件目录</p></blockquote><ul><li><a href="从cydia安装">cydia substrate</a></li></ul><blockquote><p>cydia substrate是一个框架，允许第三方开发者在越狱系统方法里面打一下运行时补丁和扩展一些方法，是开发越狱插件的基石。cydia substrate主要包含三个模块，分别是MobileHooker,MObileLoader,Safe mode。<br>MobileHooker 用于替换系统或者应用的方法，它提供了MSHookMessageEX 来hook OC的函数，MSHookFunction来hook C函数。<br>MobileLoader 用于将第三方动态库加载到目标应用里面。首先它会通过dyld_insert_libraries将自己加载到目标程序里面，然后通过查找/Library/MobileSubstrate/DynamicLibraries/目录下的所有plist文件，如果plist文件里面包含有当前应用的BundleID，那么就会通过dlopen()函数打开对应的dylib文件。<br>safe mode 当插件加载导致了系统奔溃时，mobilesafety会捕捉到这个异常并且让设备进入安全模式。找到最近安装的导致奔溃的插件并且卸载即可退出安全模式。</p></blockquote><ul><li>adv-cmds</li></ul><blockquote><p>提供ps命令</p></blockquote><ul><li>appsync</li></ul><blockquote><p>让系统不再校验应用的签名</p></blockquote><ul><li>scp</li></ul><blockquote><p>对于iOS10以后的版本，使用yalu越狱之后就没有scp这个工具了，可以在网上找到scp的源代码使用iFunBox复制到设备的/usr/bin目录下，然后通过ssh访问该目录，执行以下命令：<br>cd /usr/bin<br>ldid -S scp<br>chmod 777 scp</p></blockquote><ul><li><a href="https://github.com/facebook/chisel" target="_blank" rel="noopener">chisel</a></li></ul><blockquote><p>提供便利的LLDB调试命令<br>安装教程</p><ol><li>brew install chisel</li><li>如果不存在~/.lldbinit文件那就创建一个文件，并且将以下代码放到该文件中<br>#~/.lldbinit<br>…<br>command script import /usr/local/opt/chisel/libexec/fblldb.py</li><li>重启Xcode或者在LLDB中输入 command source ~/.lldbinit命令在加载脚本。</li></ol></blockquote><h3 id="安全工具"><a href="#安全工具" class="headerlink" title="安全工具"></a>安全工具</h3><ul><li><a href="https://github.com/Polidea/ios-class-guard" target="_blank" rel="noopener">ios-class-guard</a></li></ul><blockquote><p>该工具是从class-dump fork出来的，用于dump出APP中的类和方法并且生成混淆代码，将生成的混淆的宏定义添加到项目的pch文件中，达到混淆所有的类和方法的作用</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iOS 逆向常用命令</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/iOS-%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/iOS-%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="1-查看信息相关"><a href="#1-查看信息相关" class="headerlink" title="1. 查看信息相关"></a>1. 查看信息相关</h3><ul><li>查看越狱设备所有的APP的BundleID （前提需要安装frida-iOS-dump）</li></ul><blockquote><p>MacBookPro:frida-ios-dump-master lemon$ ./dump.py -l</p></blockquote><ul><li>查看设备UDID (前提需要安装ideviceinstall)</li></ul><blockquote><p>MacBookPro:~ lemon$ idevice_id  -l</p></blockquote><ul><li>查看iPA是否已经砸壳 (如果返回cryptid=0代表已砸壳，否则代表未砸壳)</li></ul><blockquote><p>MacBookPro:~ lemon$ otool -l target.app/target | grep cryptid</p></blockquote><a id="more"></a><ul><li>查看设备日志</li></ul><blockquote><p>MacBookPro:~ lemon$ idevicesyslog -u deviceudid</p></blockquote><ul><li>给特定的设备安装程序</li></ul><blockquote><p>MacBookPro:~ lemon$ ideviceinstaller -i target.ipa -u  deviceudid</p></blockquote><ul><li>砸壳 (使用frida)</li></ul><blockquote><p>MacBookPro:frida-ios-dump-master lemon$ ./dump.py BundleID</p></blockquote><ul><li>class-dump头文件</li></ul><blockquote><p>MacBookPro:~ lemon$ class-dump -s -S -H target.app/target -o /path/to/save/header</p></blockquote><ul><li>查看动态库架构</li></ul><blockquote><p>lipo -info</p></blockquote><ul><li>ssh</li></ul><blockquote><p>ssh root@deviceip</p></blockquote><ul><li>查找进程</li></ul><blockquote><p>ps aux | grep /App<br>ps -e | grep /Applications</p></blockquote><ul><li>查找文件</li></ul><blockquote><p>grep -r Header /System/Library/</p></blockquote><ul><li>分离fat binary</li></ul><blockquote><p>lipo -thin armv7 WeChat.decrypted -output WeChat_armv7.decrypted<br>lipo -thin arm64 xxx.decryptec -output xxx.arm64.decrypted</p></blockquote><h3 id="2-LLDB"><a href="#2-LLDB" class="headerlink" title="2. LLDB"></a>2. LLDB</h3><ul><li>打印UI结构</li></ul><blockquote><p>po [[[UIWindow keyWindow] rootViewController] _printHierarchy]    (iOS 8)<br>po [[UIWindow keyWindow] recursiveDescription]</p></blockquote><ul><li>打印调用栈信息</li></ul><blockquote><p>bt (backtrace)<br>bt all (all threads)</p></blockquote><ul><li>objc_msgSend参数打印</li></ul><blockquote><p>po $xo</p></blockquote><blockquote><p>p (char*)$x1</p></blockquote><blockquote><p>p (SEL)$x1</p></blockquote><ul><li>返回地址</li></ul><blockquote><p>p/x $lr</p></blockquote><ul><li>增加断点</li></ul><blockquote><p>b -a ox00002224</p></blockquote><ul><li>列举模块</li></ul><blockquote><p>image lisg -o -f </p></blockquote><ul><li>lldb基础指令</li></ul><blockquote><p>c<br>n<br>ni<br>br list<br>br del<br>br dis<br>br en</p></blockquote><ul><li>远程调试</li></ul><blockquote><p>debugserver *:1234 -a pid</p></blockquote><blockquote><p>debugserver -x backboard *:1234 /var/mobile/Containers/Bundle/Application/9DB7CE45-3B4C-42A3-9D4D-49A3A5122903/AlipayWallet.app/AlipayWallet</p></blockquote><ul><li>远程连接</li></ul><blockquote><p>proces connect connect://192.168.2.154:1234</p></blockquote><ul><li>lldb expr例子</li></ul><blockquote><p>(lldb) expr char <em>$str = (char </em>)malloc(8)</p><p>(lldb) expr (void)strcpy($str, “munkeys”)</p><p>(lldb) expr $str[1] = ‘o’</p><p>(char) $0 = ‘o’</p><p>(lldb) p $str</p><p>(char *) $str = 0x00007fd04a900040 “monkeys”</p><p>(lldb) x/4c $str</p><p>(lldb) x/1w <code>$str + 3</code></p><p>(lldb) expr (void)free($str)</p><p>(lldb) expr id $myView = (id)0x7f82b1d01fd0</p><p>(lldb) expr (void)[$myView setBackgroundColor:[UIColor blueColor]]</p><p>(lldb) expr (void)[CATransaction flush]</p><p>(lldb) po [$myButton allTargets]</p><p>(lldb) p (ptrdiff_t)ivar_getOffset((struct Ivar *)class_getInstanceVariable([MyView class], “_layer”))</p></blockquote><ul><li>给断点增加命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br command add 1</span><br><span class="line">Enter your debugger command(s).  Type &apos;DONE&apos; to end.</span><br><span class="line">&gt; register read $rdi </span><br><span class="line">&gt; c </span><br><span class="line">&gt; DONE</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><ul><li>修改寄存器的值</li></ul><blockquote><p>register write x0 1</p></blockquote><h3 id="3-Cycript"><a href="#3-Cycript" class="headerlink" title="3. Cycript"></a>3. Cycript</h3><ul><li>查看当前界面的元素层级结构</li></ul><blockquote><p>cy# [[UIApp keyWindow]recursiveDescription].toString()</p></blockquote><ul><li>查看当前keywindow的根控制器的所有subView</li></ul><blockquote><p>cy# [[[UIApp keyWindow] rootViewController] _printHierarchy].toString()</p></blockquote><ul><li>输出简单的视图信息</li></ul><blockquote><p>cy# [[UIApp keyWindow] _autolayoutTrace].toString()</p></blockquote><ul><li>查看一个实例的所有ivar</li></ul><blockquote><p>cy# [choose(SBApplication)[0] _ivarDescription].toString()</p></blockquote><ul><li>查看一个class的对象方法和类方法</li></ul><blockquote><p>cy# [choose(SBApplicationController)[0] _methodDescription].toString()</p></blockquote><ul><li>访问对象和实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cy# [#0xb226710 url]</span><br><span class="line">@&quot;ww4fd1rfRDShBo_4K6rqfwAAACMAAQED&quot;</span><br><span class="line"></span><br><span class="line">cy# c = #0x1752d8c0</span><br><span class="line">cy#&quot;&lt;FavAudioPlayerController: 0x1752d8c0; frame = (0 0; 290 60); autoresize = W; layer = &lt;CALayer: 0x172dc2b0&gt;&gt;&quot;</span><br><span class="line">cy# c-&gt;m_audioInfo</span><br><span class="line">cy#&quot;&lt;FavAudioInfo: 0x172b2a30&gt;&quot;</span><br><span class="line">cy# c-&gt;m_audioInfo.m_nsAudioPath</span><br></pre></td></tr></table></figure><h3 id="4-ARM"><a href="#4-ARM" class="headerlink" title="4. ARM"></a>4. ARM</h3><h3 id="5-工具"><a href="#5-工具" class="headerlink" title="5. 工具"></a>5. 工具</h3><ul><li><a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpdecrypted</a></li><li><a href="https://github.com/theos/theos" target="_blank" rel="noopener">theos</a></li><li><a href="https://cgit.sukimashita.com/usbmuxd.git/" target="_blank" rel="noopener">usbmuxd</a> </li><li><a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a></li><li><a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">class-dummp</a></li><li><a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a></li></ul>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>通过theos提供的logify来为类的所有方法添加追踪日志</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/%E9%80%9A%E8%BF%87theos%E6%8F%90%E4%BE%9B%E7%9A%84logify%E6%9D%A5%E4%B8%BA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E8%BF%BD%E8%B8%AA%E6%97%A5%E5%BF%97/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/%E9%80%9A%E8%BF%87theos%E6%8F%90%E4%BE%9B%E7%9A%84logify%E6%9D%A5%E4%B8%BA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E8%BF%BD%E8%B8%AA%E6%97%A5%E5%BF%97/</url>
      <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>###logify是THEOS自带的为代码添加Log的工具，可以使用该工具给指定的类添加Log代码并且生成一个新的Tweak.xm文件</p><h2 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h2><h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h3><h4 id="2-1-1-安装Theos"><a href="#2-1-1-安装Theos" class="headerlink" title="2.1.1 安装Theos"></a>2.1.1 安装Theos</h4><p> 首先需要安装<a href="https://github.com/theos/theos" target="_blank" rel="noopener">Theos</a>，安装完成之后会默认安装此工具。</p><a id="more"></a><h4 id="2-1-2-将APP脱壳，有两种方式可以获得脱壳的APP"><a href="#2-1-2-将APP脱壳，有两种方式可以获得脱壳的APP" class="headerlink" title="2.1.2 将APP脱壳，有两种方式可以获得脱壳的APP"></a>2.1.2 将APP脱壳，有两种方式可以获得脱壳的APP</h4><h5 id="2-1-2-1-无越狱机"><a href="#2-1-2-1-无越狱机" class="headerlink" title="2.1.2.1 无越狱机"></a>2.1.2.1 无越狱机</h5><p>通过PP助手去越狱市场下载脱壳的ipa，有时下载下来的也不一定是脱壳后的，你可以通过在终端执行以下命令<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -l target.app/target | grep crypt</span><br></pre></td></tr></table></figure></p><p> 如果输出<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cryptoff 16384</span><br><span class="line">cryptsize 58753024</span><br><span class="line">cryptid 0 //0 代表已经砸壳，1代表未砸壳</span><br></pre></td></tr></table></figure></p><h5 id="2-1-2-2-有越狱机"><a href="#2-1-2-2-有越狱机" class="headerlink" title="2.1.2.2 有越狱机"></a>2.1.2.2 有越狱机</h5><p> 你需要一台越狱机器，安装完整版之后通过工具来脱壳，这个时候你也有两个方法获得脱壳应用。方法一：你可以使用<a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpdecrypted</a>工具来砸壳。方式二：你也可以使用庆总开源的工具<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-iOS-dump</a>一条命令行进行砸壳。</p><h4 id="2-1-3-class-dump-出头文件"><a href="#2-1-3-class-dump-出头文件" class="headerlink" title="2.1.3 class-dump 出头文件"></a>2.1.3 class-dump 出头文件</h4><p>通过以上的方式得到砸壳后的应用之后，需要利用<a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">clas-dump</a>工具dump出头文件。具体的用法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class-dump -s -S -H target.app/target -o /path/to/save/header</span><br></pre></td></tr></table></figure><h4 id="2-1-4-使用logify工具生成Tweak-xm文件"><a href="#2-1-4-使用logify工具生成Tweak-xm文件" class="headerlink" title="2.1.4 使用logify工具生成Tweak.xm文件"></a>2.1.4 使用logify工具生成Tweak.xm文件</h4><p>该文件里面会hook该头文件对应的类，并且会在代码里面加上Log打印<br>用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logify.pl HookHeader.h的全路径 &gt;Tweak.xm</span><br></pre></td></tr></table></figure><p>如果要跟踪多个头文件，则继续转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logify.pl 其它头文件 &gt;&gt; Tweak.xm</span><br></pre></td></tr></table></figure><p> <em>注意中间是 &gt;&gt;</em></p><h4 id="2-1-5-使用nic-pl命令来生成Theos工程，选择Teak工具。"><a href="#2-1-5-使用nic-pl命令来生成Theos工程，选择Teak工具。" class="headerlink" title="2.1.5 使用nic.pl命令来生成Theos工程，选择Teak工具。"></a>2.1.5 使用nic.pl命令来生成Theos工程，选择Teak工具。</h4><h4 id="2-1-6-创建完Tweak工程之后，将在2-1-4中生成的Tweak-xm替换掉工程中的Teak-xm-不过此时还需要对该文件做一些修改"><a href="#2-1-6-创建完Tweak工程之后，将在2-1-4中生成的Tweak-xm替换掉工程中的Teak-xm-不过此时还需要对该文件做一些修改" class="headerlink" title="2.1.6 创建完Tweak工程之后，将在2.1.4中生成的Tweak.xm替换掉工程中的Teak.xm.不过此时还需要对该文件做一些修改"></a>2.1.6 创建完Tweak工程之后，将在2.1.4中生成的Tweak.xm替换掉工程中的Teak.xm.不过此时还需要对该文件做一些修改</h4><p>a.去掉.cxx_destruct 方法</p><p>b.将HBLogDebug 改为NSLog</p><p>然后修改makefile文件，在最上面那一行增加<br>THEOS_DEVICE_IP = 你的设备的IP</p><h4 id="2-1-7"><a href="#2-1-7" class="headerlink" title="2.1.7"></a>2.1.7</h4><p> 使用一下make package install 生成deb包，并且安装到越狱设备上。</p><h4 id="2-1-8-运行目标APP，观察日志。"><a href="#2-1-8-运行目标APP，观察日志。" class="headerlink" title="2.1.8 运行目标APP，观察日志。"></a>2.1.8 运行目标APP，观察日志。</h4><p> 有两种方法可以观察日志，第一种是通过xcode-&gt;window-&gt;Device and simulators-&gt;view device logs 。<br> 第二种是通过idevicesyslog -u udid 来查看特定设备的日志。这种方式需要安装<a href="https://www.jianshu.com/p/746f3ddded1f" target="_blank" rel="noopener">libimobiledevice</a></p>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logify </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>导出iOS真机缓存的dyld_shared_cache_arm64文件</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/%E5%AF%BC%E5%87%BAiOS%E7%9C%9F%E6%9C%BA%E7%BC%93%E5%AD%98%E7%9A%84dyld-shared-cache-arm64%E6%96%87%E4%BB%B6/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/%E5%AF%BC%E5%87%BAiOS%E7%9C%9F%E6%9C%BA%E7%BC%93%E5%AD%98%E7%9A%84dyld-shared-cache-arm64%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h3 id="1前言"><a href="#1前言" class="headerlink" title="1前言"></a>1前言</h3><p>在iOS系统中，存在着这么一个文件夹，/System/Library/Caches/com.apple.dyld，这个文件夹里面放着的是什么文件呢，在我的iphone5s中，两个文件dyld_shared_cache_armv7s和dyly_shared_arm64，这两个文件分别代表两个arm架构，一个是armv7s一个是arm64。</p><a id="more"></a><p>顾名思义，这两个都是缓存文件，里面放着的都是各种系统所可能用到的动态库。如Foundation.framework,Security.framework等等。在/System/Library/Frameworks/这个路径下面所有的动态库只放了一些配置文件，而真正的执行文件就在上面说的缓存文件里面。因为几乎所有的iOS程序都会用到系统库，当程序运行的时候会使用dyld(位于/usr/lib/dylb)程序进行连接，另一方面，由于每个iOS程序都会连接很多的动态库，如果需要一个一个连接会很耗时，如果把它们放在一个地方打包好，等到运行的时候全部连接岂不美滋滋，基于这些原因，就有了dyld_shared_cache_armv7s和dyld_shared_cache_armv64两个缓存文件（有些设备有可能还会有dyld_shared_cache_armv7）。</p><h4 id="2工具"><a href="#2工具" class="headerlink" title="2工具"></a>2工具</h4><p>上面我已经解释了为什么会存在这两个文件以及这两个文件的作用，在iOS逆向中，我们常常需要查看某一个系统类的实现，这个时候就要去对应的系统库里面查看，这些系统库就放在对应的缓存文件里面了。但是这些文件是经过处理的，不可以直接查看，所以需要用到一些工具来查看。这里介绍两个工具，一个是<a href="https://github.com/kennytm/Miscellaneous/downloads" target="_blank" rel="noopener">dyld_decache[v0.1c]</a> 另外一个是<a href="https://opensource.apple.com/source/dyld/dyld-195.6/launch-cache/dsc_extractor.cpp" target="_blank" rel="noopener">dsc_extractor</a>，<a href="https://www.jianshu.com/p/a7b1fed0359f" target="_blank" rel="noopener">编译方法</a> 。这两个工具的不同之处是，第一个工具是不可以用来解析arm64指令集的缓存文件的，而dsc_extractor是可以用来解析arm64指令集的缓存文件的，现在基本上大家用的都是arm64位指令集的设备了。（iPhone5s以上都是arm64位结构）</p><h4 id="3还原"><a href="#3还原" class="headerlink" title="3还原"></a>3还原</h4><p>通过2中的dyld_decache[v0.1c]工具和dsc_extractor我们可以还原出<br>dyld_shared_cache_armX缓存文件中隐藏的framework。下面是语法</p><p>#####3.1 dsc_extractor<br>usage: dsc_extractor <path-to-cache-file> <path-to-device-dir></path-to-device-dir></path-to-cache-file></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usage: dsc_extractor 你要解析的arm64的缓存文件路径 保存的路径</span><br></pre></td></tr></table></figure><p>解析过程中会出现类似于<br>0/969</p><p>1/969</p><p>2/969</p><p>3/969</p><p>4/969</p><p>5/969</p><p>…..</p><p>这样的文字。</p><h5 id="3-2-dyld-decache-v0-1c"><a href="#3-2-dyld-decache-v0-1c" class="headerlink" title="3.2 dyld_decache[v0.1c]"></a>3.2 dyld_decache[v0.1c]</h5><p>dyld_decache[v0.1c] -o 要保存的路径   你要解析的缓存文件路径</p><p>解析完成后会出现两个文件加，一个是system,另外一个usr，如无意外，所有的动态库都会在里面，接下来尽情的蹂躏他们吧。不过记得在开始这一切之前，要将iphone里面的dyld_shared_cache_arm64文件拷贝一份到OSX上面去操作。</p>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>dsc_extractor的编译和使用</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/dsc-extractor%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/dsc-extractor%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="1前言"><a href="#1前言" class="headerlink" title="1前言"></a>1前言</h3><p>在iOS逆向中，我们常常需要对dyld_shared_cache_armX类型的文件进行还原，第一个我们经常使用的是dyld_decache工具，但是这个工具并不能用从来还原dyld_shared_cache_arm64文件，也就是64位指令集架构的缓存文件，这个时候dsc_extractor就为你续命了。</p><a id="more"></a><h3 id="2编译"><a href="#2编译" class="headerlink" title="2编译"></a>2编译</h3><p>打开终端依次执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir dsc_extractor</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd dsc_extractor</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://opensource.apple.com/tarballs/dyld/dyld-210.2.3.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf dyld-210.2.3.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd dyld-210.2.3/launch-cache/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch dsc_extractor.patch</span><br></pre></td></tr></table></figure><p>通过上面的操作，我们下载下来了touch dsc_extractor的源码并且解压出来，并在其中创建了一个touch dsc_extractor.patch的空文件，接下来把以下内容复制到该文件里面去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">--- dyld-210.2.3/launch-cache/dsc_extractor.cpp  2012-05-21 02:35:15.000000000 -0400</span><br><span class="line">+++ dyld-210.2.3/launch-cache/dsc_extractor.cpp2013-07-26 16:05:03.000000000 -0400</span><br><span class="line">@@ -37,6 +37,7 @@</span><br><span class="line"> #include &lt;mach-o/arch.h&gt;</span><br><span class="line"> #include &lt;mach-o/loader.h&gt;</span><br><span class="line"> #include &lt;Availability.h&gt;</span><br><span class="line">+#include &lt;dlfcn.h&gt;</span><br><span class="line"> </span><br><span class="line"> #define NO_ULEB </span><br><span class="line"> #include &quot;Architectures.hpp&quot;</span><br><span class="line">@@ -456,7 +457,7 @@</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">-#if 1</span><br><span class="line">+/* #if 1 */</span><br><span class="line"> </span><br><span class="line"> typedef int (*extractor_proc)(const char* shared_cache_file_path, const char* extraction_root_path,</span><br><span class="line"> void (^progress)(unsigned current, unsigned total));</span><br><span class="line">@@ -468,7 +469,7 @@</span><br><span class="line"> return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">-void* handle = dlopen(&quot;/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle&quot;, RTLD_LAZY);</span><br><span class="line">+void* handle = dlopen(&quot;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle&quot;, RTLD_LAZY);</span><br><span class="line"> if ( handle == NULL ) &#123;</span><br><span class="line"> fprintf(stderr, &quot;dsc_extractor.bundle could not be loaded\n&quot;);</span><br><span class="line"> return 1;</span><br><span class="line">@@ -484,7 +485,7 @@</span><br><span class="line"> fprintf(stderr, &quot;dyld_shared_cache_extract_dylibs_progress() =&gt; %d\n&quot;, result);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line">-#endif</span><br><span class="line">+/* #endif */</span><br></pre></td></tr></table></figure><h3>记住，在+/<em>endif </em>/后面是还有一行空行的。</h3><p>然后执行一下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch &lt; dsc_extractor.patch</span><br></pre></td></tr></table></figure><p>执行完成该命令后，你可以在dsc_extractor.patch文件的同级目录下看到一个dsc_extractor.cpp文件，接下来打开这个文件，要修改里面的内容。如下：<br>原处：230行</p><p>const char* afterSlash = &amp;dirs[1];<br>修改成：</p><p>char* afterSlash = &amp;dirs[1];  去除const<br>原处：460行</p><p>#if 0<br>修改成：</p><p>#if 1<br>原处：488行</p><p>/<em> #endif </em>/<br>修改成：</p><p>#endif 放开注释</p><p>修改完成后，回到终端，运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ -o dsc_extractor dsc_extractor.cpp dsc_iterator.cpp</span><br></pre></td></tr></table></figure><p>到了这里，dsc_extractor终于编译完成了，你可以在同级目录下看到dsc_extractor的执行文件。你可以把它复制到任何地方然后使用。</p><h3 id="3使用"><a href="#3使用" class="headerlink" title="3使用"></a>3使用</h3><p>编译dsc_extractor成功后，用iFunBox将iOS 里面的/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64复制到OSX的任何位置，然后在终端运行</p><p>dsc_extractor完成路径 arm64缓存文件路径  要保存文件的路径</p><p>然后终端显示<br>0/1004<br>1/1004<br>2/1004<br>3/1004<br>4/1004<br>5/1004<br>6/1004<br>7/1004<br>这样的文本的时候就成功了</p>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dsc-extractor </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 基础汇编知识</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS-%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS-%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h3 id="1-寄存器-内存-栈"><a href="#1-寄存器-内存-栈" class="headerlink" title="1 寄存器 内存  栈"></a>1 寄存器 内存  栈</h3><p>在高级语言里面，操作对象是变量，在ARM汇编里面，操作对象是寄存器（register），内存和栈(stack)</p><a id="more"></a><h3 id="2-数据操作指令"><a href="#2-数据操作指令" class="headerlink" title="2 数据操作指令"></a>2 数据操作指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op &#123;cond&#125;&#123;s&#125; Rd, Rn, Op2</span><br></pre></td></tr></table></figure><p>其中，cond和s是两个可选后缀，cond用来指定指令op在什么条件下执行，共有下面17种条件。</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>EQ</td><td>结果为0, Equal to 0</td></tr><tr><td>NE</td><td>结果不为0，Not Equal to 0</td></tr><tr><td>CS</td><td>有进位或者借位  Carry Set</td></tr><tr><td>HS</td><td>同CS,unsigned Higher or same</td></tr><tr><td>CC</td><td>没有进位或者借位 Carry clear</td></tr><tr><td>LO</td><td>同CC unsigned Lower</td></tr><tr><td>MI</td><td>结果小于0 ， Minus</td></tr><tr><td>PL</td><td>结果大于0 ， Plus</td></tr><tr><td>VS</td><td>溢出， oVerflow set</td></tr><tr><td>VC</td><td>无溢出  ， oVerflow clear</td></tr><tr><td>HI</td><td>无符号比较大于 ，unsigned higher</td></tr><tr><td>LS</td><td>无符号比较小于，unsigned lower or same</td></tr><tr><td>GE</td><td>有符号比较大于等于 ，signed greater than or Equal</td></tr><tr><td>LT</td><td>有符号比较小于，signed less than</td></tr><tr><td>GT</td><td>有符号比较大于，signed greater than</td></tr><tr><td>LE</td><td>无符号比较小于等于，signed less than equal</td></tr><tr><td>AL</td><td>无条件（Always ,默认）</td></tr></tbody></table><p>例如：<br>比较 R0,R1<br>移动 GE R2, R1<br>移动 LT R2, R0<br>比较R0和R1的值，如果R0大于R1，那么R2等于R1,如果R0小于R1，那么R2等于R0。</p><hr><p>s的作用是指定指令op是否设置flag，共有下面四种flag。</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>N（Negative）</td><td>如果结果小于0则置1，否则置0</td></tr><tr><td>Z (Zero)</td><td>如果结果是0则置1，否则置0</td></tr><tr><td>C （Carry）</td><td>对于加操作来说，如果产生进位则置1，否则置0，对于减操作来说，如果产生借位则置0，否则置1，对于有位移的非加/减操作来说，C置移出值的最后一位，对于其他的非加/减操作来说，C的值一般不变</td></tr><tr><td>V（Overflos）</td><td>如果操作溢出则置1，否则置0</td></tr></tbody></table><p>需要注意的是，Cflag表示的是无符号位运算结果是否溢出，Vflag表示的是有符号位数运算结果是否溢出。</p><hr><p>算术操作</p><p>ADD R0, R1, R2 ; R0 = R1 + R2</p><p>ADC R0, R1, R2 ; R0 = R1 + R2 + C(arry)</p><p>SUB R0, R1, R2 ; R0 = R1 - R2</p><p>SBC R0, R1, R2 ; R0 = R1 - R2 - !C</p><p>RSB R0, R1, R2 ; R0 = R2 - R1</p><p>RSC R0, R1, R2 ; R0 = R2 - R1 - !C</p><hr><p>逻辑操作</p><p>AND R0, R1, R2 ; R0 = R1 &amp; R2 //按位与</p><p>ORR R0, R1, R2 ; R0 = R1 | R2 //按位或</p><p>EOR R0, R1, R2 ; R0 = R1 ^ R2 //按位异或</p><p>BIC R0, R1, R2 ; R0 = R1 &amp;~ R2 //按位取反与</p><p>MOV R0, R2 ; R0 = R2  //赋值</p><p>MVN R0, R2 ; R0 = ~R2  //按位取反</p><hr><p>比较操作</p><p>CMP R1, R2 ; 执行R1 - R2并依结果设置flag</p><p>CMN R1, R2 ; 执行R1 + R2并依结果设置flag</p><p>TST R1, R2 ; 执行R1 &amp; R2并依结果设置flag</p><p>TEQ R1, R2 ; 执行R1 ^ R2并依结果设置flag</p><hr><p>乘法操作</p><p>MUL R4, R3, R2 ; R4 = R3 * R2</p><p>MLA R4, R3, R2, R1 ; R4 = R3 * R2 + R1</p><p>乘法操作的操作数必须来自寄存器</p><p>###3 内存操作指令<br>内存操作指令的基本格式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op&#123;cond&#125;&#123;type&#125; Rn, [Rn,?Op2]</span><br></pre></td></tr></table></figure></p><p>其中Rn是基址寄存器，用户存放基地址</p><p>cond的作用于数据操作指令相同，都是用来指定op是在什么条件下执行</p><p>type指定指令op操作的数据类型，共有四种</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>B(unsigned Byte)</td><td>无符号byte，执行时扩展到32bit,以0填充</td></tr><tr><td>SB(Signed Byte)</td><td>有符号byte，仅用于LDR指令，执行时扩展到32bit，以符号位填充</td></tr><tr><td>H (signed Halfword)</td><td>无符号halfword,执行时扩展到32bitj,以0填充</td></tr><tr><td>SH （signed halfword）</td><td>有符号halfword 仅用于LDR指令，执行时扩展到32bit,以符号位填充</td></tr></tbody></table><p>如果不指定byte，则默认的数据类型是word<br>ARM内存操作基础指令只有两个： LDR (LoaD Register)将数据从内存中读出来，存到寄存器中。以及STR(STore Register)将寄存器的数据读出来，存到内存中。两个指令的使用情况如下：</p><p>LDR<br>-<br>LDR Rt, [Rn {,#offset}]  ;  Rt = *(Rn {+ offset}),{}代表可选</p><p>LDR Rt, [Rn, #offset]! ; Rt = *(Rn + offset); Rn<br>= Rn + offset</p><p>LDR Rt, [Rn], #offset ; Rt = *Rn; Rn = Rn +<br>offset</p><p>STR<br>-</p><p>STR Rt, [Rn {, #offset}] ; *(Rn {+ offset}) = Rt</p><p>STR Rt, [Rn, #offset]! ; *(Rn {+ offset}) = Rt; Rn<br>= Rn + offset</p><p>STR Rt, [Rn], #offset ; *Rn = Rt; Rn = Rn +<br>offset</p><p>此外， LDR和STR的变种LDRD和STRD还可以操<br>作双字（ Doubleword），即一次性操作2个寄存器，<br>其基本格式如下：<br>op{cond} Rt, Rt2, [Rn {, #offset}]</p><p>用法及原型类似，如下：<br>STRD R4, R5, [R9,#offset]  ； *(R9+offset) = R4 ,  *(R9+offset+R4) = R5</p><p>LDRD R4, R5, [R9,#offset] ; R4 = *(R9 + offset);<br>R5 = *(R9 + offset + 4)</p><p>除了LDR和STR外，还可以通过LDM（ LoaD<br>Multiple）和STM（ STore Multiple）进行块传输，一<br>次性操作多个寄存器。块传输指令的基本格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op&#123;cond&#125;&#123;mode&#125; Rd&#123;!&#125;, reglist</span><br></pre></td></tr></table></figure><p>其中Rd是基址寄存器，可选的“!”指定Rd变化后<br>的值是否写回Rd； reglist是一系列寄存器，用大括号<br>括起来，它们之间可以用“,”分隔，也可以用“-”表示<br>一个范围，比如， {R4–R6,R8}表示寄存器R4、 R5、<br>R6、 R8；这些寄存器的顺序是按照自身的编号由小<br>到大排列的，与大括号内的排列顺序无关。<br>需要特别注意的是， LDM和STM的操作方向与<br>LDR和STR完全相反： LDM是把从Rd开始，地址连续<br>的内存数据存入reglist中， STM是把reglist中的值存入<br>从Rd开始，地址连续的内存中。</p><p>“cond”的作用与数据操作指令相同。 “mode”指定<br>Rd值的4种变化规律，如下所示：</p><p>IA（ Increment After）<br>每次传输后增加Rd的值；</p><p>IB（ Increment Before）<br>每次传输前增加Rd的值；</p><p>DA（ Decrement After）<br>每次传输后减少Rd的值；</p><p>DB（ Decrement Before）<br>每次传输前减少Rd的值</p><p>示例： 假设R0的值为5</p><p>执行以下命令后， R4、 R5、 R6的值分别变成：<br>foo():<br>LDMIA R0, {R4 – R6} ; R4 = 5, R5 = 6,<br>R6 = 7<br>LDMIB R0, {R4 – R6} ; R4 = 6, R5 = 7,<br>R6 = 8<br>LDMDA R0, {R4 – R6} ; R4 = 5, R5 = 4,<br>R6 = 3<br>LDMDB R0, {R4 – R6} ; R4 = 4, R5 = 3,<br>R6 = 2</p><h4 id="4-分支指令"><a href="#4-分支指令" class="headerlink" title="4 分支指令"></a>4 分支指令</h4><p>分支指令可以分为无条件分支和条件分支两种。</p><p>. 无条件分支<br>foo():<br>B Label ; 跳转到Label处往下执行<br>…… ; 得不到执行<br>Label:<br>……</p><p>. 条件分支</p><p>条件分支的cond是依照6.2.1节提到的4种flag来判<br>断的，它们的对应关系如下：<br>cond flag<br>EQ Z = 1</p><p>NE Z = 0</p><p>CS C = 1</p><p>HS C = 1</p><p>CC C = 0</p><p>LO C = 0</p><p>MI N = 1</p><p>PL N = 0</p><p>VS V = 1</p><p>VC V = 0</p><p>HI C = 1 &amp; Z = 0</p><p>LS C = 0 | Z = 1</p><p>GE N = V</p><p>LT N != V</p><p>GT Z = 0 &amp; N = V</p><p>LE Z = 1 | N != V</p><p>在条件分支指令前会有一条数据操作指令来设置<br>flag，分支指令根据flag的值来决定代码走向，举例如<br>下：<br>Label:<br>LDR R0, [R1], #4<br>CMP R0, 0 ; 如果R0 == 0， Z = 1；否则Z = 0<br>BNE Label ; Z == 0则跳转</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LLDB &amp;&amp; debugserver的使用</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/LLDB-debugserver%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/LLDB-debugserver%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h4 id="1-1-LLDB"><a href="#1-1-LLDB" class="headerlink" title="1.1 LLDB"></a>1.1 LLDB</h4><p>  </p><h4>LLDB全称为low level debugger,是xcode自带的动态调试工具，可用于c,c++,objective-c，全盘支持iOS，OSX以及iOS模拟器。<br> LLDB有以下四个功能：<p></p><p> 1.在特定的情况下暂停程序</p><p> 2.在特定的情况下启动程序</p><p> 3.在程序停止的情况下检查程序内部</p><p> 4.在程序停止的情况下改动程序，观察执行过程。</p><p> LLDB是运行在OSX程序中的，可以通过特定的语句配合debugServer对iOS中的程序进行监视。</p><a id="more"></a><h4 id="1-2-debugServer"><a href="#1-2-debugServer" class="headerlink" title="1.2 debugServer"></a>1.2 debugServer</h4><p> </p><h4>debugserver是运行在iOS程序中的，顾名思义，作为server端，它接受与来自服务端，也就是LLDB传送过来的命令，继而执行的操作。再把执行结果返回给LLDB,默认情况下， iOS并没有安装debugserver，只有在设备连接了一次xcode之后，并在window-&gt;device中添加此设备之后，debugservercai才会别安装到iOS中，默认位于Developer/usr/bin目录下。<p></p><p> 但是默认的debugserver只用用户调试我们自己的app，如果想要调试iOS里面所有的app，还需要通过给debugserver赋予task_for_pid的权限。以下是配置task_for_pid的教程</p><p> 1.debugserver瘦身，首先根据你的iOS设备确定你的手机对应的ARM，4s是armv7,5,5c是armv7s，5s以上的机型都是arm64，我的手机是5s，所以对应的arm是arm64，所以只从debugserver保留arm64的架构即可。具体步骤:<br> 首先将未经处理的debugserver从iOS拷贝到OSX中，可以用scp命令，也可以用iFunBox。<br> 然后利用命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -thin arm64（这里对应你的iOS设备的结构） (未经处理的debugServer的路径) -output (新的debugserver的保存路径)</span><br></pre></td></tr></table></figure><p> 2.给debugServer添加task_for_pid权限，将以下xml保存为ent.xml。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;com.apple.springboard.debugapplications&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;get-task-allow&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;task_for_pid-allow&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;key&gt;run-unsigned-code&lt;/key&gt;</span><br><span class="line">&lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure><p> 运行以下命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldid -S(ent.xml的全路径) (debugServer的全路径)</span><br></pre></td></tr></table></figure><p> 以上命令实质上是通过ldid这个签名工具，为debugserver添加task_for_pid权限，上面的命令也可以用xcode自带的codesign实现。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codesign -s -f - --entitlements ent.plist -f debugserver</span><br></pre></td></tr></table></figure><p> 3.将添加权限后的debugserver放回去iOS复制到/usr/bin/debugserver，这样的好处是可以全局执行debugserver命令。另一个原因是因为在developer里面的是不可以写的，无法覆盖。<br> 4.给新的debugserver添加可执行的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/bin/debugserver</span><br></pre></td></tr></table></figure><p>####1.3 debugserver使用</p><p></p><h4>debugserver有两个命令。<p></p><p> 1.启动进程,debugserver会启动进程，并且开启port端口，等待来自ip的LLDB接入。ip如果为*则代表任意ip</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugserver backend ip:port /path/to/excutable</span><br></pre></td></tr></table></figure><p> 2.附加进程，附加进程是在进程已打开的情况下，可以执行以下命令。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugserver ip:port -a &quot;processname&quot;</span><br></pre></td></tr></table></figure><h4 id="1-4-LLDB-amp-amp-debugserver配合使用"><a href="#1-4-LLDB-amp-amp-debugserver配合使用" class="headerlink" title="1.4 LLDB &amp;&amp; debugserver配合使用"></a>1.4 LLDB &amp;&amp; debugserver配合使用</h4><p></p><h5><br>假设我们要调试在iOS中要按下home键的处理。通过IDA我们知道按下home键的时候调用了 -[SpringBoard _menuButtonDown:] 这个方法，现在我们的需求是在menuButtonDown的方法下面打一个断点。<p></p><p>(1)首先利用debugserver启动进程或者附加进程。系统的SpringBoard默认是启动的，所以不需要启动进程，使用附加进程命令即可。SSH到iOS中，然后附加到SpringBoard进程(以下命令开启了1234接口并且等待来自任意ip的LLDB接入)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Last login: Sun Apr  8 11:04:23 on ttys016</span><br><span class="line">MacBookPro:~ lemon$ ssh root@192.168.2.154</span><br><span class="line">lemons-iPhone5S:~ root# debugserver *:1234 -a &quot;SpringBoard&quot;</span><br><span class="line">debugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-340.3.124</span><br><span class="line"> for arm64.</span><br><span class="line">Attaching to process SpringBoard...</span><br><span class="line">Listening to port 1234 for a connection from *...</span><br></pre></td></tr></table></figure><p>(2)在OSX的terminal中启动LLDB，然后连接远程1234端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MacBookPro:~ lemon$ lldb</span><br><span class="line">(lldb) process connect connect://192.168.2.154:1234</span><br><span class="line">Process 2148 stopped</span><br><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = signal SIGSTOP</span><br><span class="line">    frame #0: 0x000000018208cfd8 libsystem_kernel.dylib`mach_msg_trap + 8</span><br><span class="line">libsystem_kernel.dylib`mach_msg_trap:</span><br><span class="line">-&gt;  0x18208cfd8 &lt;+8&gt;: ret    </span><br><span class="line"></span><br><span class="line">libsystem_kernel.dylib`mach_msg_overwrite_trap:</span><br><span class="line">    0x18208cfdc &lt;+0&gt;: mov    x16, #-0x20</span><br><span class="line">    0x18208cfe0 &lt;+4&gt;: svc    #0x80</span><br><span class="line">    0x18208cfe4 &lt;+8&gt;: ret    </span><br><span class="line">Target 0: (SpringBoard) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>(3)通过以上两步我们已经可以在电脑的终端利用LLDB调试APP了。现在在终端输入 image list -o -f 可以看到当前所有iOS中启动的所有的进程模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[(lldb) image list -o -f</span><br><span class="line">[  0] 0x0000000000040000 /Users/lemon/Library/Developer/Xcode/iOS DeviceSupport/9.3.1 (13E238)/Symbols/usr/lib/dyld</span><br><span class="line">[  1] 0x00000000000dc000 /System/Library/CoreServices/SpringBoard.app/SpringBoard(0x00000001000dc000)</span><br><span class="line">[  2] 0x0000000100988000 /Library/MobileSubstrate/MobileSubstrate.dylib(0x0000000100988000)</span><br><span class="line">[  3] 0x0000000001acc000 /Users/lemon/Library/Developer/Xcode/iOS DeviceSupport/9.3.1 (13E238)/Symbols/System/Library/PrivateFrameworks/StoreServices.framework/StoreServices</span><br></pre></td></tr></table></figure><p>(4)通过3中的信息我们发现了Spring的偏移是0x00000000000dc000，接下来我们需要用ida查看menuButtonDown这个函数在模块中的地址是多少。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                     -[SpringBoard _menuButtonDown:]:</span><br><span class="line">0000000100016fe8         stp        x28, x27, [sp, #0xffffffa0]!                ; Objective C Implementation defined at 0x1006a4550 (instance)</span><br><span class="line">0000000100016fec         stp        x26, x25, [sp, #0x10]</span><br><span class="line">0000000100016ff0         stp        x24, x23, [sp, #0x20]</span><br><span class="line">0000000100016ff4         stp        x22, x21, [sp, #0x30]</span><br><span class="line">0000000100016ff8         stp        x20, x19, [sp, #0x40]</span><br><span class="line">0000000100016ffc         stp        x29, x30, [sp, #0x50]</span><br><span class="line">0000000100017000         add        x29, sp, #0x50</span><br><span class="line">0000000100017004         sub        sp, sp, #0x60</span><br></pre></td></tr></table></figure><p>通过上面的信息可以看到，该函数的第一条指令的地址是0000000100016fe8，所以该函数偏移后的地址是：原地址+偏移 =》0x00000000000dc000 +   0000000100016fe8 = 0x1000F2FE8</p><p>(5)在偏移后的地址出打断点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0x1000F2FE8</span><br><span class="line">Breakpoint 1: where = SpringBoard`_mh_execute_header + 71804, address = 0x00000001000f2fe8</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>(6)在打完断点之后，可以按下home键，这个时候程序就会停在断点处，可以用1.5里面的命令进行调试等等</p><h4 id="1-5-LLDB命令解析"><a href="#1-5-LLDB命令解析" class="headerlink" title="1.5 LLDB命令解析"></a>1.5 LLDB命令解析</h4><p></p><h5><br>(1) b NSog // 在函数的起始位置设置断点<p></p><p>(2) br s -a address //在地址处设置断点</p><p>(3) br s -a ‘address + offsetAddress’ //在地址处设置断点</p><p>(4) br dis //禁用所有的断点</p><p>(5) br dis 6 //禁用序号为6的断点</p><p>(6) br del //删除所有断点</p><p>(7) br del 6 //删除序号为6的断点</p><p>(8) br en //启用所有断点</p><p>(9) br en 6 //启用序号为6的断点</p><p>(10)br com add 1 //当序号为1的断点执行的时候，可以执行预先设置的指令。当执行了这条指令之后，llDB会要求你输入一些指令，并且以DONE结束，当程序停在序号为1的断点时，就会执行这些预先设定的指令。</p><p>(11)p $R1 //打印R1的值</p><p>(12)p/x $sp //打印SP的地址，以16进制输出</p><p>(13)x/10 $sp //打印sp的地址，以10进制输出</p><p>(14)nexti 和 stepi //nexti不进入函数体，stepi进入函数体，nexti可以简写成ni,setpi可以简写成si。</p><p>(15)register write r0 1 //用于给指定的寄存器r0赋值为1从而达到对程序进行改动的目的。</p></h5></h5></h4></h4></h4>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLDB </tag>
            
            <tag> debugserver </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>libimobiledevice的安装和使用</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/libimobiledevice%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/libimobiledevice%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p></p><h5>libimobiledevice 是一个跨平台的软件库，支持 iPhone®, iPod Touch®, iPad® and Apple TV® 等设备的通讯协议。不依赖任何已有的私有库，不需要越狱。应用软件可以通过这个开发包轻松访问设备的文件系统、获取设备信息，备份和恢复设备，管理 SpringBoard 图标，管理已安装应用，获取通讯录、日程、备注和书签等信息，使用 libgpod 同步音乐和视频。<p></p><a id="more"></a><h2 id="2-安装方式"><a href="#2-安装方式" class="headerlink" title="2.安装方式"></a>2.安装方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install -HEAD libimobiledevice #安装最新的更新，支持 iOS 10</span><br><span class="line">brew install ideviceinstaller  # 仅在 iOS9工作</span><br></pre></td></tr></table></figure><h2 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3.常用命令"></a>3.常用命令</h2><h3 id="3-1-查看当前所连接的设备"><a href="#3-1-查看当前所连接的设备" class="headerlink" title="3.1 查看当前所连接的设备"></a>3.1 查看当前所连接的设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MacBookPro:~ lemon$ idevice_id -l # 显示当前所连接的设备[udid]，包括 usb、WiFi 连接</span><br><span class="line">********c06e788b2d8dc60004a7015ce5dad782</span><br><span class="line">********9a816a4089bd28f4f2e63c57a8138c63</span><br><span class="line"></span><br><span class="line">instruments -s devices      # 列出设备包括模拟器、真机及 mac 电脑本身</span><br></pre></td></tr></table></figure><h3 id="3-2-安装应用"><a href="#3-2-安装应用" class="headerlink" title="3.2 安装应用"></a>3.2 安装应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ideviceinstaller -u [udid] -i [xxx.ipa] # 给指定连接的设备安装应用</span><br></pre></td></tr></table></figure><h3 id="3-3-卸载应用"><a href="#3-3-卸载应用" class="headerlink" title="3.3 卸载应用"></a>3.3 卸载应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ideviceinstaller -u [udid] -U [bundleId] # 给指定连接的设备卸载应用</span><br></pre></td></tr></table></figure><h3 id="3-4-查看设备已安装的应用"><a href="#3-4-查看设备已安装的应用" class="headerlink" title="3.4 查看设备已安装的应用"></a>3.4 查看设备已安装的应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ideviceinstaller -u [udid] -l                   # 指定设备，查看安装的第三方应用</span><br><span class="line">ideviceinstaller -u [udid] -l -o list_user      # 指定设备，查看安装的第三方应用</span><br><span class="line">ideviceinstaller -u [udid] -l -o list_system    # 指定设备，查看安装的系统应用</span><br><span class="line">ideviceinstaller -u [udid] -l -o list_all       # 指定设备，查看安装的系统应用和第三方应用</span><br></pre></td></tr></table></figure><h3 id="3-5-获取设备信息"><a href="#3-5-获取设备信息" class="headerlink" title="3.5  获取设备信息"></a>3.5  获取设备信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ideviceinfo -u [udid]                       # 指定设备，获取设备信息</span><br><span class="line">ideviceinfo -u [udid] -k DeviceName         # 指定设备，获取设备名称：iPhone6s</span><br><span class="line">idevicename -u [udid]                       # 指定设备，获取设备名称：iPhone6s</span><br><span class="line">ideviceinfo -u [udid] -k ProductVersion     # 指定设备，获取设备版本：10.3.1</span><br><span class="line">ideviceinfo -u [udid] -k ProductType        # 指定设备，获取设备类型：iPhone8,1</span><br><span class="line">ideviceinfo -u [udid] -k ProductName        # 指定设备，获取设备系统名称：iPhone OS</span><br></pre></td></tr></table></figure></h5>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>logos基础语法</title>
      <link href="/2018/07/25/iOS%20%E9%80%86%E5%90%91/logos%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/07/25/iOS%20%E9%80%86%E5%90%91/logos%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Logos-语法"><a href="#Logos-语法" class="headerlink" title="Logos 语法"></a>Logos 语法</h1><ol><li><p>%hook className 指定需要hook的class，必须以end结尾 如：hook了系统界面的home按钮按下方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">- (void)_munuButtonDown:(id)down&#123;</span><br><span class="line">   NSLog(@&quot;You are press the home button&quot;);</span><br><span class="line">   %orig;//call the original _menuButton</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>%log 打印日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%log((NSString *)@&quot;iOSRE&quot;, (NSString *)@&quot;Debug&quot;);</span><br></pre></td></tr></table></figure></li><li><p>%orig 执行原始代码，必须在%hook里面使用，如果在hook方法里面不增加这一行代码，那么原始函数不会被调用。另外还可以用该函数修改原始函数的参数。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%hook SBLockScreenDateViewController</span><br><span class="line">//以下方法设置锁屏界面的日期的文字，改成了lemon love well</span><br><span class="line">- (void)setCustomSubtitleText:(id)arg1 withColor:(id)arg2</span><br><span class="line">&#123;</span><br><span class="line">   %orig(@&quot;Lemon love Well&quot;,arg2);</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure></li><li><p>%group 用户将%hook分组，便于代码管理和条件初始化分组，必须以%end结尾，一个%group可以包括多个%hook，如果一个%hook不在一个%group里面，那么这个%hook属于%group_ungrouped。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%group iOS7Hook</span><br><span class="line">%hook iOS7Class</span><br><span class="line">- (id)iOS7Method&#123;</span><br><span class="line">id result = %orig;</span><br><span class="line">NSLog(@&quot;This class &amp; method only exist in iOS</span><br><span class="line">7.&quot;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line">%end</span><br><span class="line">%group iOS8Hook</span><br><span class="line">%hook iOS8Class</span><br><span class="line">- (id)iOS8Method&#123;</span><br><span class="line">id result = %orig;</span><br><span class="line">NSLog(@&quot;This class &amp; method only exist in iOS</span><br><span class="line">8.&quot;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line">%end</span><br></pre></td></tr></table></figure></li><li><p>%init 值得注意的是，每个%group必须配合下面的%init使用才能生效，该指令用户初始化一个%group，必须在%hook里面调用或者%ctor里面调用。如果带参数，那么初始化指定的group，如果不带参数，那么初始化_ungrouped。如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#ifndef kCFCoreFoundationVersionNumber_iOS_8_0</span><br><span class="line">#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10</span><br><span class="line">#endif</span><br><span class="line">%hook SpringBoard</span><br><span class="line">- (void)applicationDidFinishLaunching:(id)application</span><br><span class="line">&#123;</span><br><span class="line">%orig;</span><br><span class="line">%init; // Equals to %init(_ungrouped)</span><br><span class="line">if (kCFCoreFoundationVersionNumber &gt;=</span><br><span class="line">kCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp;</span><br><span class="line">kCFCoreFoundationVersionNumber &lt;</span><br><span class="line">kCFCoreFoundationVersionNumber_iOS_8_0)          %init(iOS7Hook);//init iOS7Hook group</span><br><span class="line">if (kCFCoreFoundationVersionNumber &gt;=</span><br><span class="line">kCFCoreFoundationVersionNumber_iOS_8_0) %init(iOS8Hook);</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure></li><li><p>%ctor，tweak的constructor，完成初始化工作，如果不显式定义，theos会自动生成一个%ctor，并在里面调用%init(_ungrouped)。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//以下代码段可以生效，因为theos隐式调用了%ctor并且%init(_ungroped)</span><br><span class="line">%hook SpringBoard</span><br><span class="line">- (void)reboot</span><br><span class="line">&#123;</span><br><span class="line">   NSLog(@&quot;If rebooting does not word then i screwed&quot;);</span><br><span class="line">   %orig;//call origin method</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line">//以下代码段不能生效，虽然显式定义了%ctor，但是没有在里面调用%init方法</span><br><span class="line">%hook SpringBoard</span><br><span class="line">   - (void)reboot</span><br><span class="line">&#123;</span><br><span class="line">   NSLog(@&quot;If rebooting does not word then i screwed&quot;);</span><br><span class="line">   %orig;//call origin method</span><br><span class="line">&#125;</span><br><span class="line">%ctor&#123;</span><br><span class="line">   //need to call %init here.</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>%new在%hook内部使用，给一个现有的class添加新的函数，功能与class_addMethod一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">%new </span><br><span class="line">- (void)createNewMethod</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;This is a new method&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>%c 该指令的作用等同于NSClassFromString()或者obj_getClass()动态获取一个类的定义，在%hook或者%ctor内使用。</p></li></ol>]]></content>
      
      <categories>
          
          <category> iOS 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logos </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS适配国际化(跟随系统切换和应用内切换)</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%80%82%E9%85%8D%E5%9B%BD%E9%99%85%E5%8C%96-%E8%B7%9F%E9%9A%8F%E7%B3%BB%E7%BB%9F%E5%88%87%E6%8D%A2%E5%92%8C%E5%BA%94%E7%94%A8%E5%86%85%E5%88%87%E6%8D%A2/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%80%82%E9%85%8D%E5%9B%BD%E9%99%85%E5%8C%96-%E8%B7%9F%E9%9A%8F%E7%B3%BB%E7%BB%9F%E5%88%87%E6%8D%A2%E5%92%8C%E5%BA%94%E7%94%A8%E5%86%85%E5%88%87%E6%8D%A2/</url>
      <content type="html"><![CDATA[<blockquote><p>在开发中我们的APP可能会有海外的版本，可能APP需要匹配英语，俄语，日语等等，这个时候就要做国际化的匹配处理，但是国际化适配也分两种情况，一种是根据iPhone系统语言自动切换界面语言，另外一种是在APP内选择语言，直接刷新APP的界面。下面我会分别介绍这两种情况。<a href="https://github.com/codemonkeybulucck/LocalizableDemo.git" target="_blank" rel="noopener">Demo在这里</a></p></blockquote><a id="more"></a><h2 id="第一种情况，比较简单的跟随系统语言自动切换。这种情况主要使用的是系统提供给我们的一个宏"><a href="#第一种情况，比较简单的跟随系统语言自动切换。这种情况主要使用的是系统提供给我们的一个宏" class="headerlink" title="第一种情况，比较简单的跟随系统语言自动切换。这种情况主要使用的是系统提供给我们的一个宏"></a>第一种情况，比较简单的跟随系统语言自动切换。这种情况主要使用的是系统提供给我们的一个宏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define NSLocalizedString(key, comment) \</span><br><span class="line">    [NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:nil]</span><br></pre></td></tr></table></figure><p>key的作用是去localizable.strings文件里面根据这个key去匹配文本内容，然后返回。如果用了这个宏，因为实际上调用的是 <code>[NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:nil]</code> 这个方法，table为nil代表默认去Localizable.strings里面找，所以当创建strings文件的时候命名必须为Localizable,如果strings命名为其他名字，那么要用 <code>#define NSLocalizedStringFromTable(key, tbl, comment)</code>指定table的名字为strings的文件名字。<br>以上是基本的介绍。</p><h3 id="下面开始说说开发步骤："><a href="#下面开始说说开发步骤：" class="headerlink" title="下面开始说说开发步骤："></a>下面开始说说开发步骤：</h3><p>1.首先需要在项目中增加需要匹配的语言</p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-7681990a7fc5939d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20170608-104014.png"></p><p>如我需要匹配的语言是简体中文和英语。<br>2.创建Localizable.strings文件</p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-64952a4b48db1030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20170608-104053.png"><br>创建完成后点击该文件，然后在右侧面板的点击Localization 选择English和Chinese，然后就会生成以下两个文件<br><img src="http://upload-images.jianshu.io/upload_images/2269918-cd15913998ecf15b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20170608-104133.png"></p><h3 id="Localizable-strings-English-代表当系统语言是中文的时候，会来到这个文件根据key匹配text"><a href="#Localizable-strings-English-代表当系统语言是中文的时候，会来到这个文件根据key匹配text" class="headerlink" title="Localizable.strings(English)代表当系统语言是中文的时候，会来到这个文件根据key匹配text"></a>Localizable.strings(English)代表当系统语言是中文的时候，会来到这个文件根据key匹配text</h3><h4 id="Localizable-strings-Simplified-代表当系统语言是英文的时候，会来到这个文件根据key匹配text。"><a href="#Localizable-strings-Simplified-代表当系统语言是英文的时候，会来到这个文件根据key匹配text。" class="headerlink" title="Localizable.strings(Simplified)代表当系统语言是英文的时候，会来到这个文件根据key匹配text。"></a>Localizable.strings(Simplified)代表当系统语言是英文的时候，会来到这个文件根据key匹配text。</h4><p>以下是两个文件的内容：</p><h3 id="Localizable-strings-English"><a href="#Localizable-strings-English" class="headerlink" title="Localizable.strings(English)"></a>Localizable.strings(English)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;LoginButtonText&quot;=&quot;Login&quot;;</span><br><span class="line">&quot;LabelText&quot;=&quot;The language of System is English now&quot;;</span><br></pre></td></tr></table></figure><h3 id="Localizable-strings-Chinese-simplified"><a href="#Localizable-strings-Chinese-simplified" class="headerlink" title="Localizable.strings(Chinese(simplified))"></a>Localizable.strings(Chinese(simplified))</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;LoginButtonText&quot;=&quot;登陆&quot;;</span><br><span class="line">&quot;LabelText&quot;=&quot;现在系统的语言是中文&quot;;</span><br></pre></td></tr></table></figure><p>3.使用NSLocalizedString(key,comment) 宏来赋值<br>在前面已经说了这个宏的作用了，在我的demo中我给button和label设置text。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[button setTitle:NSLocalizedString(@&quot;LoginButtonText&quot;, @&quot;&quot;) forState:UIControlStateNormal];</span><br><span class="line">    label.text = NSLocalizedString(@&quot;LabelText&quot;, @&quot;&quot;);</span><br></pre></td></tr></table></figure></p><p>最后去设置里面切换语言就能看到效果。</p><h2 id="第二种情况，像微博或者微信可以在应用的语言设置里面直接设置本APP的语言，这种设置不会影响其他APP，只是本APP的一种行为，主要是利用NSUserDefault来保存本地自定的语言的值，如en-zh-hans等，然后通过读取这个值来加载对应的lproj文件，然后再生成对应的bundle，每个bundle下面就会放着每个table的stings文件。"><a href="#第二种情况，像微博或者微信可以在应用的语言设置里面直接设置本APP的语言，这种设置不会影响其他APP，只是本APP的一种行为，主要是利用NSUserDefault来保存本地自定的语言的值，如en-zh-hans等，然后通过读取这个值来加载对应的lproj文件，然后再生成对应的bundle，每个bundle下面就会放着每个table的stings文件。" class="headerlink" title="第二种情况，像微博或者微信可以在应用的语言设置里面直接设置本APP的语言，这种设置不会影响其他APP，只是本APP的一种行为，主要是利用NSUserDefault来保存本地自定的语言的值，如en,zh-hans等，然后通过读取这个值来加载对应的lproj文件，然后再生成对应的bundle，每个bundle下面就会放着每个table的stings文件。"></a>第二种情况，像微博或者微信可以在应用的语言设置里面直接设置本APP的语言，这种设置不会影响其他APP，只是本APP的一种行为，主要是利用NSUserDefault来保存本地自定的语言的值，如en,zh-hans等，然后通过读取这个值来加载对应的lproj文件，然后再生成对应的bundle，每个bundle下面就会放着每个table的stings文件。</h2><h3 id="话不多说，以下是开发步骤："><a href="#话不多说，以下是开发步骤：" class="headerlink" title="话不多说，以下是开发步骤："></a>话不多说，以下是开发步骤：</h3><p>1.和第一种情况一样，首先需要在项目中增加需要匹配的语言<br><img src="http://upload-images.jianshu.io/upload_images/2269918-7681990a7fc5939d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20170608-104014.png"></p><p>2.创建.strings文件，这里和第一种情况不太一样的是，这里你可以任意指定一个名字，如FirstTabBarItem.strings 来放置tabbar的第一个item的多语言文件，SecondTabBarItem.strings 来放置tabbar的第二个item的多语言文件，这里可以灵活处理。创建完strings文件之后，还是和之前一样点击Localization。然后选择你要适配的语言，生成文件。</p><p>3.第三步创建一个LocalizableHelper 的类，这个类的作用是提供一个让外界根据key和table来获取文本的宏，当设置成功之后就会发出一个通知，接受者只需要监听这个通知然后更新必要界面就可以了。具体请看<a href="https://github.com/codemonkeybulucck/LocalizableDemo.git" target="_blank" rel="noopener">demo</a>，里面已经写了所有步骤的注释。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS 国际化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS SDK利用Aggregate打包动态库和静态库</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS-SDK%E5%88%A9%E7%94%A8Aggregate%E6%89%93%E5%8C%85%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS-SDK%E5%88%A9%E7%94%A8Aggregate%E6%89%93%E5%8C%85%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/</url>
      <content type="html"><![CDATA[<blockquote><p>前言：可能做SDK的iOS开发者都体验过打包动态库或者静态库的时候那些繁琐的步骤，需要分别选择真机和模拟器来编译，最后还要用命令行将他们合并起来，每次都这样打包的话特别麻烦。但是我们可以使用Aggregate的脚本来自动打包。</p></blockquote><a id="more"></a><h2 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h2><p>新建一个target,选择cross-platform的Aggregate，如下图<br><img src="http://upload-images.jianshu.io/upload_images/2269918-95f30fdbd0120257.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><h2 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h2><p>创建完Aggregate之后，增加一个run script，具体步骤为，选中刚刚创建的Aggregate target,然后在build phases 下面点击加号，选择 new run script phase<br><img src="http://upload-images.jianshu.io/upload_images/2269918-974c8e93ac6449ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p><h2 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h2><p>在图中红色框框标注的地方输入以下脚本<br><img src="http://upload-images.jianshu.io/upload_images/2269918-cb9318bf8185f24e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p><h2 id="如果要生成-a后缀的静态库，那么使用以下脚本"><a href="#如果要生成-a后缀的静态库，那么使用以下脚本" class="headerlink" title="如果要生成.a后缀的静态库，那么使用以下脚本"></a>如果要生成.a后缀的静态库，那么使用以下脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">set -e</span><br><span class="line"># Sets the target folders and the final framework product.</span><br><span class="line"># 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME</span><br><span class="line"># 例如: FMK_NAME=&quot;MyFramework&quot;</span><br><span class="line">FMK_NAME=&quot;IDMPCMCC&quot;</span><br><span class="line"># Install dir will be the final output to the framework.</span><br><span class="line"># The following line create it in the root folder of the current project.</span><br><span class="line"># 获取当前时间</span><br><span class="line">DATE=$(date +%Y%m%d-%H:%M:%S)</span><br><span class="line"># 定义IDMPCMCC+当前时间 命名的文件夹名字</span><br><span class="line">INSTALL_DIR=$&#123;HOME&#125;/Desktop/IDMPCMCC$&#123;DATE&#125;</span><br><span class="line"># 支持真机静态库所在的路径</span><br><span class="line">DEVICE_DIR=$&#123;BUILD_DIR&#125;/Release-iphoneos/</span><br><span class="line"># 支持模拟器静态库所在的路径</span><br><span class="line">SIMULATOR_DIR=$&#123;BUILD_DIR&#125;/Release-iphonesimulator/</span><br><span class="line"># -configuration $&#123;CONFIGURATION&#125;</span><br><span class="line"># Clean and Building both architectures.</span><br><span class="line"># 配置生成静态库一些参数</span><br><span class="line">xcodebuild build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot; -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphoneos clean build ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION</span><br><span class="line">xcodebuild build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot;  -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphonesimulator clean build ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION</span><br><span class="line"># Cleaning the oldest.</span><br><span class="line">if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]</span><br><span class="line">then</span><br><span class="line">rm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">fi</span><br><span class="line">mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;</span><br><span class="line"># Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.</span><br><span class="line"># 合并真机和模拟器架构静态库</span><br><span class="line">lipo -create &quot;$&#123;DEVICE_DIR&#125;/lib$&#123;FMK_NAME&#125;.a&quot; &quot;$&#123;SIMULATOR_DIR&#125;/lib$&#123;FMK_NAME&#125;.a&quot; -output &quot;$&#123;INSTALL_DIR&#125;/lib$&#123;FMK_NAME&#125;.a&quot;</span><br><span class="line"></span><br><span class="line">open &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="如果要生成-framework的静态库或者动态库的话，使用以下脚本"><a href="#如果要生成-framework的静态库或者动态库的话，使用以下脚本" class="headerlink" title="如果要生成.framework的静态库或者动态库的话，使用以下脚本"></a>如果要生成.framework的静态库或者动态库的话，使用以下脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">set -e</span><br><span class="line"># Sets the target folders and the final framework product.</span><br><span class="line"># 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME</span><br><span class="line"># 例如: FMK_NAME=&quot;MyFramework&quot;</span><br><span class="line">FMK_NAME=&quot;IDMPCMCC&quot;</span><br><span class="line"># Install dir will be the final output to the framework.</span><br><span class="line"># The following line create it in the root folder of the current project.</span><br><span class="line"># 获取当前时间</span><br><span class="line">DATE=$(date +%Y%m%d-%H:%M:%S)</span><br><span class="line"># 定义IDMPCMCC+当前时间 命名的文件夹名字</span><br><span class="line">INSTALL_DIR=$&#123;HOME&#125;/Desktop/IDMPCMCC$&#123;DATE&#125;/$&#123;FMK_NAME&#125;.framework</span><br><span class="line">DEVICE_DIR=$&#123;BUILD_DIR&#125;/Release-iphoneos/$&#123;FMK_NAME&#125;.framework</span><br><span class="line">SIMULATOR_DIR=$&#123;BUILD_DIR&#125;/Release-iphonesimulator/$&#123;FMK_NAME&#125;.framework</span><br><span class="line"># -configuration $&#123;CONFIGURATION&#125;</span><br><span class="line"># Clean and Building both architectures.</span><br><span class="line">xcodebuild build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot;  -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphoneos clean build ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION</span><br><span class="line">xcodebuild build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot; -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphonesimulator clean build ONLY_ACTIVE_ARCH=NO BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION</span><br><span class="line"># Cleaning the oldest.</span><br><span class="line">if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]</span><br><span class="line">then</span><br><span class="line">rm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">fi</span><br><span class="line">mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;</span><br><span class="line"># Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.</span><br><span class="line">lipo -create &quot;$&#123;DEVICE_DIR&#125;/$&#123;FMK_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;/$&#123;FMK_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;/$&#123;FMK_NAME&#125;&quot;</span><br><span class="line"></span><br><span class="line">open &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br></pre></td></tr></table></figure><p><code>build BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=&quot;-fembed-bitcode&quot;</code>这一句代码是用来开启bitcode</p><h2 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h2><p>选择创建的Aggregate运行即可。<br><img src="http://upload-images.jianshu.io/upload_images/2269918-f690c4f4ec8531ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDK </tag>
            
            <tag> Aggregate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS链式编程实(仿Masonry框架)</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E-%E4%BB%BFMasonry%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E-%E4%BB%BFMasonry%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<blockquote><p>前言： 相信做过iOS开发的都知道系统给开发者提供的代码设置约束有多难用，设置一个元素的位置往往要写十多行的代码，因为NSLayoutConstraint这个类是在太难用了。所以一个简单的代码布局框架就会很受开发者欢迎。所以也有了这次实践，通过链式编程实现简单的自动布局。下面也是模仿<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a>做一套自己的自动布局框架。</p></blockquote><a id="more"></a><h1 id="1-先看看我们最终实现同样的效果的代码对比"><a href="#1-先看看我们最终实现同样的效果的代码对比" class="headerlink" title="1.先看看我们最终实现同样的效果的代码对比"></a>1.先看看我们最终实现同样的效果的代码对比</h1><h2 id="1-1使用系统代码设置约束"><a href="#1-1使用系统代码设置约束" class="headerlink" title="1.1使用系统代码设置约束"></a>1.1使用系统代码设置约束</h2><pre><code>greenView.translatesAutoresizingMaskIntoConstraints = NO;[superview addConstraints:@[                            //greenView constraints                            [NSLayoutConstraint constraintWithItem:greenView                                                         attribute:NSLayoutAttributeTop                                                         relatedBy:NSLayoutRelationEqual                                                            toItem:superview                                                         attribute:NSLayoutAttributeTop                                                        multiplier:1.0                                                          constant:20],                            [NSLayoutConstraint constraintWithItem:greenView                                                         attribute:NSLayoutAttributeLeft                                                         relatedBy:NSLayoutRelationEqual                                                            toItem:superview                                                         attribute:NSLayoutAttributeLeft                                                        multiplier:1.0                                                          constant:20],                            [NSLayoutConstraint constraintWithItem:greenView                                                         attribute:NSLayoutAttributeBottom                                                         relatedBy:NSLayoutRelationEqual                                                            toItem:nil                                                         attribute:NSLayoutAttributeNotAnAttribute                                                        multiplier:1.0                                                          constant:80],                            [NSLayoutConstraint constraintWithItem:greenView                                                         attribute:NSLayoutAttributeRight                                                         relatedBy:NSLayoutRelationEqual                                                            toItem:superview                                                         attribute:NSLayoutAttributeNotAnAttribute                                                        multiplier:1                                                          constant:80],                            ]];</code></pre><h2 id="1-2使用链式编程实现约束"><a href="#1-2使用链式编程实现约束" class="headerlink" title="1.2使用链式编程实现约束"></a>1.2使用链式编程实现约束</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[greenView makeLayout:^void(LMLayout *layout) &#123;</span><br><span class="line">      layout.width.equalTo(@(80));</span><br><span class="line">      layout.height.equalTo(@80);</span><br><span class="line">      layout.left.equalTo(self.view.lm_left).offSet(20);</span><br><span class="line">      layout.top.equalTo(self.view.lm_top).offSet(20);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><h1 id="2-以上的代码缩减了这么多主要是因为将复杂的方法调用用链式的方式实现出来了，那么什么是链式编程呢？"><a href="#2-以上的代码缩减了这么多主要是因为将复杂的方法调用用链式的方式实现出来了，那么什么是链式编程呢？" class="headerlink" title="2.以上的代码缩减了这么多主要是因为将复杂的方法调用用链式的方式实现出来了，那么什么是链式编程呢？"></a>2.以上的代码缩减了这么多主要是因为将复杂的方法调用用链式的方式实现出来了，那么什么是链式编程呢？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout.left.equalTo(self.view.lm_left).offSet(20);</span><br></pre></td></tr></table></figure><pre><code>以这句代码为例，可以通过点语法一直不断的调用下一个方法，像一条链子一样，这样的方式就叫做链式编程。</code></pre><p>那么在代码层面，如何可以实现一直不断的通过点语法调用下一个方法。<br>实质上就是通过点语法调用方法的时候，返回一个block。而这个block必须需要包涵一个很重要的特点，这个block有返回值，这个返回值的类型是一个调用下一个方法的对象，这样下次又可以通过这个对象执行下一个方法。代码示例为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(LMLayout *(^)(NSObject *object))equalTo;</span><br></pre></td></tr></table></figure></p><p>上述代码返回了一个(LMLayout <em>(^)(NSObject </em>object)block,该block返回了一个LMLayout对象，以便后面可以继续调用下一个方法，然后接受输入一个object的参数，该参数可以用来设置内部的约束的值。</p><h1 id="3-基于以上的了解，我们开始着手写一个仿masonry的框架。"><a href="#3-基于以上的了解，我们开始着手写一个仿masonry的框架。" class="headerlink" title="3.基于以上的了解，我们开始着手写一个仿masonry的框架。"></a>3.基于以上的了解，我们开始着手写一个仿masonry的框架。</h1><p>以下使我们最终要实现的调用方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[greenView makeLayout:^void(LMLayout *layout) &#123;</span><br><span class="line">      layout.width.equalTo(@(80));</span><br><span class="line">      layout.height.equalTo(@80);</span><br><span class="line">      layout.left.equalTo(self.view.lm_left).offSet(20);</span><br><span class="line">      layout.top.equalTo(self.view.lm_top).offSet(20);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure></p><h2 id="3-1先从外层的方法看起，首先给UIView创建了一个分类，并且定义了一个makeLayout的方法，需要传进一个block的参数，该block的作用就是设置greenView的约束。所以最外层的方法就是"><a href="#3-1先从外层的方法看起，首先给UIView创建了一个分类，并且定义了一个makeLayout的方法，需要传进一个block的参数，该block的作用就是设置greenView的约束。所以最外层的方法就是" class="headerlink" title="3.1先从外层的方法看起，首先给UIView创建了一个分类，并且定义了一个makeLayout的方法，需要传进一个block的参数，该block的作用就是设置greenView的约束。所以最外层的方法就是"></a>3.1先从外层的方法看起，首先给UIView创建了一个分类，并且定义了一个makeLayout的方法，需要传进一个block的参数，该block的作用就是设置greenView的约束。所以最外层的方法就是</h2><p>UIView+layout.h 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)makeLayout:(void(^)(LMLayout *layout))layoutBlock;</span><br></pre></td></tr></table></figure></p><p>UIView+layout.m文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)makeLayout:(void(^)(LMLayout *layout))layoutBlock&#123;</span><br><span class="line">    LMLayout *layout = [[LMLayout alloc]initWithView:self];</span><br><span class="line">    layoutBlock(layout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在以上的方法中，创建了一个LMLayout的对象，并且将当前的view作为参数去初始化LMLayout对象。接下来看看一些LMLayout的初始化方法的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithView:(UIView *)view&#123;</span><br><span class="line">    NSAssert([view superview]!=nil, @&quot;未能找到view的superView&quot;);</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _view = view;</span><br><span class="line">        view.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在初始化方法内部会判断当前设置约束的view是否有superView，并且用属性保存当前传进来的view，关闭translatesAutoresizingMaskIntoConstraints。<br>再返回到上一个方法，初始化完成之后就执行该block，将初始化好的layout对象传过去。</p><h2 id="3-2-接下来看block内部的调用"><a href="#3-2-接下来看block内部的调用" class="headerlink" title="3.2 接下来看block内部的调用"></a>3.2 接下来看block内部的调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout.width.equalTo(@(80));</span><br></pre></td></tr></table></figure><p>一层一层分析，layout.width实质上是调用了-(LMLayout*)width; 看看该方法内部的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(LMLayout*)width&#123;</span><br><span class="line">    _property = PropertyTypeWidth;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PropertyTypeWidth 是一个枚举值，表示当前设置约束的属性是width，然后返回当前layout对象。<br>既然返回了layout对象，那么同样可以通过点执行下一个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout.equalTo(@(80))</span><br></pre></td></tr></table></figure></p><p>同样看一下方法的定义和实现<br>.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(LMLayout *(^)(NSObject *object))equalTo;</span><br></pre></td></tr></table></figure></p><p>.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">-(LMLayout *(^)(NSObject *object))equalTo&#123;</span><br><span class="line">    __weak typeof(self)weakSelf = self;</span><br><span class="line">    return ^(NSObject *object)&#123;</span><br><span class="line">        //判断外部调用equalTo()这个block的时候会传什么值</span><br><span class="line">        //如果是直接设置属性的值</span><br><span class="line">        if ([object isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">            CGFloat floatValue = [(NSNumber*)object floatValue];</span><br><span class="line">            NSLayoutAttribute attribute = NSLayoutAttributeHeight;</span><br><span class="line">            switch (weakSelf.property) &#123;</span><br><span class="line">                case PropertyTypeWidth:</span><br><span class="line">                    attribute = NSLayoutAttributeWidth;</span><br><span class="line">                    break;</span><br><span class="line">                case PropertyTypeHeight:</span><br><span class="line">                    attribute = NSLayoutAttributeHeight;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    attribute = NSLayoutAttributeNotAnAttribute;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:weakSelf.view attribute:attribute relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:floatValue];</span><br><span class="line">            //检测之前是否已经设置了旧的同一属性的约束，如果是就删除，添加新的约束</span><br><span class="line">            [weakSelf checkIfExistOldLayoutWithNewLayout:constraint];</span><br><span class="line">            [weakSelf.view addConstraint:constraint];</span><br><span class="line">        &#125;</span><br><span class="line">        //如果是设置一个参照view</span><br><span class="line">        else if([object isKindOfClass:[NSDictionary class]])&#123;</span><br><span class="line">            NSDictionary *dict = (NSDictionary*)object;</span><br><span class="line">            UIView *view = (UIView *)dict[@&quot;view&quot;];</span><br><span class="line">            weakSelf.conferenceView = view;</span><br><span class="line">            weakSelf.conferProperty = [dict[@&quot;property&quot;] floatValue];</span><br><span class="line">            NSLayoutAttribute attribute = [LMLayout attributeWithProperty:weakSelf.property];</span><br><span class="line">            NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:weakSelf.view attribute:attribute relatedBy:NSLayoutRelationEqual toItem:weakSelf.conferenceView attribute:weakSelf.conferProperty multiplier:1 constant:0];</span><br><span class="line">            //检测之前是否已经设置了旧的同一属性的约束，如果是就删除，添加新的约束</span><br><span class="line">            [weakSelf checkIfExistOldLayoutWithNewLayout:constraint];</span><br><span class="line">            weakSelf.currentConstraint = constraint;</span><br><span class="line">            [weakSelf.view.superview addConstraint:constraint];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>上述方法首先返回一个返回值类型为LMLayout，参数类型型为NSObject对象的Block，为什么是NSObject对象类型，因为equalTo有可能会直接传入一个数值，也有可能会传入一个view的属性，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout.height.equalTo(@80);</span><br><span class="line">layout.left.equalTo(self.view.lm_left).offSet(20);</span><br></pre></td></tr></table></figure></p><h3 id="3-2-1-首先看传进来的是一个数值的情况"><a href="#3-2-1-首先看传进来的是一个数值的情况" class="headerlink" title="3.2.1 首先看传进来的是一个数值的情况"></a>3.2.1 首先看传进来的是一个数值的情况</h3><p>如果传进来是一个数值，那么会判断之前是否已经设置过该约束，如果已经设置过就删除该约束，重新添加新的约束。</p><h4 id="3-2-2-如果是-equalTo-self-view-lm-left-这种形式，括号内的self-view-lm-left实质上是执行了UIView的分类的"><a href="#3-2-2-如果是-equalTo-self-view-lm-left-这种形式，括号内的self-view-lm-left实质上是执行了UIView的分类的" class="headerlink" title="3.2.2 如果是.equalTo(self.view.lm_left)这种形式，括号内的self.view.lm_left实质上是执行了UIView的分类的"></a>3.2.2 如果是.equalTo(self.view.lm_left)这种形式，括号内的self.view.lm_left实质上是执行了UIView的分类的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(NSDictionary&lt;UIView *,NSNumber *&gt;*)lm_left;</span><br></pre></td></tr></table></figure><p>.m文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(NSDictionary&lt;UIView *,NSNumber *&gt;*)lm_left&#123;</span><br><span class="line">    return [self dictWithProperty:PropertyTypeLeft];</span><br><span class="line">&#125;</span><br><span class="line">- (NSDictionary&lt;UIView *,NSNumber *&gt;*)dictWithProperty:(PropertyType)type&#123;</span><br><span class="line">    NSDictionary *dict = @&#123;@&quot;view&quot;:self,@&quot;property&quot;:@([LMLayout attributeWithProperty:type])&#125;;</span><br><span class="line">    return dict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法内部会返回一个字典，字典的第一个参数表示需要参照的view，第二个参数表示的参照view的哪个属性。<br>当接收到返回的字典之后，因为之前已经获取了需要约束的view和需要约束的属性，现在也获取了参照的view和参照的属性，可以创建NSLayoutConstraint对象，并且添加约束到他们共同的superView上面。</p><h2 id="3-3-下面来关注一下offset-20"><a href="#3-3-下面来关注一下offset-20" class="headerlink" title="3.3 下面来关注一下offset(20)"></a>3.3 下面来关注一下offset(20)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout.left.equalTo(self.view.lm_left).offSet(20);</span><br></pre></td></tr></table></figure><p>.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void(^LayoutOffsetBlock)(CGFloat offset))offSet;</span><br></pre></td></tr></table></figure></p><p>.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(void(^LayoutOffsetBlock)(CGFloat offset))offSet&#123;</span><br><span class="line"> __weak typeof(self)weakSelf = self;</span><br><span class="line">    return ^(CGFloat margin)&#123;</span><br><span class="line">        NSLayoutAttribute attribute = [LMLayout attributeWithProperty:weakSelf.property];</span><br><span class="line">        NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem:weakSelf.view attribute:attribute relatedBy:NSLayoutRelationEqual toItem:weakSelf.conferenceView attribute:weakSelf.conferProperty multiplier:1 constant:margin];</span><br><span class="line">        if (weakSelf.currentConstraint.firstItem == constraint.firstItem &amp;&amp; weakSelf.currentConstraint.firstAttribute == constraint.firstAttribute &amp;&amp; weakSelf.currentConstraint.secondItem == constraint.secondItem &amp;&amp; weakSelf.currentConstraint.secondAttribute == constraint.secondAttribute) &#123;</span><br><span class="line">            weakSelf.currentConstraint.constant = margin;</span><br><span class="line">            //[weakSelf.view.superview removeConstraint:weakSelf.currentConstraint];</span><br><span class="line">           // [weakSelf.view.superview addConstraint:constraint];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法内部首先会根据枚举值拿到对应的NSLayoutAttribute，然后判断是否已经设置了该约束，如果是，那么直接修改该约束的值。</p><h1 id="4-设置其他约束的方法都和上述类似。相关的源码已经上传到LMlayout，具体可以查看github"><a href="#4-设置其他约束的方法都和上述类似。相关的源码已经上传到LMlayout，具体可以查看github" class="headerlink" title="4 设置其他约束的方法都和上述类似。相关的源码已经上传到LMlayout，具体可以查看github."></a>4 设置其他约束的方法都和上述类似。相关的源码已经上传到<a href="https://github.com/codemonkeybulucck/LMLayout.git" target="_blank" rel="noopener">LMlayout</a>，具体可以查看github.</h1>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链式编程 </tag>
            
            <tag> masonry </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用xcode7创建静态库和动态库的完整过程</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8xcode7%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8xcode7%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>1、创建项目<br>     首先先创建一个简单的iOS项目用来测试SDK,创建完成项目结构如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-2d001ae1cb482cf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_2.png"></p><pre><code>点击项目名称，在右侧Target选项中点击加号，在选择面板中选择cocoa touch framework，然后点击next.然后填写SDK的名字，然后点击finish.最后targets选项的项目如下图所示：其中最下面的SDK就是我创建的库。 </code></pre><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/2269918-4d405ac4ab0736c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_6.png"></p><p>2、编写framework的代码</p><pre><code>在你的framework文件夹下面右键add file,然后开始编码，这里就不细说了，和平时写的类一样，只是一定要保证你的文件是在你创建的framework里面.然后在.h头文件中提供给外界使用的方法属性等。 </code></pre><p>3、配置项目<br>       上面我们已经创建好了项目并且逻辑代码都写好了，接下来 需要对项目做一些配置，Let’s do it.<br>        首先对framework进行一些基本的设置，根据自身需要来设置，还是在targets选选中你的framework的名字，然后在buildsetting那里找到architectures设置支持的指令集，默认是没有支持armv7s的，所以我们要手动添加,点击右边的选项，然后选择other，然后在弹出框中点击下面的加号，然后添加 armv7s 。<br>最后添加完成如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-59032cb28bc05ea5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_12.png"></p><pre><code>设置iOS deployment target ，表示最低支持iOS的系统版本，根据个人情况来选择，一般如果是动态库，那么是8.0，如果是静态库是7.0。</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2269918-d818da50d7feb629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_14.png"></p><pre><code> 3.3设置静态库支持bitcode如下图所示：设置other c flag ,在release那里添加 -fembed-bitcode 。</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2269918-b36e816bdf656190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_15.png"></p><pre><code>如果要忽略一些警告，还可以在other warning flag那里输入一些值，具体可以[看这里](http://www.cocoachina.com/ios/20141218/10678.html)。</code></pre><p>因为你正在创建framework供他人使用，最好禁掉这些功能（无效代码和debug用符号），让用户自己选择对自己的项目有利的部分使用。和之前一样，使用搜索框，改变下述设置：</p><p>Dead Code Stripping设置为NO<br>Strip Debug Symbol During Copy 全部设置为NO<br>Strip Style设置为Non-Global Symbols<br>如果使用了category ，则使用该FMWK的程序运行时会crash，此时需要在该工程中 other linker flags 添加两个参数  -ObjC -all_load<br>编译出Framework是，需要把 GenerateDebugSymbols ＝NO，否则会出现很多 warning:例如 .pcm not such file or directory</p><pre><code>设置framework为动态库或者静态库。Dynamic library为动态库，Static library为静态库。</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2269918-bc8e490d8dfce2db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_17.png"></p><pre><code>然后切换到Build Phases选项卡中，打开headers,将你要提供给外界使用的头文件暴露出来，默认该文件都是在Project里面的</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2269918-92591c752e446d3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_20.png"></p><pre><code>然后将要供外界使用的头文件拖拽到public下面。</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2269918-79313d39dd49ec9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_21.png"></p><p>   到这里framework的的设置就完成了，接下来可以设置项目来使用framework。</p><p>4、项目引用framework<br>   在左上角的导航栏那里选择刚开始创建的测试项目，然后选择edit scheme</p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-ab5090e09a8d52ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_23.png"></p><p>   在Run选项那里，点击右侧下面的加号，然后在弹出面板选择我们创建的framework,点击<br>close。<br>   然后就可以在项目中引入头文件使用里面的类。</p><p>5.关于framework打包<br>   在左上角的导航栏那里选择创建的framework,然后点击edit scheme</p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-4211e1987ad9c783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_26.png"></p><p>然后在Run选项中，将build configuration 设置为release </p><p><img src="http://upload-images.jianshu.io/upload_images/2269918-b67e5780656efc65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20160830_28.png"></p><p>如果build的时候选择的是模拟器，那么编译出来的framework就是可以在模拟器上运行的，但是真机不行，如果想在真机使用，build的时候必须选择真机。</p><p>可以使用 lipo -info 来查看framework支持的cpu<br>可以使用lipo -create  来合并两个framework </p><p>需要注意的是，如果是使用了合并模拟器和真机结构的静态库，上传到app么没有问题，如果是使用了合并模拟器和真机结构的冬天库，archive的时候会报错，错误信息大致是不能包含用i386或者x86-64架构的framework，所以发布的时候记得使用真机版本的framework.</p><p>以上只是个人对于framework的一些探究，如果有什么纰漏或者错误的地方，欢迎指正。</p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDK </tag>
            
            <tag> 动态库 </tag>
            
            <tag> 静态库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS使用AMR进行编码和解码</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%BD%BF%E7%94%A8AMR%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%BD%BF%E7%94%A8AMR%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>在上一篇文章中将采样率为16K的amr的库编译出来了，并且已经放到github上面：<br> <a href="https://github.com/codemonkeybulucck/opencore-vo-amrwbenc-iOS" target="_blank" rel="noopener">vo-amrwbenc编译</a><br>然后我做了一个如何使用amr进行编码和解码的demo,demo里面主要包含了一个8K和16K的编解码，两种编解码方式使用的是不同的静态库，具体可以下载代码来看。<br><a href="https://github.com/codemonkeybulucck/opencore-amrDemo-iOS.git" target="_blank" rel="noopener">AMR编码和解码</a></p>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMR </tag>
            
            <tag> wav </tag>
            
            <tag> 音频开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用opencore_amr实现wav转amr(8khz,16khz)</title>
      <link href="/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8opencore-amr%E5%AE%9E%E7%8E%B0wav%E8%BD%ACamr-8khz-16khz/"/>
      <url>/2018/07/25/iOS%20%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8opencore-amr%E5%AE%9E%E7%8E%B0wav%E8%BD%ACamr-8khz-16khz/</url>
      <content type="html"><![CDATA[<blockquote><p>由于公司正在做声纹方面的开发，所以需要对语音数据做压缩，目前想到了三种压缩方式，1是AMR，2是Speex,3是Opus,这里先说第一种方式，在iOS4.0之前是可以进行amr格式的录音的，后来苹果取消了这个声音格式，但是可以使用opencore-amr来将wav格式转换为amr格式。</p></blockquote><a id="more"></a><blockquote><p>目前网上的例子大多数都是8Khz采样率的wav文件转AMR,具体可以参照<a href="http://my.oschina.net/jeans/blog/69937" target="_blank" rel="noopener">iOS音频格式之AMR和WAV互转(更新支持64位)</a>，这里也要感谢这篇博文的作者黄俊鹏，他给我提供了帮助我才找到了方法。但是我们公司由于对于声音采集样本的要求比较高，所以我们要使用16Khz的采样率，那么问题就出现了，在opencore-amr中并没有提供amr-wb的encode方法，8kHZ使用的opencore-amrnb.a的静态库，其中提供了encode和decode的方法，但是对于16Khz使用的是opencore-amrwb的静态库，其中里面只提供了decode的方法，后来通过其他资料我我才明白encode在另外一个项目vo-amrwbenc里面，如果要使用的话必须要单独编译这个项目才可以，项目下载可以看<a href="https://sourceforge.net/projects/opencore-amr/files/?source=navbar" target="_blank" rel="noopener">opencore-amr</a>，所以如果需要将16Khz wav文件转为amr文件，只需要编译这个库然后使用就可以了，如果要解码那么还是需要使用原来的opencore-amr库。</p></blockquote><p> #下面就可以编译vo-amrwebenc</p><h2 id="1-首先新建一个文件夹，将下载到的vo-amrwbenc-0-1-3-tar-gz压缩包放到里面（有可能下载下来的不一定是这个版本，因为这个库会更新，所以下面的命令也要跟着改变VERSION为对应的下载的压缩包的版本），然后进入这个文件夹，在里面创建build-sh文件-将以下脚本粘贴到文件里面"><a href="#1-首先新建一个文件夹，将下载到的vo-amrwbenc-0-1-3-tar-gz压缩包放到里面（有可能下载下来的不一定是这个版本，因为这个库会更新，所以下面的命令也要跟着改变VERSION为对应的下载的压缩包的版本），然后进入这个文件夹，在里面创建build-sh文件-将以下脚本粘贴到文件里面" class="headerlink" title="1.首先新建一个文件夹，将下载到的vo-amrwbenc-0.1.3.tar.gz压缩包放到里面（有可能下载下来的不一定是这个版本，因为这个库会更新，所以下面的命令也要跟着改变VERSION为对应的下载的压缩包的版本），然后进入这个文件夹，在里面创建build.sh文件,将以下脚本粘贴到文件里面"></a>1.首先新建一个文件夹，将下载到的vo-amrwbenc-0.1.3.tar.gz压缩包放到里面（有可能下载下来的不一定是这个版本，因为这个库会更新，所以下面的命令也要跟着改变VERSION为对应的下载的压缩包的版本），然后进入这个文件夹，在里面创建build.sh文件,将以下脚本粘贴到文件里面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">set -xe</span><br><span class="line"></span><br><span class="line"># 注意这里需要改为下载下来的压缩包的版本</span><br><span class="line">VERSION=&quot;0.1.3&quot;</span><br><span class="line"></span><br><span class="line">LIBSRCNAME=&quot;vo-amrwbenc&quot;</span><br><span class="line"></span><br><span class="line">CURRENTPATH=`pwd`</span><br><span class="line"></span><br><span class="line">mkdir -p &quot;$&#123;CURRENTPATH&#125;/src&quot;</span><br><span class="line"></span><br><span class="line"># 下载压缩包的后缀有可能是tar不一定是tar.gz，下面也要根据情况修改</span><br><span class="line">tar zxvf $&#123;LIBSRCNAME&#125;-$&#123;VERSION&#125;.tar.gz -C &quot;$&#123;CURRENTPATH&#125;/src&quot;</span><br><span class="line"></span><br><span class="line">cd &quot;$&#123;CURRENTPATH&#125;/src/$&#123;LIBSRCNAME&#125;-$&#123;VERSION&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 设置环境变量并创建lib-ios文件夹，后续生成的.a类库都会放在这个文件夹里边</span><br><span class="line"></span><br><span class="line">DEST=&quot;$&#123;CURRENTPATH&#125;/lib-ios&quot;</span><br><span class="line"></span><br><span class="line">mkdir -p &quot;$&#123;DEST&#125;&quot;</span><br><span class="line"></span><br><span class="line">ARCHS=&quot;armv7 armv7s arm64 i386 x86_64&quot;</span><br><span class="line"></span><br><span class="line">LIBS=&quot;libvo-amrwbenc.a&quot;</span><br><span class="line"></span><br><span class="line">for arch in $ARCHS; do</span><br><span class="line"></span><br><span class="line">case $arch in arm*)</span><br><span class="line"></span><br><span class="line">IOSV=&quot;-miphoneos-version-min=7.0&quot;</span><br><span class="line"></span><br><span class="line">if [ $arch == &quot;arm64&quot; ]</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">IOSV=&quot;-miphoneos-version-min=7.0&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;Building for iOS $arch ****************&quot;</span><br><span class="line"></span><br><span class="line"># 编译 $arch 环境的类库（amr类型类型）</span><br><span class="line"></span><br><span class="line">SDKROOT=&quot;$(xcrun --sdk iphoneos --show-sdk-path)&quot;</span><br><span class="line"></span><br><span class="line">CC=&quot;$(xcrun --sdk iphoneos -f clang)&quot;</span><br><span class="line"></span><br><span class="line">CXX=&quot;$(xcrun --sdk iphoneos -f clang++)&quot;</span><br><span class="line"></span><br><span class="line">CPP=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;</span><br><span class="line"></span><br><span class="line">CFLAGS=&quot;-isysroot $SDKROOT -arch $arch $IOSV -isystem $SDKROOT/usr/include -fembed-bitcode&quot;</span><br><span class="line"></span><br><span class="line">CXXFLAGS=$CFLAGS</span><br><span class="line"></span><br><span class="line">CPPFLAGS=$CFLAGS</span><br><span class="line"></span><br><span class="line">export CC CXX CFLAGS CXXFLAGS CPPFLAGS</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line"></span><br><span class="line">--host=arm-apple-darwin \</span><br><span class="line"></span><br><span class="line">--prefix=$DEST \</span><br><span class="line"></span><br><span class="line">--disable-shared --enable-static</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">*)</span><br><span class="line"></span><br><span class="line">IOSV=&quot;-mios-simulator-version-min=7.0&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;Building for iOS $arch*****************&quot;</span><br><span class="line"></span><br><span class="line">SDKROOT=`xcodebuild -version -sdk iphonesimulator Path`</span><br><span class="line"></span><br><span class="line">CC=&quot;$(xcrun -sdk iphoneos -f clang)&quot;</span><br><span class="line"></span><br><span class="line">CXX=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;</span><br><span class="line"></span><br><span class="line">CPP=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;</span><br><span class="line"></span><br><span class="line">CFLAGS=&quot;-isysroot $SDKROOT -arch $arch $IOSV -isystem $SDKROOT/usr/include -fembed-bitcode&quot;</span><br><span class="line"></span><br><span class="line">CXXFLAGS=$CFLAGS</span><br><span class="line"></span><br><span class="line">CPPFLAGS=$CFLAGS</span><br><span class="line"></span><br><span class="line">export CC CXX CFLAGS CXXFLAGS CPPFLAGS</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line"></span><br><span class="line">--prefix=$DEST \</span><br><span class="line"></span><br><span class="line">--disable-shared</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">make &gt; /dev/null</span><br><span class="line"></span><br><span class="line">make install     </span><br><span class="line"></span><br><span class="line">make clean   </span><br><span class="line"></span><br><span class="line">for i in $LIBS; do</span><br><span class="line"></span><br><span class="line">mv $DEST/lib/$i $DEST/lib/$i.$arch</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for i in $LIBS; do</span><br><span class="line"></span><br><span class="line">input=&quot;&quot;</span><br><span class="line"></span><br><span class="line">for arch in $ARCHS; do</span><br><span class="line"></span><br><span class="line">input=&quot;$input $DEST/lib/$i.$arch&quot;</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">lipo -create -output $DEST/lib/$i $input</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>##2.修改build.sh的权限，打开终端，cd到新建的文件夹，使用命令 chmod  777 build.sh 修改权限。</p><p>##3.修改完成之后在终端执行 ./build.sh 就会在vo-amrwbenc里面生成一个lib-ios文件夹，里面就包含了libvo-amrwbenc.a的静态库和enc_if_h的头文件。</p><p>最后我已经将编译好的项目放到github上面</p><p><a href="https://github.com/codemonkeybulucck/opencore-amrDemo-iOS" target="_blank" rel="noopener">vo-amrwbenc编译</a></p><h2 id="4-更新"><a href="#4-更新" class="headerlink" title="4.更新"></a>4.更新</h2><p>——————-2018.8.16更新———————————————<br>今天有收到issues说编码的效率很慢，然后需要更新open-amr的库然后重新编译，大家需要到<a href="https://sourceforge.net/projects/opencore-amr/files/?source=navbar" target="_blank" rel="noopener">opencore-amr</a>下载最新的库，然后重新编译打包静态库，下面附上打包脚本，打包方法和上面一致。同时记得要改一下脚本里面压缩报的版本和压缩后缀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/sh</span><br><span class="line">set -xe</span><br><span class="line"> </span><br><span class="line">VERSION=&quot;0.1.3&quot;</span><br><span class="line">SDKVERSION=&quot;8.4&quot;</span><br><span class="line">LIBSRCNAME=&quot;opencore-amr&quot;</span><br><span class="line"> </span><br><span class="line">CURRENTPATH=`pwd`</span><br><span class="line"> </span><br><span class="line">mkdir -p &quot;$&#123;CURRENTPATH&#125;/src&quot;</span><br><span class="line">tar zxvf $&#123;LIBSRCNAME&#125;-$&#123;VERSION&#125;.tar.gz -C &quot;$&#123;CURRENTPATH&#125;/src&quot;</span><br><span class="line">cd &quot;$&#123;CURRENTPATH&#125;/src/$&#123;LIBSRCNAME&#125;-$&#123;VERSION&#125;&quot;</span><br><span class="line"> </span><br><span class="line">DEVELOPER=`xcode-select -print-path`</span><br><span class="line">DEST=&quot;$&#123;CURRENTPATH&#125;/lib-ios&quot;</span><br><span class="line">mkdir -p &quot;$&#123;DEST&#125;&quot;</span><br><span class="line"> </span><br><span class="line">ARCHS=&quot;armv7 armv7s arm64 i386 x86_64&quot;</span><br><span class="line"># ARCHS=&quot;armv7&quot;</span><br><span class="line">LIBS=&quot;libopencore-amrnb.a libopencore-amrwb.a&quot;</span><br><span class="line"> </span><br><span class="line">DEVELOPER=`xcode-select -print-path`</span><br><span class="line"> </span><br><span class="line">for arch in $ARCHS; do</span><br><span class="line">case $arch in</span><br><span class="line">arm*)</span><br><span class="line"> </span><br><span class="line">IOSV=&quot;-miphoneos-version-min=7.0&quot;</span><br><span class="line">if [ $arch == &quot;arm64&quot; ]</span><br><span class="line">then</span><br><span class="line">IOSV=&quot;-miphoneos-version-min=7.0&quot;</span><br><span class="line">fi</span><br><span class="line"> </span><br><span class="line">echo &quot;Building for iOS $arch ****************&quot;</span><br><span class="line">SDKROOT=&quot;$(xcrun --sdk iphoneos --show-sdk-path)&quot;</span><br><span class="line">CC=&quot;$(xcrun --sdk iphoneos -f clang)&quot;</span><br><span class="line">CXX=&quot;$(xcrun --sdk iphoneos -f clang++)&quot;</span><br><span class="line">CPP=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;</span><br><span class="line">CFLAGS=&quot;-isysroot $SDKROOT -arch $arch $IOSV -isystem $SDKROOT/usr/include -fembed-bitcode&quot;</span><br><span class="line">CXXFLAGS=$CFLAGS</span><br><span class="line">CPPFLAGS=$CFLAGS</span><br><span class="line">export CC CXX CFLAGS CXXFLAGS CPPFLAGS</span><br><span class="line"> </span><br><span class="line">./configure \</span><br><span class="line">--host=arm-apple-darwin \</span><br><span class="line">--prefix=$DEST \</span><br><span class="line">--disable-shared --enable-static</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">IOSV=&quot;-mios-simulator-version-min=7.0&quot;</span><br><span class="line">echo &quot;Building for iOS $arch*****************&quot;</span><br><span class="line"> </span><br><span class="line">SDKROOT=`xcodebuild -version -sdk iphonesimulator Path`</span><br><span class="line">CC=&quot;$(xcrun -sdk iphoneos -f clang)&quot;</span><br><span class="line">CXX=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;</span><br><span class="line">CPP=&quot;$(xcrun -sdk iphonesimulator -f clang++)&quot;</span><br><span class="line">CFLAGS=&quot;-isysroot $SDKROOT -arch $arch $IOSV -isystem $SDKROOT/usr/include -fembed-bitcode&quot;</span><br><span class="line">CXXFLAGS=$CFLAGS</span><br><span class="line">CPPFLAGS=$CFLAGS</span><br><span class="line">export CC CXX CFLAGS CXXFLAGS CPPFLAGS</span><br><span class="line">./configure \</span><br><span class="line">--prefix=$DEST \</span><br><span class="line">--disable-shared</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">make &gt; /dev/null</span><br><span class="line">make install</span><br><span class="line">make clean</span><br><span class="line">for i in $LIBS; do</span><br><span class="line">mv $DEST/lib/$i $DEST/lib/$i.$arch</span><br><span class="line">done</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line">for i in $LIBS; do</span><br><span class="line">input=&quot;&quot;</span><br><span class="line">for arch in $ARCHS; do</span><br><span class="line">input=&quot;$input $DEST/lib/$i.$arch&quot;</span><br><span class="line">done</span><br><span class="line">lipo -create -output $DEST/lib/$i $input</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMR </tag>
            
            <tag> wav </tag>
            
            <tag> 音频开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用hexo在github上搭建自己的博客</title>
      <link href="/2018/07/25/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/%E4%BD%BF%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/07/25/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/%E4%BD%BF%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><blockquote><p>hexo是node.js提供的一个强大的，并且简单快速搭建自己博客的工具，通过该工具可以快速的搭建起自己的博客，该工具还提供了一系列的主题，可以快捷的设置不同主题。通过修改几个命令就可以将搭建好的博客部署到github上。<br>下面将会讲解如何1.通过hexo搭建自己的博客 2.如何设置博客的主题 3.如何应用到github 4.域名关联，通过自己的域名访问博客</p></blockquote><a id="more"></a><h2 id="0x02-准备工作"><a href="#0x02-准备工作" class="headerlink" title="0x02 准备工作"></a>0x02 准备工作</h2><blockquote><p>在开始工作之前你需要做一些准备工作</p></blockquote><ul><li>创建一个github账号，如果没有的话</li><li>安装node.js</li><li>安装npm</li></ul><h2 id="0x03-LET’S-DO-IT"><a href="#0x03-LET’S-DO-IT" class="headerlink" title="0x03 LET’S DO IT"></a>0x03 LET’S DO IT</h2><p>1、 首先在登录你的github账号，并且创建一个仓库，这个仓库的名字一定要按照<code>特定的格式</code>来写：也就是你的 <code>用户名.github.io</code>，如下图所示：<br><img src="http://pcd17v2u0.bkt.clouddn.com/15324821682415.jpg" alt=""><br>由于我之前已经创建过相同命名的仓库，所以会提示我已经重复了，以上的截图只是用于做仓库命名的示例，切记仓库的名字一定是 <code>用户名.github.io</code></p><p>2、 如果github上面没有配置SSH的话需要在本地生成一个公钥，然后配置到github上面。（如果已经配置的可以直接看第三步）<br>     使用以下命令创建一对公私秘钥</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; //创建秘钥，执行该命令后一直回车即可</span><br><span class="line">$ cat ~/.ssh/id_rsa.pub  //创建完成后查看创建好的公钥</span><br></pre></td></tr></table></figure></code></pre><p>   将上面创建好的公钥复制，然后登录github, 按照Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key的步骤，粘贴公钥即可。</p><p>3、 安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><p>4、 初始化目录在本地创建一个文件夹，可以随便起一个名字， 然后进入到该文件夹里面，通过hexo init初始化，初始化完成后会在该文件夹里面生成一些文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lemons-MacBookPro:~ lemon$ mkdir hexo</span><br><span class="line">Lemons-MacBookPro:~ lemon$ cd hexo/</span><br><span class="line">Lemons-MacBookPro:hexo lemon$ hexo init</span><br></pre></td></tr></table></figure><p>生成的目录如下所示：<br><img src="http://pcd17v2u0.bkt.clouddn.com/15324833176604.jpg" alt=""></p><p>5、 修改 _config.yml: 配置文件，可以在里面配置博客的名字，描述，主题，部署到哪里等等，下面来看一下里面主要需要修改的地方。<br>设置博客网站的标题，副标题，描述，作者的名字，语言，时区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  # Site</span><br><span class="line">title: Lemon&apos;s blog</span><br><span class="line">subtitle: Talk is cheap show me the code</span><br><span class="line">description: iOS Developer | 拥抱变化 | 🍋😊</span><br><span class="line">keywords: </span><br><span class="line">author: lemon</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure><p>需要部署到哪个平台,你需要修改的地方是repo，将仓库的地址换成在第一步创建的仓库地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:codemonkeybulucck/codemonkeybulucck.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>6、在本地浏览器查看博客的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate # 生成，可以用简写 hexo g</span><br><span class="line">$ hexo server # 启动服务，可以用简写 hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">WARN  ========================= ATTENTION! ==========================</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">WARN   NexT repository is moving here: https://github.com/theme-next</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">WARN   It&apos;s rebase to v6.0.0 and future maintenance will resume there</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>这样就会将博客部署到本地，在浏览器打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可访问</p><p>7、在第六步中我们看到的生成默认主题的博客，我们也许想换成更加符合我们审美的主题。 我们可以在 <a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">hexo有哪些好看的主题</a>这里找到我们自己喜欢的主题，下面以 hexo-theme-next 为例。 还是在我们的博客目录，下载主题到该目录下的theme文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><p>下载完成之后，打开_config.yml文件修改以下地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>将原来的默认的主题改为next，然后执行hexo server 来重新生成本地博客，这个时候在浏览器查看会发现主题和之前的不一样了。你还可以在theme-&gt;next-&gt;_config.yml文件夹里面修改布局，可以设置下面四个中任意的一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure><p>8、 到此为止我们已经搭建好博客并且设置了相应的主题，下面我们来试一下写一篇博客。博客的类型是markdown格式，可以下载一个Mweb来提前写好文章然后复制到source-&gt;_posts文件夹里面，也通过通过 hexo new post “博客名字”来生成一个markdown类型的博客</p><p>9、上传到github，由于我们在第5点已经设置了github的地址，因此我们直使用 <code>hexo deploy</code>来上传即可。<br>如果发现执行以上命令后有如下错误<br><code>Deployer not found: github 或者 Deployer not found: git</code><br>则需要先安装一个插件</p><p><code>npm install hexo-deployer-git --save</code><br>安装完该插件之后继续执行 <code>hexo deploy</code> 即可通过 <code>你的用户名.github.io</code>来访问你的博客。下面是我的博客 <a href="http://codemonkeybulucck.github.io" target="_blank" rel="noopener">codemonkeybulucck</a></p><p>10、绑定域名，如果没有域名的可以到<a href="https://wanwang.aliyun.com/?utm_content=se_1000094076" target="_blank" rel="noopener">阿里万网</a> 购买一个域名，<br>购买完成后到控制台找到对应的域名，添加解析，域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问<br>按照我下面的设置即可<br><img src="http://pcd17v2u0.bkt.clouddn.com/15324859351285.jpg" alt=""></p><p>设置完成之后还不可以立刻使用域名访问，需要到本地的博客的目录下的source文件夹里面创建一个CNAME文件，里面填写购买的域名<br>然后重新 <code>hexo deploy</code>之后就可以通过域名来访问你的博客了。</p><h2 id="0x04-以上，希望能帮助到你。"><a href="#0x04-以上，希望能帮助到你。" class="headerlink" title="0x04 以上，希望能帮助到你。"></a>0x04 以上，希望能帮助到你。</h2>]]></content>
      
      <categories>
          
          <category> 其他技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/24/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/hello-world/"/>
      <url>/2018/07/24/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
